{"meta":{"title":"Hanson的博客","subtitle":null,"description":null,"author":"Hanson Zhang","url":"http://myhanson.com"},"pages":[{"title":"Categories","date":"2017-11-09T03:42:36.037Z","updated":"2017-11-09T03:36:31.247Z","comments":true,"path":"categories/index.html","permalink":"http://myhanson.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-11-09T03:42:36.048Z","updated":"2017-11-09T03:36:31.248Z","comments":true,"path":"tags/index.html","permalink":"http://myhanson.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"通过RunScript给iOS项目自增版本号(Versioin和Build)","slug":"通过RunScript给iOS项目自增版本号(Versioin和Build)","date":"2018-03-13T16:38:20.000Z","updated":"2018-03-13T16:39:14.111Z","comments":true,"path":"2018/03/14/通过RunScript给iOS项目自增版本号(Versioin和Build)/","link":"","permalink":"http://myhanson.com/2018/03/14/通过RunScript给iOS项目自增版本号(Versioin和Build)/","excerpt":"需求分析 在打包应用之后，需要自增 Version 的最后一位 和 Build 的值。 只在 Archive(Release) 的时候触发该自增。","text":"需求分析 在打包应用之后，需要自增 Version 的最后一位 和 Build 的值。 只在 Archive(Release) 的时候触发该自增。 添加 RunScript在 项目Target -&gt; Build Phases -&gt; 点击+号 -&gt; New Run Script Phase 然后添加如下内容：1234567891011121314151617181920if [ $CONFIGURATION == Release ]; thenecho \"当前为 Release Configuration,开始自增 Build\"plist=$&#123;INFOPLIST_FILE&#125;buildnum=$(/usr/libexec/PlistBuddy -c \"Print CFBundleVersion\" \"$&#123;plist&#125;\")if [[ \"$&#123;buildnum&#125;\" == \"\" ]]; thenecho \"Error：在Plist文件里没有 Build 值\"exit 2fibuildnum=$(expr $buildnum + 1)/usr/libexec/PlistBuddy -c \"Set CFBundleVersion $buildnum\" \"$&#123;plist&#125;\"echo \"开始自增 Version 最后一位\"versionNum=$(/usr/libexec/PlistBuddy -c \"Print CFBundleShortVersionString\" \"$&#123;plist&#125;\")thirdPartVersonNum=`echo $versionNum | awk -F \".\" '&#123;print $3&#125;'`thirdPartVersonNum=$(($thirdPartVersonNum + 1))newVersionStr=`echo $versionNum | awk -F \".\" '&#123;print $1 \".\" $2 \".'$thirdPartVersonNum'\" &#125;'`/usr/libexec/PlistBuddy -c \"Set CFBundleShortVersionString $newVersionStr\" \"$&#123;plist&#125;\"elseecho $CONFIGURATION \"当前不为 Release Configuration\"fi 注意因为我的版本号是xx.xx.xx这样的形式，所以我以 . 拆分版本号后，取出第三个值来增加，最后再拼接回来。123versionNum=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleShortVersionString&quot; &quot;$&#123;plist&#125;&quot;)# 这里取出第三个值thirdPartVersonNum=`echo $versionNum | awk -F &quot;.&quot; &apos;&#123;print $3&#125;&apos;`","categories":[],"tags":[]},{"title":"PathToGo诞生记","slug":"PathToGo诞生记","date":"2018-03-02T02:44:10.000Z","updated":"2018-03-02T02:44:39.058Z","comments":true,"path":"2018/03/02/PathToGo诞生记/","link":"","permalink":"http://myhanson.com/2018/03/02/PathToGo诞生记/","excerpt":"不知道大家在使用 Mac 的时候有没有这样的需求: 经常需要获取当前文件或者文件夹的路径，并且复制到粘贴板。 对于我来说经常有这种需要，然后我就从网上再结合自己的经验，找了好几种方法：","text":"不知道大家在使用 Mac 的时候有没有这样的需求: 经常需要获取当前文件或者文件夹的路径，并且复制到粘贴板。 对于我来说经常有这种需要，然后我就从网上再结合自己的经验，找了好几种方法： 右键-选择「显示简介」，然后在弹出的窗口里直接用鼠标拖动复制「位 置」里的路径。 ​ 缺点：麻烦。 把文件拖到浏览器，在浏览器地址栏复制路径。 ​ 缺点：麻烦。 打开终端，把文件拖入终端，终端会把文件路径打印出来，然后复制。 ​ 缺点：麻烦。 打开终端，cd到目标目录，然后输入 「pwd|pbcopy」就可以把路径复制到粘贴板。 ​ 缺点：麻烦。 选择文件，然后使用快捷键「Option + Command + C」。 ​ 缺点：这个快捷键在更低版本的系统中好像不行，而且会与 Alfred 的一个快捷键冲突。还是麻烦。 利用 Automator 来建立 Service 服务添加到右键服务菜单。 ​ 缺点：麻烦。 以上几种方法都不能满足我的需求： 直观快捷 最好可以同时获取多个文件/文件夹的路径。 这时候我想起了很受大家欢迎的一款效率软件：Go2Shell 这款软件把它拖动到 Finder 的工具栏后，只要点击它就可以立刻启动终端，并且进入到当前的路径。 那可以不可以也做一款这样的 App 操作和 Go2Shell 类似，选中一个或多个文件或文件夹然后直接一点，就可以把当前选中的文件或文件夹路径复制到粘贴板呢？ 然后经过一番折腾，『PathToGo』这款 App 就诞生了。 虽然一开始是想直接利用 AppleScript 然后导出为应用程序的，可是看着 AppleScript 导出为应用程序的图标实在不够酷，就直接着手做了 PathToGo 这个简单的 Mac App。 下面看看实际体验效果吧： 首先是把『PathToGo』拖动到 Finder 的工具栏，记得是按住『command键』来进行拖动。 拖放好了之后，只需要选中你想要的一个或多个文件/文件夹，然后点击在工具栏上的『PathToGo』的图标，路径就已经复制到粘贴板上了，然后你就能愉快的 用 command+v 就能粘贴出你选择的文件的路径了。 怎么样？是不是很方便快捷呢！PathToGo 已经开源在 HansonStudio 的 Github 组织下了，大家可以在 Release 页面下载使用。","categories":[],"tags":[]},{"title":"用SwiftGen管理UIImage等的String-based接口","slug":"用SwiftGen管理UIImage等的String-based接口","date":"2017-12-08T07:15:21.000Z","updated":"2018-01-04T16:38:43.900Z","comments":true,"path":"2017/12/08/用SwiftGen管理UIImage等的String-based接口/","link":"","permalink":"http://myhanson.com/2017/12/08/用SwiftGen管理UIImage等的String-based接口/","excerpt":"问题现状平时我们使用UIImage，UIFont，UIColor会遇到很多String-based的接口方法，比如常用的UIImage：1let testImage = UIImage(named: \"test\") 对于上面的代码，如果我们把 test 拼写错了，Xcode 并不会给出提示，只有当我们运行的时候才会收到报错，这样维护起来是有一定成本的。","text":"问题现状平时我们使用UIImage，UIFont，UIColor会遇到很多String-based的接口方法，比如常用的UIImage：1let testImage = UIImage(named: \"test\") 对于上面的代码，如果我们把 test 拼写错了，Xcode 并不会给出提示，只有当我们运行的时候才会收到报错，这样维护起来是有一定成本的。 代码解决我们可以用类似如下的代码来解决这个问题：1234567891011121314151617181920212223242526import UIKit.UIImagestruct ImageAssets &#123; fileprivate var name: String var image: UIImage &#123; let image = UIImage(named: name) guard let result = image else &#123; fatalError(\"Unable to load image named \\(name).\") &#125; return result &#125;&#125;enum Assets &#123; enum AppLogo &#123; static let appLogo = ImageAssets(name: \"appLogo\") static let grayLogo = ImageAssets(name: \"gray_logo\") &#125; enum Arrow &#123; static let arrowBlue = ImageAssets(name: \"arrow_blue\") static let arrowBrown = ImageAssets(name: \"arrow_brown\") &#125; // ....&#125;extension UIImage &#123; convenience init!(asset: ImageAssets) &#123; self.init(named: asset.name) &#125;&#125; 利用上面的代码，我们在新建 UIImage 的时候就不需要去想图片的名字了，而且 Xcode 还会有代码提示：12let logo = Asset.AppLogo.appLogo.imagelet grayLogo = UIImage(asset: Asset.AppLogo.grayLogo) 存在问题虽然这种方法在调用的时候简单又安全了，但是项目中的图片往往比较多，如果手动编写维护那段代码也是需要不少精力，而且不能保证后续不会添加新的图片，这样每次都要去维护那段代码不免有些反人类。那么现在就要介绍这个开源项目— SwiftGen了！ SwiftGen is a tool to auto-generate Swift code for resources of your projects, to make them type-safe to use. 利用 SwiftGen 可以帮我们生成这类的代码，但是 SwiftGen 默认生成的代码样式有时候并不是我们想要的，而且默认生成还会有针对 macOS 上的代码，比较好的是 SwiftGen 提供了模板的功能，我们可以按自己的需要来修改模板。 集成 SwiftGen 在项目中SwiftGen 提供了好几种的集成方式，我这里只介绍我自己比较喜欢的方式：就是通过下载它的 Zip 文件解压到项目的目录中，然后通过添加 Run Script 来进行管理。这样可以基本做到不用操心代码。 1.修改模板 到 SwiftGen仓库的Release页面下载最新的 swiftgen-5.2.1.zip 将解压后的 swiftgen-5.2.1 文件夹放到项目所在的目录下(存放xxx.xcodeproj 的位置)，可以将文件夹的名字改为SwiftGen5简洁一点。 进入到 SwiftGen5 里的 templates/xcassets 目录下，这里面可以看到有不少模板，我们选择 swift4.stencil 复制一份，命名为 my-swift4.stencil 然后我们就可以在里面修改我们自己想要的模板，我主要是想把 macOS 等其它平台的一些判断代码给删掉:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// Generated using SwiftGen, using my-templete created by Hanson&#123;% if catalogs %&#125;&#123;% set imageAlias %&#125;&#123;&#123;param.imageAliasName|default:\"Image\"&#125;&#125;&#123;% endset %&#125;import UIKit.UIImagetypealias &#123;&#123;imageAlias&#125;&#125; = UIImage&#123;% set enumName %&#125;&#123;&#123;param.enumName|default:\"Asset\"&#125;&#125;&#123;% endset %&#125;&#123;% set imageType %&#125;&#123;&#123;param.imageTypeName|default:\"ImageAsset\"&#125;&#125;&#123;% endset %&#125;@available(*, deprecated, renamed: \"&#123;&#123;imageType&#125;&#125;\")typealias &#123;&#123;enumName&#125;&#125;Type = &#123;&#123;imageType&#125;&#125;struct &#123;&#123;imageType&#125;&#125; &#123;fileprivate var name: Stringvar image: &#123;&#123;imageAlias&#125;&#125; &#123;let bundle = Bundle(for: BundleToken.self)let image = &#123;&#123;imageAlias&#125;&#125;(named: name, in: bundle, compatibleWith: nil)guard let result = image else &#123; fatalError(\"Unable to load image named \\(name).\") &#125;return result&#125;&#125;&#123;% macro enumBlock assets sp %&#125;&#123;&#123;sp&#125;&#125; &#123;% call casesBlock assets sp %&#125;&#123;&#123;sp&#125;&#125; &#123;% if not param.noAllValues %&#125;&#123;&#123;sp&#125;&#125; &#123;% endif %&#125;&#123;% endmacro %&#125;&#123;% macro casesBlock assets sp %&#125;&#123;&#123;sp&#125;&#125; &#123;% for asset in assets %&#125;&#123;&#123;sp&#125;&#125; &#123;% if asset.type == \"color\" %&#125;&#123;&#123;sp&#125;&#125; static let &#123;&#123;asset.name|swiftIdentifier:\"pretty\"|lowerFirstWord|escapeReservedKeywords&#125;&#125; = &#123;&#123;colorType&#125;&#125;(name: \"&#123;&#123;asset.value&#125;&#125;\")&#123;&#123;sp&#125;&#125; &#123;% elif asset.type == \"image\" %&#125;&#123;&#123;sp&#125;&#125; static let &#123;&#123;asset.name|swiftIdentifier:\"pretty\"|lowerFirstWord|escapeReservedKeywords&#125;&#125; = &#123;&#123;imageType&#125;&#125;(name: \"&#123;&#123;asset.value&#125;&#125;\")&#123;&#123;sp&#125;&#125; &#123;% elif asset.items %&#125;&#123;&#123;sp&#125;&#125; enum &#123;&#123;asset.name|swiftIdentifier:\"pretty\"|escapeReservedKeywords&#125;&#125; &#123;&#123;&#123;sp&#125;&#125; &#123;% set sp2 %&#125;&#123;&#123;sp&#125;&#125; &#123;% endset %&#125;&#123;&#123;sp&#125;&#125; &#123;% call casesBlock asset.items sp2 %&#125;&#123;&#123;sp&#125;&#125; &#125;&#123;&#123;sp&#125;&#125; &#123;% endif %&#125;&#123;&#123;sp&#125;&#125; &#123;% endfor %&#125;&#123;% endmacro %&#125;&#123;% macro allValuesBlock assets filter prefix sp %&#125;&#123;&#123;sp&#125;&#125; &#123;% for asset in assets %&#125;&#123;&#123;sp&#125;&#125; &#123;% if asset.type == filter %&#125;&#123;&#123;sp&#125;&#125; &#123;&#123;prefix&#125;&#125;&#123;&#123;asset.name|swiftIdentifier:\"pretty\"|lowerFirstWord|escapeReservedKeywords&#125;&#125;,&#123;&#123;sp&#125;&#125; &#123;% elif asset.items %&#125;&#123;&#123;sp&#125;&#125; &#123;% set prefix2 %&#125;&#123;&#123;prefix&#125;&#125;&#123;&#123;asset.name|swiftIdentifier:\"pretty\"|escapeReservedKeywords&#125;&#125;.&#123;% endset %&#125;&#123;&#123;sp&#125;&#125; &#123;% call allValuesBlock asset.items filter prefix2 sp %&#125;&#123;&#123;sp&#125;&#125; &#123;% endif %&#125;&#123;&#123;sp&#125;&#125; &#123;% endfor %&#125;&#123;% endmacro %&#125;enum &#123;&#123;enumName&#125;&#125; &#123;&#123;% if catalogs.count &gt; 1 %&#125;&#123;% for catalog in catalogs %&#125;enum &#123;&#123;catalog.name|swiftIdentifier:\"pretty\"|escapeReservedKeywords&#125;&#125; &#123;&#123;% call enumBlock catalog.assets \" \" %&#125;&#125;&#123;% endfor %&#125;&#123;% else %&#125;&#123;% call enumBlock catalogs.first.assets \"\" %&#125;&#123;% endif %&#125;&#125;extension &#123;&#123;imageAlias&#125;&#125; &#123;convenience init!(asset: &#123;&#123;imageType&#125;&#125;) &#123;let bundle = Bundle(for: BundleToken.self)self.init(named: asset.name, in: bundle, compatibleWith: nil)&#125;&#125;private final class BundleToken &#123;&#125;&#123;% else %&#125;// No assets found&#123;% endif %&#125; 2.建立RunScript 在Xcode中，进入到项目的Target，选择Build Phases,然后点击左上角的 + 号后点击 New Run Script Phase在新建的RunScript里添加如下内容： 1234567if which \"$PROJECT_DIR\"/SwiftGen5/bin/swiftgen &gt;/dev/null;thenset -e\"$PROJECT_DIR\"/SwiftGen5/bin/swiftgen xcassets -t my-swift4 \"$PROJECT_DIR/swiftGenExample/Assets.xcassets\" --output \"$PROJECT_DIR/swiftGenExample/ImageCode/ImageAsset.swift\"elseecho \"##run echo warning: SwiftGen not installed, download it from https://github.com/SwiftGen/SwiftGen\"fi 这段 Run Script 作用就是利用 SwiftGen 生成代码后写入到 ImageAsset.swift 文件中。 Build 一下project，我们就可以在 /swiftGenExample/ImageCode/ 目录下看到 ImageAsset.swift，此时该文件还没有被项目索引，所以把它拖进项目Xcode对应的目录下就行了，之后即使我们添加了新的图片或者删掉旧的图片，只要每次Build一下项目，代码就会自动更新了。 下面是生成的 ImageAsset.swift 的代码：123456789101112131415161718192021222324252627282930313233343536// ImageAsset.swift// Generated using SwiftGen, using my-templete created by Hansonimport UIKit.UIImagetypealias Image = UIImage@available(*, deprecated, renamed: \"ImageAsset\")typealias AssetType = ImageAssetstruct ImageAsset &#123; fileprivate var name: String var image: Image &#123; let bundle = Bundle(for: BundleToken.self) let image = Image(named: name, in: bundle, compatibleWith: nil) guard let result = image else &#123; fatalError(\"Unable to load image named \\(name).\") &#125; return result &#125;&#125;enum Asset &#123; static let arrowBlue = ImageAsset(name: \"arrow_blue\") static let arrowBrown = ImageAsset(name: \"arrow_brown\") static let iconLeftBack = ImageAsset(name: \"icon_left_back\") static let startLogo = ImageAsset(name: \"start_logo\")&#125;extension Image &#123; convenience init!(asset: ImageAsset) &#123; let bundle = Bundle(for: BundleToken.self) self.init(named: asset.name, in: bundle, compatibleWith: nil) &#125;&#125;private final class BundleToken &#123;&#125; 结语这里只是利用了 SwiftGen 对于 Image 的部分。它还有其它的关于 String ，StroyBoard，Font等等的代码生成。原理基本相同，靠大家按需研究啦。 到我的博客阅读：myhanson.com本文Demo：SwiftGenExample","categories":[],"tags":[]},{"title":"Swift 实现启动屏动画","slug":"Swift 实现启动屏动画","date":"2017-12-08T02:13:30.000Z","updated":"2017-12-22T02:05:53.711Z","comments":true,"path":"2017/12/08/Swift 实现启动屏动画/","link":"","permalink":"http://myhanson.com/2017/12/08/Swift 实现启动屏动画/","excerpt":"Github: SplashAnimate 准备工作：首先我们需要确定作为宣传的图片的宽高比，这个一般是与 UI 确定的。一般启动屏展示会有上下两部分，上面是宣传图片，下面是 App 的 Logo。 实现基本思路：在 LaunchScreen 结束后，在 AppDelegate 中将 rootViewController 指向展示广告用的 AdViewController，在AdViewController 中设置一段时间后自己销毁，并提供回调方法在 AppDelegate 中将 rootViewController 指向 App 真正的首页。","text":"Github: SplashAnimate 准备工作：首先我们需要确定作为宣传的图片的宽高比，这个一般是与 UI 确定的。一般启动屏展示会有上下两部分，上面是宣传图片，下面是 App 的 Logo。 实现基本思路：在 LaunchScreen 结束后，在 AppDelegate 中将 rootViewController 指向展示广告用的 AdViewController，在AdViewController 中设置一段时间后自己销毁，并提供回调方法在 AppDelegate 中将 rootViewController 指向 App 真正的首页。 实现细节：新建一个 AdViewController 用于放置广告宣传等展示.注意有一个回调方法。1234567891011class AdViewController: UIViewController &#123; // 用于 AdViewController 销毁后的回调 var completion: (() -&gt; Void)? var adImage: UIImage? var adView: UIImageView? override func viewDidLoad() &#123; // .... &#125;&#125; 在 ViewDidLoad 方法中配置广告图,同时判断 iPhoneX的特殊情况123456789101112131415161718192021222324252627override func viewDidLoad() &#123; super.viewDidLoad() var adViewHeight = (1040 / 720) * screenWidth var imageName = \"start_page\" if UIDevice.isiPhoneX() &#123; adViewHeight = (1920 / 1124) * screenWidth imageName = \"start_page_x\" &#125; adView = UIImageView(frame: CGRect(x: 0, y: 0, width: screenWidth, height: adViewHeight)) adView?.image = UIImage(named: imageName) adView?.contentMode = .scaleAspectFill self.view.addSubview(adView!) let bottomHolderView = UIView(frame: CGRect(x: 0, y: screenHeight-120, width: screenWidth, height: 120)) self.view.addSubview(bottomHolderView) let logo = UIImageView(frame: CGRect(x: (screenWidth-120)/2, y: (120-50)/2, width: 120, height: 50)) logo.image = UIImage(named: \"start_logo\") bottomHolderView.addSubview(logo) let time: TimeInterval = 1.0 DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + time) &#123; self.dismissAdView() &#125;&#125; 上面代码中有几个注意的: 因为图片要撑满屏幕的宽度，所以宽度是固定的，根据图片的高宽比，算出图片实际应有的高度，这样图片可以在各个尺寸的 iPhone 中才不会因为拉伸而变形。但是因为 iPhoneX 特殊的宽高比，所以还是要为它特定一张图片，不然即使图片在 iPhoneX 上不变形，图片所占的高度会太小，或者顶部被刘海遮挡内容而不美观。123456var adViewHeight = (1040 / 720) * screenWidthvar imageName = \"start_page\"if UIDevice.isiPhoneX() &#123; adViewHeight = (1920 / 1124) * screenWidth imageName = \"start_page_x\"&#125; 上面判断是否为 iPhoneX 我是在 UIDevice 里扩展了一个方法：12345678extension UIDevice &#123; public static func isiPhoneX() -&gt; Bool &#123; if UIScreen.main.bounds.height == 812 &#123; return true &#125; return false &#125;&#125; 还有注意在执行销毁时调用回调方法1234let time: TimeInterval = 1.0DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + time) &#123; self.dismissAdView()&#125; 在 AppDelegate 中 didFinishLaunchingWithOptions 方法中调用下面的 setUpWindowAndRootView() 来管理页面展示123456789101112131415extension AppDelegate &#123; func setUpWindowAndRootView() &#123; window = UIWindow(frame: UIScreen.main.bounds) window!.backgroundColor = UIColor.white window!.makeKeyAndVisible() let adVC = AdViewController() adVC.completion = &#123; let vc = ViewController() vc.adView = adVC.view self.window!.rootViewController = vc &#125; window!.rootViewController = adVC &#125;&#125; 注意在 AdViewController 销毁的回调方法中，将 AdViewController 的 view 传给真正的首页，让首页来执行动画123456adVC.completion = &#123; let vc = ViewController() // 将 AdViewController 的 view 传给真正的首页，让首页来执行动画 vc.adView = adVC.view self.window!.rootViewController = vc&#125; 在首页 ViewController 里我们有如下方法来执行 AdViewController 的销毁动画，这里配置的动画是常见的扩大渐变消失123456789101112131415private var advertiseView: UIView?var adView: UIView? &#123; didSet &#123; advertiseView = adView! advertiseView?.frame = self.view.bounds self.view.addSubview(advertiseView!) UIView.animate(withDuration: 1.5, animations: &#123; [weak self] in self?.advertiseView?.transform = CGAffineTransform(scaleX: 1.2, y: 1.2) self?.advertiseView?.alpha = 0 &#125;) &#123; [weak self] (isFinish) in self?.advertiseView?.removeFromSuperview() self?.advertiseView = nil &#125; &#125;&#125; 至此，一个简单的启动屏动画就完成了。","categories":[],"tags":[]},{"title":"记一次失败的 Swift 元组数组实践","slug":"记一次失败的 Swift 元组数组实践","date":"2017-11-28T08:01:34.000Z","updated":"2017-11-28T08:24:40.487Z","comments":true,"path":"2017/11/28/记一次失败的 Swift 元组数组实践/","link":"","permalink":"http://myhanson.com/2017/11/28/记一次失败的 Swift 元组数组实践/","excerpt":"想建立一个元组的数组，来简单存放构建 TabViewController 的信息首先我的做法是1234567let homeTab = (vc: VYHomeViewController(), title: \"Home\", image: \"home_gray\", selectedImage: \"home_blue\")let infoTab = (vc: VYInformationViewController(), title: \"Info\", image: \"home_gray\", selectedImage: \"home_blue\")let marketTab = (vc: VYMarketViewController(), title: \"Market\", image: \"home_gray\", selectedImage: \"home_blue\")let userTab = (vc: VYUserCenterViewController(), title: \"Me\", image: \"home_gray\", selectedImage: \"home_blue\")// 下面报错：Heterogeneous collection literal could only be inferred to '[Any]'; add explicit type annotation if this is intentionallet data = [homeTab, infoTab, marketTab, userTab] 但是会报错，Xcode 的修改提示是后面添加 as [Any]1let data = [selfSelectedTab, infoTab, marketTab, userTab] as [Any] 但是这样做已经不是原来的做一个元组数组的初衷了。无法在遍历数组的时候使用命名元组来获取信息","text":"想建立一个元组的数组，来简单存放构建 TabViewController 的信息首先我的做法是1234567let homeTab = (vc: VYHomeViewController(), title: \"Home\", image: \"home_gray\", selectedImage: \"home_blue\")let infoTab = (vc: VYInformationViewController(), title: \"Info\", image: \"home_gray\", selectedImage: \"home_blue\")let marketTab = (vc: VYMarketViewController(), title: \"Market\", image: \"home_gray\", selectedImage: \"home_blue\")let userTab = (vc: VYUserCenterViewController(), title: \"Me\", image: \"home_gray\", selectedImage: \"home_blue\")// 下面报错：Heterogeneous collection literal could only be inferred to '[Any]'; add explicit type annotation if this is intentionallet data = [homeTab, infoTab, marketTab, userTab] 但是会报错，Xcode 的修改提示是后面添加 as [Any]1let data = [selfSelectedTab, infoTab, marketTab, userTab] as [Any] 但是这样做已经不是原来的做一个元组数组的初衷了。无法在遍历数组的时候使用命名元组来获取信息 接着我用 typealias 的方法改成如下：12345678typealias TabInfo = (vc: UIViewController, title: String, image: String, selectedImage: String)var tabInfo: [TabInfo] = [TabInfo]()let homeTab = (vc: VYHomeViewController(), title: \"Home\", image: \"home_gray\", selectedImage: \"home_blue\")let infoTab = (vc: VYHomeViewController(), title: \"Info\", image: \"home_gray\", selectedImage: \"home_blue\")// 下面报错：Cannot express tuple conversion '(vc: VYInformationViewController, title: String, image: String, selectedImage: String)' to '(vc: UIViewController, title: String, image: String, selectedImage: String)'tabInfo.append(homeTab) 给数组添加元素的时候报错，因为元组不支持类型转换，VYHomeViewController 虽然继承 UIViewController，但是元组看来它们不是同一类型。 最后还是放弃了用元组数组的方法：123456789let homeTab = (vc: VYHomePageViewController(), title: Home, image: \"new_home_gray\", selectedImage: \"new_home_blue\")let infoTab = (vc: VYInformationViewController(), title: Info, image: \"msg_gray\", selectedImage: \"msg_blue\")let marketTab = (vc: VYMarketViewController(), title: Market, image: \"hangqing_gray\", selectedImage: \"hangqing_blue\")let userTab = (vc: VYUserCenterViewController(), title: Me, image: \"mine_gray\", selectedImage: \"mine_blue\")addViewController(homeTab.vc, title: homeTab.title, image: homeTab.image, selectedIamge: homeTab.selectedImage)addViewController(infoTab.vc, title: infoTab.title, image: infoTab.image, selectedIamge: infoTab.selectedImage)addViewController(marketTab.vc, title: marketTab.title, image: marketTab.image, selectedIamge: marketTab.selectedImage)addViewController(userTab.vc, title: userTab.title, image: userTab.image, selectedIamge: userTab.selectedImage)","categories":[],"tags":[]},{"title":"自定义 UISegmentedControl 样式","slug":"自定义 UISegmentedControl 样式","date":"2017-05-09T14:18:30.000Z","updated":"2017-11-28T08:18:52.583Z","comments":true,"path":"2017/05/09/自定义 UISegmentedControl 样式/","link":"","permalink":"http://myhanson.com/2017/05/09/自定义 UISegmentedControl 样式/","excerpt":"系统的 UISegmentedControl 是个挺方便的控件，这里来讲讲在 Swift3 下自定义 UISegmentedControl 的样式，包括修改底色，边框颜色等等。 要了解 UISegmentedControl 各个部分的组成，可以在官方的文档中找到 UISegmentedControl 文档 。着重注意这个图： 上面这幅图明确的列出了 UISegmentedControl 各个部分所控制的方法。下面就开始自定义吧。","text":"系统的 UISegmentedControl 是个挺方便的控件，这里来讲讲在 Swift3 下自定义 UISegmentedControl 的样式，包括修改底色，边框颜色等等。 要了解 UISegmentedControl 各个部分的组成，可以在官方的文档中找到 UISegmentedControl 文档 。着重注意这个图： 上面这幅图明确的列出了 UISegmentedControl 各个部分所控制的方法。下面就开始自定义吧。 首先我们先做一个通过颜色生成图片的的一个扩展方法：1234567891011121314extension UIImage&#123; public class func renderImageWithColor(_ color: UIColor, size: CGSize) -&gt; UIImage &#123; UIGraphicsBeginImageContext(size) guard let context = UIGraphicsGetCurrentContext() else &#123; UIGraphicsEndImageContext() return UIImage() &#125; context.setFillColor(color.cgColor); context.fill(CGRect(x: 0, y: 0, width: size.width, height: size.height)); let img = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() return img ?? UIImage() &#125;&#125; 接着，我们可以为 UISegmentedControl 建立一个可以自定义颜色的扩展方法：1234567891011121314151617181920212223242526272829303132extension UISegmentedControl &#123; /// 自定义样式 /// /// - Parameters: /// - normalColor: 普通状态下背景色 /// - selectedColor: 选中状态下背景色 /// - dividerColor: 选项之间的分割线颜色 func setSegmentStyle(normalColor: UIColor, selectedColor: UIColor, dividerColor: UIColor) &#123; let normalColorImage = UIImage.renderImageWithColor(normalColor, size: CGSize(width: 1.0, height: 1.0)) let selectedColorImage = UIImage.renderImageWithColor(selectedColor, size: CGSize(width: 1.0, height: 1.0)) let dividerColorImage = UIImage.renderImageWithColor(dividerColor, size: CGSize(width: 1.0, height: 1.0)) setBackgroundImage(normalColorImage, for: .normal, barMetrics: .default) setBackgroundImage(selectedColorImage, for: .selected, barMetrics: .default) setDividerImage(dividerColorImage, forLeftSegmentState: .normal, rightSegmentState: .normal, barMetrics: .default) let segAttributesNormal: NSDictionary = [NSForegroundColorAttributeName: UIColor.gray, NSFontAttributeName: UIFont.systemFont(ofSize: 14)] let segAttributesSeleted: NSDictionary = [NSForegroundColorAttributeName: UIColor.white,NSFontAttributeName: UIFont.systemFont(ofSize: 14)] // 文字在两种状态下的颜色 setTitleTextAttributes(segAttributesNormal as [NSObject : AnyObject], for: UIControlState.normal) setTitleTextAttributes(segAttributesSeleted as [NSObject : AnyObject], for: UIControlState.selected) // 边界颜色、圆角 self.layer.borderWidth = 0.7 self.layer.cornerRadius = 5.0 self.layer.borderColor = dividerColor.cgColor self.layer.masksToBounds = true &#125;&#125; 这个扩展方法我只暴露了三种颜色的修改，大家可以根据自己需求修改。最后就是使用了，注意这里如果进行了自定义，不能用 autoLayout 了, 需指定 Segement 的位置大小，不然显示出来的效果被压缩成了一条线，我估计是 setBackgroundImage 的方法需要把 1x1 的颜色图片进行填充，如果不指定大小会出差错。12345let segment = UISegmentedControl(items: [\"测试\", \"测试\", \"测试\"])segment.frame = CGRect(x: 0, y: 0, width: 150, height: 40)segment.setSegmentStyle(normalColor: UIColor.clear, selectedColor: UIColor.cyan, dividerColor: UIColor.gray)segment.selectedSegmentIndex = 0view.addSubview(segment) 个人比较喜欢用 extension 扩展方法，这里大家直接拷贝就能够使用了，祝大家自定义愉快吧~","categories":[],"tags":[]},{"title":"HSStockChart介绍","slug":"HSStockChart介绍","date":"2017-05-03T08:53:30.000Z","updated":"2017-11-28T08:19:15.162Z","comments":true,"path":"2017/05/03/HSStockChart介绍/","link":"","permalink":"http://myhanson.com/2017/05/03/HSStockChart介绍/","excerpt":"HSStockChart 是一个绘制股票分时图、K 线图的库。支持流畅的回弹拖动，长按十字线，捏合放大缩小等功能，主要使用了 CAShapeLayer 来绘图，相比使用 Core Graphics 和重写 drawRect 的方法更高效，占用内存更小。GitHub 地址：HSStockChart","text":"HSStockChart 是一个绘制股票分时图、K 线图的库。支持流畅的回弹拖动，长按十字线，捏合放大缩小等功能，主要使用了 CAShapeLayer 来绘图，相比使用 Core Graphics 和重写 drawRect 的方法更高效，占用内存更小。GitHub 地址：HSStockChart 功能 支持绘制分时图，五日分时图，K 线图，MA 线指标，交易量柱等。 支持横屏查看。 K 线图利用 UIScrollView 达到流畅的滑动查看效果。 使用 CAShapeLayer 绘图，内存占用更小，效率更高。 版本需求 iOS 8.0+ Swift 3 说明 之前绘图的方法是重写 drawRect 方法，在方法里获取 CGContext 然后利用Core Graphics 来进行绘图，调用 setNeedsDisplay 来刷新。但是这种方法有个问题是： 一旦你实现了 CALayerDelegate 协议中的 -drawLayer:inContext: 方法或者 UIView 中的 -drawRect: 方法（其实就是前者的包装方法），图层就创建了一个绘制上下文，这个上下文需要的内存可从这个公式得出：图层宽x图层高x4字节，宽高的单位均为像素。对于一个在 Retina iPad 上的全屏图层来说，这个内存量就是 2048x1526x4字节，相当于12MB内存，图层每次重绘的时候都需要重新抹掉内存然后重新分配。【摘自 iOS Core Animation- Advanced Techniques 中文译本 高效绘图一章】 因为我要达到流畅滑动查看的效果，所以在 UIScrollView 上添加了一个 UIView 这个 View 的宽度会依据当前展示数据的多少而变化，结合 UIScrollView 的 ContentSize 就能达到很好的滑动效果。 如果我用之前重写 drawRect 的方法，那么这个 View 会根据数据量的变大而变大，从而导致绘图内存急剧上升，数据量大的时候会崩溃。基于此，我采用了 CAShapeLayer 的方式绘图，此方式的特点如下： CAShapeLayer 是一个通过矢量图形而不是 bitmap 来绘制的图层子类。你指定诸如颜色和线宽等属性，用 CGPath 来定义想要绘制的图形，最后就自动渲染出来了。当然，你也可以用 Core Graphics 直接向原始的内容中绘制一个路径，相比之下，使用 CAShapeLayer 有以下一些优点: 渲染快速。CAShapeLayer 使用了硬件加速，绘制同一图形会比用 Core Graphics 快很多。 高效使用内存。一个 CAShapeLayer 不需要像普通 CALayer 一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。 不会被图层边界剪裁掉，一个 CAShapeLayer 可以在边界之外绘制。你的图层路径不会像在使用 Core Graphics 的普通 CALayer 一样被剪裁掉。 不会出现像素化。当你给 CAShapeLayer 做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化 最终在真机上测试(注意是在真机上测试)两种方式的结果如图，内存大大降低并且稳定在13M左右 自定义 CAShapeLayer，重写 action(forKey event: String) 方法。目的是 关闭 CAShapeLayer 的隐式动画，避免滑动时候或者十字线出现时有残影的现象(实际上是因为 Layer 的 position 属性变化而产生的隐式动画) 12345class HSCAShapeLayer: CAShapeLayer &#123; override func action(forKey event: String) -&gt; CAAction? &#123; return nil &#125;&#125; LicenseReleased under MIT License.","categories":[],"tags":[]}]}