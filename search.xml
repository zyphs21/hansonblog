<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CoreLocation 中的 Course 和 Heading 简析</title>
      <link href="/2020/04/15/CoreLocation%E4%B8%AD%E7%9A%84Course%E5%92%8CHeading%E7%AE%80%E6%9E%90/"/>
      <url>/2020/04/15/CoreLocation%E4%B8%AD%E7%9A%84Course%E5%92%8CHeading%E7%AE%80%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>很多地图 App 都会有一个当前定位的标记，该标记可以根据用户手持手机的朝向不同而改变方向。如图：</p><img src="https://imgkr.cn-bj.ufileos.com/6a305cfc-4d8e-4f17-ad25-d40534e29aec.png" width = "80" height = "80" alt="带方向的定位标记" align=center /><p>如果要实现这个带方向定位的标记点，需要什么数据呢？</p><a id="more"></a><ul><li>定位数据</li><li>手机朝向数据</li></ul><p>定位数据获取很简单，调用 <code>CLLocationManager</code> 的 <code>startUpdatingLocation()</code> 方法，然后在 <code>didUpdateLocations</code> 的回调方法中可以得到的 <code>CLLocation</code> 属性值。</p><p><code>CLLocation</code> 对象中，除了有我们需要的 coordinate 位置数据外，还有一个 <code>course</code> 属性。</p><p>这个 <code>course</code> 属性是不是我们需要的手机朝向数据呢？</p><blockquote><p>course:<br>The direction in which the device is traveling, measured in degrees and relative to due north.</p></blockquote><blockquote><p>Course values are measured in degrees starting at due north and continue clockwise around the compass. Thus, north is 0 degrees, east is 90 degrees, south is 180 degrees, and so on. Course values may not be available on all devices. A negative value indicates that the course information is invalid.</p></blockquote><p>从文档的解释来看，它是一个相对于地理北极以顺时针方向的角度数据，手机朝着正北方是 0 度，朝着东边是 90度，依次类推。</p><p>看起来是我们想要的值。但是从实际测试(真机室内测试)结果看，<strong>这个值一直是返回 -1 。（负数代表此值当前不可用）</strong></p><p>排除使用方式的不对，我们从文档 <a href="https://developer.apple.com/documentation/corelocation/getting_heading_and_course_information" target="_blank" rel="noopener">Getting Heading and Course Information</a> 发现，我们要获取的其实是 <code>heading</code>  的数据。</p><p>通过调用 CLLocationManager 中的 </p><pre><code>startUpdatingHeading()</code></pre><p>然后在 <code>locationManager(_:didUpdateHeading:)</code> 的回调方法中就可以获取到 heading 的数据了。</p><h2 id="Course-和-Heading"><a href="#Course-和-Heading" class="headerlink" title="Course 和 Heading"></a>Course 和 Heading</h2><p>从字面意思上我们可以将它们区分为 <code>航向</code> 和 <code>朝向</code></p><p><code>Course(航向)信息</code> 反映的是设备移动的速度和方向，并且仅在具有GPS硬件条件的设备上可用。</p><p>注意不要将 <code>Course(航向)</code> 与 <code>Heading(朝向)</code> 混淆。Course(航向) 反映的是设备移动时的方向，是<strong>从GPS信息中获取到，它与设备的物理方向无关</strong>。</p><p>而 <code>Heading(朝向)信息</code> 则是通过计算手机上传感器的值而获取到的相对于地理北极的角度信息。</p><h3 id="Course"><a href="#Course" class="headerlink" title="Course"></a>Course</h3><p>Course 常常是用在进行导航的情况下。比如平时我们开车进行导航的时候，有时候车子转弯过快，会发现导航上的朝向并没有及时更新到正确的方向，要过一会才会更新，这就是因为 GPS 信息没有及时更新过来，故 Course 信息也就无法有足够的数据支持它更新。</p><h3 id="Heading"><a href="#Heading" class="headerlink" title="Heading"></a>Heading</h3><p>Heading 是与物理设备有关的值，所以我们在获取 Heading 信息的时候，注意要配置 CLLocationManager 的 <code>headingOrientation</code> 属性。</p><p>headingOrientation 默认值是 <code>portrait</code> ，即我们平时正面拿着手机。而当我们正面横着拿手机的时候，需要将 <code>headingOrientation</code> 属性根据实际情况改成 <code>landscapeLeft</code> 或者 <code>landscapeRight</code>，这样系统才能通过手机的持有方位计算正确的 <code>Heading</code> 值，不然 Heading 就一直是默认以 portrait 的形式计算得到。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何判断一个多边形是否合法</title>
      <link href="/2019/02/17/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95/"/>
      <url>/2019/02/17/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>利用无人机对一片区域进行测绘前，我们会先在地图上框选一个区域，然后再规划飞行的路线，而需要测绘的这片区域往往是一个多边形。这就涉及判断多边形是否合法的问题。</p><a id="more"></a><p>首先我们要确定一个标准：<strong>怎么样才算一个不合法的多边形</strong> ？我们可以简单地通过下面这幅图来解释一下：<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/judgePolygonValid/polygonDesc.png" alt=""></p><p>我们可以看出前面两个分别是凹多边形和凸多边形，而最后一张则是我们所说的不合法多边形，可以看出这个不合法的多边形的特征就是：<strong>它存在某条边与另外一条边相交的情况</strong> 。</p><p>那么要判断一个多边形是否合法，我们只要判断组成多边形的所有线段是否存在相交的情况即可，当然，我们这里所说的相交是 <strong>规范相交</strong> ，即 <strong>交点不在线段的端点上</strong> 。</p><p>好了，那么现在的问题可以简化成：<strong>如何判断两条线段是否规范相交</strong> 。</p><p>这里我们需要借助 <strong>向量的叉积</strong> 来进行判断。</p><blockquote><p>叉积，又称向量积，是对三维空间中的两个向量的二元运算。</p></blockquote><p>这里推荐 3Blue1Brown 的 <a href="https://www.bilibili.com/video/av6731067/?p=11" target="_blank" rel="noopener">视频</a> 来快速回顾一下叉积的概念(下面的两幅截图来自此视频)。我们只需知道叉积的结果是有正负的，比如我们以向量 $\vec{v}$ 为标准，如下图，向量  $\vec{w}$  在  $\vec{v}$ 的 <strong>顺时针方向</strong>，那么   $\vec{v} \times \vec{w} &lt; 0$ ：</p><p><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/judgePolygonValid/vetorvw.png" alt=""><br>$$\vec{v} \times \vec{w} &lt; 0$$</p><p>如果向量 $\vec{w}$  在  $\vec{v}$ 的 <strong>逆时针方向</strong>，那么 $\vec{v} \times \vec{w} &gt; 0$ ：</p><p><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/judgePolygonValid/vetorwv.png" alt=""><br>$$\vec{v} \times \vec{w} &gt; 0$$</p><p>那么我们如何利用叉积的特性运用到判断线段是否相交上呢？</p><p>我们先看下面最直接的一个线段相交的情况：<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/judgePolygonValid/line1.png" alt=""></p><p>线段 $P_1P_2$ 和 线段 $Q_1Q_2$ 明显存在一个交点，从上面这张图我们可以做一个简单的结论：<strong>如果一条的线段的两个端点在另外一条线段两侧，那么这两条线段可能相交</strong>，注意这里说的是可能相交，稍后会讲到另外一种情况。</p><p>我们可以将上面的图转换为向量的情况来看：<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/judgePolygonValid/line2.png" alt=""></p><p>是不是觉得似曾相识，这跟上面提到的叉积的情况是不是很类似？<br>向量  $\vec{P_1Q_1}$  在  $\vec{P_1P_2}$ 的逆时针方向，那么：$\vec{P_1P_2} \times \vec{P_1Q_1} &gt; 0$<br>向量  $\vec{P_1Q_2}$  在  $\vec{P_1P_2}$ 的顺时针方向，那么：$\vec{P_1P_2} \times \vec{P_1Q_2} &lt; 0$</p><p>用 A 表示 $\vec{P_1P_2} \times \vec{P_1Q_1} $ 的叉积结果，用 B 表示 $\vec{P_1P_2} \times \vec{P_1Q_2}$ 的叉积结果，那么 <strong>一条的线段的两个端点在另外一条线段两侧</strong> 这个几何现象可以用这个公式表示 ：A*B &lt; 0</p><p>我们前面提到 <strong>如果一条的线段的两个端点在另外一条线段两侧，那么这两条线段可能相交</strong> ，为什么是可能相交呢？如果我们将 线段 $Q_1Q_2$ 往右边移动一下，会存在下面这种情况：<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/judgePolygonValid/line3.png" alt=""><br>从上图可以看出，线段 $Q_1Q_2$ 的两个端点在线段 $P_1P_2$  两侧，但是它们并没有相交。</p><p>那么如何排除这种情况呢？其实很简单，我们之前都是以线段 $P_1P_2$ 作为主视角，如果将主视角换成线段 $Q_1Q_2$，那么我们很容易看出 线段 $P_1P_2$ 的两个端点并没有在 线段 $Q_1Q_2$ 的两侧。所以我们再次看回上面相交的那幅图，为了能够充分的判断两条线段相交，这次以 $Q_1Q_2$ 为主视角看待这个问题，求叉积：<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/judgePolygonValid/line4.png" alt=""><br>向量  $\vec{Q_1P_2}$  在  $\vec{Q_1Q_2}$ 的逆时针方向，那么：$\vec{Q_1Q_2} \times \vec{Q_1P_2} &gt; 0$<br>向量  $\vec{Q_1P_1}$  在  $\vec{Q_1Q_2}$ 的顺时针方向，那么：$\vec{Q_1Q_2} \times \vec{Q_1P_1} &lt; 0$</p><p>综上，我们可以得出：<br>A =  $\vec{P_1P_2} \times \vec{P_1Q_1} $<br>B = $\vec{P_1P_2} \times \vec{P_1Q_2} $<br>C = $\vec{Q_1Q_2} \times \vec{Q_1P_1} $<br>D = $\vec{Q_1Q_2} \times \vec{Q_1P_2} $<br>当 A * B &lt; 0 &amp;&amp; C * D &lt; 0 的时候，两条线段规范相交。<br>至于向量的叉积如何运算，这里就不细写了，给出一张计算草稿给大家过目一下：<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/judgePolygonValid/calcraft.png" alt=""><br>根据计算草稿的内容，我们就很容易通过代码来实现了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private func isIntersect(line1: (CGPoint, CGPoint), line2: (CGPoint, CGPoint)) -&gt; Bool &#123;</span><br><span class="line">        let p1 &#x3D; line1.0</span><br><span class="line">        let p2 &#x3D; line1.1</span><br><span class="line">        let q1 &#x3D; line2.0</span><br><span class="line">        let q2 &#x3D; line2.1</span><br><span class="line"></span><br><span class="line">        let a1 &#x3D; (p2.x - p1.x) * (q1.y - p1.y) - (q1.x - p1.x) * (p2.y - p1.y)</span><br><span class="line">        let a2 &#x3D; (p2.x - p1.x) * (q2.y - p1.y) - (q2.x - p1.x) * (p2.y - p1.y)</span><br><span class="line">        </span><br><span class="line">        let b1 &#x3D; (q2.x - q1.x) * (p1.y - q1.y) - (p1.x - q1.x) * (q2.y - q1.y)</span><br><span class="line">        let b2 &#x3D; (q2.x - q1.x) * (p2.y - q1.y) - (p2.x - q1.x) * (q2.y - q1.y)</span><br><span class="line">        </span><br><span class="line">        if a1 * a2 &lt; 0 &amp;&amp; b1 * b2 &lt; 0 &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于笔者能力有限，文中如有错误还请各位读者不吝赐教。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift的泛型小总结</title>
      <link href="/2018/08/05/Swift%E7%9A%84%E6%B3%9B%E5%9E%8B%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/05/Swift%E7%9A%84%E6%B3%9B%E5%9E%8B%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><strong>本文针对网上一些关于泛型的知识点进行汇总和总结，已在文中标记出参考文章的链接</strong></p><blockquote><p>泛型是程序设计语言的一种特性。允许程序员在强类型程序设计语言中编写代码时定义一些可变部分，那些部分在使用前必须作出指明。</p></blockquote><a id="more"></a><p><code>Objective-C</code> 缺乏一个重要特性:不支持泛型。幸运地是，<code>Swift</code>拥有这一特性。==泛型允许你声明的函数、类以及结构体支持不同的数据类型==。</p><p>泛型代码可以让你写出根据自我需求定义、适用于任何类型的，灵活且可重用的函数和类型。它的可以让你避免重复的代码，用一种清晰和抽象的方式来表达代码的意图。</p><p>泛型是 Swift 强大特征中的其中一个，许多 Swift 标准库是通过泛型代码构建出来的。事实上，泛型的使用贯穿了整本语言手册，只是你没有发现而已。 <span style="border-bottom:2px solid brown;">例如，Swift 的数组和字典类型都是泛型集。你可以创建一个Int数组，也可创建一个String数组，或者甚至于可以是任何其他 Swift 的类型数据数组。同样的，你也可以创建存储任何指定类型的字典（dictionary），而且这些类型可以是没有限制的。</span></p><blockquote><p><a href="https://swift.gg/2015/09/16/swift-generics/" target="_blank" rel="noopener">参考</a></p></blockquote><h2 id="实现栈的例子，说明泛型的作用"><a href="#实现栈的例子，说明泛型的作用" class="headerlink" title="实现栈的例子，说明泛型的作用"></a>实现栈的例子，说明泛型的作用</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntStack</span></span>&#123;</span><br><span class="line">  <span class="comment">// 采用数组作为容器保存数据 类型为Int</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> stackItems:[<span class="type">Int</span>] = []</span><br><span class="line">  <span class="comment">// 入栈操作 即Push 添加最新数据到容器最顶部</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">pushItem</span><span class="params">(item:Int)</span></span>&#123;</span><br><span class="line">    stackItems.append(item)    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 出栈操作 即Pop 将容器最顶部数据移除</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">popItem</span><span class="params">()</span></span>-&gt;<span class="type">Int?</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastItem = stackItems.last</span><br><span class="line">    stackItems.removeLast()</span><br><span class="line">    <span class="keyword">return</span> lastItem</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这栈能够处理<code>Int</code>类型数据。但是如果要一个能够处理<code>String</code>类型的栈呢？我们需要替换所有<code>Int</code>为<code>String</code>，不过这显然是一个糟糕的解决方法。此外另外一种方法是用<code>AnyObject</code>，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class AnyObjectStack&#123;</span><br><span class="line">  &#x2F;&#x2F; 采用数组作为容器保存数据 类型为AnyObject</span><br><span class="line">  private var stackItems:[AnyObject] &#x3D; []</span><br><span class="line">  </span><br><span class="line">  func pushItem(item:AnyObject)&#123;</span><br><span class="line">    stackItems.append(item)    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  func popItem()-&gt;AnyObject?&#123;</span><br><span class="line">    let lastItem &#x3D; stackItems.last</span><br><span class="line">    stackItems.removeLast()</span><br><span class="line">    return lastItem</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这种情况下我们就失去了数据类型的安全，并且每当我们对栈进行操作时,都需要进行一系列繁琐的类型转换(casting操作,使用as来进行类型转换)</p><ul><li>通过泛型来解决：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Stack&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">  private var stackItems: [T] &#x3D; []  </span><br><span class="line"></span><br><span class="line">  func pushItem(item:T) &#123;</span><br><span class="line">    stackItems.append(item)</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  func popItem() -&gt; T? &#123;</span><br><span class="line">    let lastItem &#x3D; stackItems.last</span><br><span class="line">    stackItems.removeLast()</span><br><span class="line">    return lastItem</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型定义方式:由一对尖括号(&lt;&gt;)包裹，命名方式通常为大写字母开头(这里我们命名为T)。在初始化阶段，我们通过明确的类型(这里为Int)来定义参数,之后编译器将所有的泛型T替换成Int类型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 指定了泛型T 就是 Int </span><br><span class="line">&#x2F;&#x2F; 编译器会替换所有T为Int</span><br><span class="line">let aStack &#x3D; Stack&lt;Int&gt;()</span><br><span class="line"></span><br><span class="line">aStack.pushItem(10)</span><br><span class="line">if let lastItem &#x3D; aStack.popItem() &#123;</span><br><span class="line">  print(&quot;last item: \(lastItem)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型扩展"><a href="#泛型扩展" class="headerlink" title="泛型扩展"></a>泛型扩展</h2><blockquote><p><a href="http://swifter.tips/extension-generic/" target="_blank" rel="noopener">参考</a></p></blockquote><p>Swift 对于泛型的支持使得我们可以避免为类似的功能多次书写重复的代码，这是一种很好的简化。而对于泛型类型，我们也可以使用 extension 为泛型类型添加新的方法。</p><p>与为普通的类型添加扩展不同的是，<span style="border-bottom: 2px solid brown">泛型类型在类型定义时就引入了类型标志，我们可以直接使用</span>。例如 Swift 的 Array 类型的定义是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public struct Array&lt;Element&gt; : CollectionType, Indexable, ... &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个定义中，已经声明了 <code>Element</code> 为泛型类型。在为类似这样的泛型类型写扩展的时候，我们不需要在 extension 关键字后的声明中重复地去写 <code>&lt;Element&gt;</code> 这样的泛型类型名字 (其实编译器也不允许我们这么做)，在扩展中可以使用和原来所定义一样的符号即可指代类型本体声明的泛型。比如我们想在扩展中实现一个 random 方法来随机地取出 Array 中的一个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extension Array &#123;</span><br><span class="line">    var random: Element? &#123;</span><br><span class="line">        return self.count !&#x3D; 0 ?</span><br><span class="line">          self[Int.random(in: 0..&lt;self.count)] : nil</span><br><span class="line">        &#x2F;&#x2F; self[Int(arc4random_uniform(UInt32(self.count)))]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let languages &#x3D; [&quot;Swift&quot;,&quot;ObjC&quot;,&quot;C++&quot;,&quot;Java&quot;]</span><br><span class="line">languages.random!</span><br><span class="line">&#x2F;&#x2F; 随机输出是这四个字符串中的某个</span><br><span class="line"></span><br><span class="line">let ranks &#x3D; [1,2,3,4]</span><br><span class="line">ranks.random!</span><br><span class="line">&#x2F;&#x2F; 随机输出是这四个数字中的某个</span><br></pre></td></tr></table></figure><p><span style="border-bottom: 2px solid brown">在扩展中是不能添加整个类型可用的新泛型符号的，但是对于某个特定的方法来说，我们可以添加 T 以外的其他泛型符号</span>。比如在刚才的扩展中加上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func appendRandomDescription</span><br><span class="line">    &lt;U: CustomStringConvertible&gt;(input: U) -&gt; String &#123;</span><br><span class="line"></span><br><span class="line">        if let element &#x3D; self.random &#123;</span><br><span class="line">            return &quot;\(element) &quot; + input.description</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &quot;empty array&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们限定了只接受实现了 <code>CustomStringConvertible</code> 的参数作为参数，然后将这个内容附加到自身的某个随机元素的描述上。因为参数 input 实现了 <code>CustomStringConvertible</code>，所以在方法中我们可以使用 description 来获取描述字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let languages &#x3D; [&quot;Swift&quot;,&quot;ObjC&quot;,&quot;C++&quot;,&quot;Java&quot;]</span><br><span class="line">languages.random!</span><br><span class="line"></span><br><span class="line">let ranks &#x3D; [1,2,3,4]</span><br><span class="line">ranks.random!</span><br><span class="line"></span><br><span class="line">languages.appendRandomDescription(ranks.random!)</span><br><span class="line">&#x2F;&#x2F; 随机组合 languages 和 ranks 中的各一个元素，然后输出</span><br></pre></td></tr></table></figure><p>虽然这是个生造的需求，但是能说明泛型在扩展里的使用方式。简单说就是我们++不能通过扩展来重新定义当前已有的泛型符号，但是可以对其进行使用；在扩展中也不能为这个类型添加泛型符号；但只要名字不冲突，我们是可以在新声明的方法中定义和使用新的泛型符号的++。</p><h2 id="typealias-和-泛型"><a href="#typealias-和-泛型" class="headerlink" title="typealias 和 泛型"></a>typealias 和 泛型</h2><h3 id="typealias-作用"><a href="#typealias-作用" class="headerlink" title="typealias 作用"></a>typealias 作用</h3><blockquote><p><a href="http://swifter.tips/typealias/" target="_blank" rel="noopener">参考</a></p></blockquote><p>typealias 是用来为已经存在的类型重新定义名字的，通过命名，可以使代码变得更加清晰。使用的语法也很简单，使用 typealias 关键字像使用普通的赋值语句一样，可以将某个已经存在的类型赋值为新的名字。比如在计算二维平面上的距离和位置的时候，我们一般使用 Double 来表示距离，用 CGPoint 来表示位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func distanceBetweenPoint(point: CGPoint, toPoint: CGPoint) -&gt; Double &#123;</span><br><span class="line">    let dx &#x3D; Double(toPoint.x - point.x)</span><br><span class="line">    let dy &#x3D; Double(toPoint.y - point.y)</span><br><span class="line">    return sqrt(dx * dx + dy * dy)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let origin: CGPoint &#x3D; CGPoint(x: 0, y: 0)</span><br><span class="line">let point: CGPoint &#x3D; CGPoint(x: 1, y: 1)</span><br><span class="line"></span><br><span class="line">let distance: Double &#x3D;  distanceBetweenPoint(origin, point)</span><br></pre></td></tr></table></figure><p>虽然在数学上和最后的程序运行上都没什么问题，但是阅读和维护的时候总是觉得有哪里不对。因为我们没有将数学抽象和实际问题结合起来，使得在阅读代码时我们还需要在大脑中进行一次额外的转换：CGPoint 代表一个点，而这个点就是我们在定义的坐标系里的位置；Double 是一个数字，它代表两个点之间的距离。</p><p>如果我们使用 typealias，就可以将这种转换直接写在代码里，从而减轻阅读和维护的负担：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">typealias Location &#x3D; CGPoint</span><br><span class="line">typealias Distance &#x3D; Double</span><br><span class="line"></span><br><span class="line">func distanceBetweenPoint(location: Location,</span><br><span class="line">    toLocation: Location) -&gt; Distance &#123;</span><br><span class="line">        let dx &#x3D; Distance(location.x - toLocation.x)</span><br><span class="line">        let dy &#x3D; Distance(location.y - toLocation.y)</span><br><span class="line">        return sqrt(dx * dx + dy * dy)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let origin: Location &#x3D; Location(x: 0, y: 0)</span><br><span class="line">let point: Location &#x3D; Location(x: 1, y: 1)</span><br><span class="line"></span><br><span class="line">let distance: Distance &#x3D;  distanceBetweenPoint(origin, toLocation: point)</span><br></pre></td></tr></table></figure><p>同样的代码，在 typealias 的帮助下，读起来就轻松多了。</p><h3 id="用-typealias-给泛型重命名"><a href="#用-typealias-给泛型重命名" class="headerlink" title="用 typealias 给泛型重命名"></a>用 typealias 给泛型重命名</h3><p>泛型类型的确定性得到保证后，才可以重命名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Person&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">typealias WorkId &#x3D; String</span><br><span class="line">typealias Worker &#x3D; Person&lt;WorkId&gt;</span><br></pre></td></tr></table></figure><h2 id="在协议中使用-associatedtype"><a href="#在协议中使用-associatedtype" class="headerlink" title="在协议中使用 associatedtype"></a>在协议中使用 associatedtype</h2><blockquote><p><a href="https://numbbbbb.gitbooks.io/-the-swift-programming-language-/content/chapter2/22_Generics.html" target="_blank" rel="noopener">参考</a></p></blockquote><p>定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分将会非常有用。关联类型为协议中的某个类型提供了一个占位名（或者说别名），其代表的实际类型在协议被采纳时才会被指定。你可以通过 associatedtype 关键字来指定关联类型。</p><p>新建一个Container协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protocol Container &#123;</span><br><span class="line">    associatedtype Item</span><br><span class="line">    mutating func append(_ item: Item)</span><br><span class="line">    var count: Int &#123; get &#125;</span><br><span class="line">    subscript(i: Int) -&gt; Item &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以给协议里的关联类型添加类型注释，让遵守协议的类型必须遵循这个约束条件。例如，下面的代码定义了一个 Item 必须遵循 Equatable 的 Container 类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protocol Container &#123;</span><br><span class="line">    associatedtype Item: Equatable</span><br><span class="line">    mutating func append(_ item: Item)</span><br><span class="line">    var count: Int &#123; get &#125;</span><br><span class="line">    subscript(i: Int) -&gt; Item &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成遵循Container协议的泛型Stack:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct Stack&lt;T&gt;: Container &#123;</span><br><span class="line">    &#x2F;&#x2F; original Stack&lt;T&gt; implementation</span><br><span class="line">    var items &#x3D; [T]()</span><br><span class="line">    mutating func push(_ item: T) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    mutating func pop() -&gt; T &#123;</span><br><span class="line">        return items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 遵循Container协议的实现</span><br><span class="line">    mutating func append(_ item: T) &#123;</span><br><span class="line">        self.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    var count: Int &#123;</span><br><span class="line">        return items.count</span><br><span class="line">    &#125;</span><br><span class="line">    subscript(i: Int) -&gt; T &#123;</span><br><span class="line">        return items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h2><blockquote><p><a href="https://numbbbbb.gitbooks.io/-the-swift-programming-language-/content/chapter2/22_Generics.html" target="_blank" rel="noopener">参考</a></p></blockquote><h3 id="实现Equtable协议-使得泛型可以比较"><a href="#实现Equtable协议-使得泛型可以比较" class="headerlink" title="实现Equtable协议,使得泛型可以比较"></a>实现Equtable协议,使得泛型可以比较</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Stack&lt;T:Equatable&gt; &#123;</span><br><span class="line"></span><br><span class="line">  private var stackItems: [T] &#x3D; []</span><br><span class="line"></span><br><span class="line">  func pushItem(item:T) &#123;</span><br><span class="line">    .append(item)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  func popItem() -&gt; T? &#123;</span><br><span class="line">    let lastItem &#x3D; stackItems.last</span><br><span class="line">    stackItems.removeLast()</span><br><span class="line">    return lastItem</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  func isItemInStack(item:T) -&gt; Bool &#123;</span><br><span class="line">    var found &#x3D; false</span><br><span class="line">    for stackItem in stackItems &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果没有 &lt;T:Equatable&gt; 这里会报错</span><br><span class="line">      if stackItem &#x3D;&#x3D; item &#123;</span><br><span class="line">        ound &#x3D; true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return found</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Where-语句"><a href="#Where-语句" class="headerlink" title="Where 语句"></a>Where 语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func allItemsMatch&lt;</span><br><span class="line">    C1: Container, C2: Container</span><br><span class="line">    where C1.ItemType &#x3D;&#x3D; C2.ItemType, C1.ItemType: Equatable&gt;</span><br><span class="line">    (someContainer: C1, anotherContainer: C2) -&gt; Bool &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 检查两个Container的元素个数是否相同</span><br><span class="line">        if someContainer.count !&#x3D; anotherContainer.count &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 检查两个Container相应位置的元素彼此是否相等</span><br><span class="line">        for i in 0..&lt;someContainer.count &#123;</span><br><span class="line">            if someContainer[i] !&#x3D; anotherContainer[i] &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果所有元素检查都相同则返回true</span><br><span class="line">        return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在Swift扩展里添加&quot;存储属性&quot;</title>
      <link href="/2018/07/17/%E5%9C%A8Swift%E6%89%A9%E5%B1%95%E9%87%8C%E6%B7%BB%E5%8A%A0%22%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7%22/"/>
      <url>/2018/07/17/%E5%9C%A8Swift%E6%89%A9%E5%B1%95%E9%87%8C%E6%B7%BB%E5%8A%A0%22%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7%22/</url>
      
        <content type="html"><![CDATA[<p>能在 Swift 扩展里添加”存储属性”吗？</p><a id="more"></a><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>最近 <a href="https://itunes.apple.com/cn/app/imagegotcha/id1384107130?mt=8" target="_blank" rel="noopener">ImageGotcha</a> 收到了第一封用户反馈的邮件。<br><img src="" alt=""><br>这个用户希望可以有 <code>Dark Mode</code>。<code>ImageGotcha</code> 只是一个工具类 <code>App</code> ，好像也没有什么必要加上这个黑夜模式，不过我还是去想了想如何给应用加上黑夜模式，或者说加上一个换肤的功能。</p><p>基本的思路就是 <code>post</code> 一个自定义的 <code>NSNotification</code>，然后在需要修改颜色的地方监听这个通知然后进行修改。<br>按照惯例，我还是去 <code>Github</code> 上搜搜，看看别人是怎么做的。然后发现一部分人的做法是给现有的 <code>UIKit</code> 控件添加扩展属性，然后可以在定义这些控件的时候指定不同模式下的颜色，这的确是一种好方法。那么是如何在 <code>Swift</code> 的 <code>Extension 扩展</code> 里添加所谓的<code>&quot;存储属性&quot;</code>呢？</p><p>我们都知道，在 <code>Swift</code> 的 <code>Extension</code> 里是不能添加<code>存储属性</code>的，这里可以类比 <code>Objective-C</code>的 <code>Category 分类</code>，分类是不能添加实例变量和属性的。</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>这里就有个问题了，为什么不能添加呢？</p><blockquote><p>因为不管是 <code>Swift</code> 的 <code>Extension</code> 还是 <code>Objective-C</code> 的 <code>Category</code> 都不能改变原有的类或者结构体的内存结构，在实例化这些类的时候，内存结构是确定的，而添加属性或者实例变量需要内存空间，会改变原有的内存结构。</p></blockquote><h2 id="利用关联对象"><a href="#利用关联对象" class="headerlink" title="利用关联对象"></a>利用关联对象</h2><p>在 <code>Objective-C</code> 中我们常常用运行时 <code>Associated Object 关联对象</code> 来给 <code>Category</code> 添加属性，而在 <code>Swift</code> 里，我们同样可以利用关联对象在 <code>Extension</code> 中添加计算属性，以达到所谓的<code>存储属性</code>的效果。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AssociatedKeys</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> testNameKey: <span class="type">String</span> = <span class="string">"testNameKey"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> testName: <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">AssociatedKeys</span>.testNameKey) <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">AssociatedKeys</span>.testNameKey, newValue, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&amp;AssociatedKeys.testNameKey</code>: <code>&amp;</code> 操作符是取出地址作为 <code>UnsafeRawPointer</code> 参数传入。<br><code>.OBJC_ASSOCIATION_RETAIN_NONATOMIC</code>: 是一个 <code>objc_AssociationPolicy</code> 枚举，它有以下几种选择(从字面意思可以猜测是与Objective-C中的属性修饰符相关)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public enum objc_AssociationPolicy : UInt &#123;</span><br><span class="line">    case OBJC_ASSOCIATION_ASSIGN</span><br><span class="line">    case OBJC_ASSOCIATION_RETAIN_NONATOMIC</span><br><span class="line">    case OBJC_ASSOCIATION_COPY_NONATOMIC</span><br><span class="line">    case OBJC_ASSOCIATION_RETAIN</span><br><span class="line">    case OBJC_ASSOCIATION_COPY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var testString &#x3D; &quot;test&quot;</span><br><span class="line"></span><br><span class="line">let view &#x3D; UIView()</span><br><span class="line"></span><br><span class="line">view.testName &#x3D; testString</span><br><span class="line">print(view.testName) &#x2F;&#x2F; 输出 Optional(&quot;test&quot;)</span><br><span class="line"></span><br><span class="line">testString.append(&quot;change&quot;)</span><br><span class="line">print(view.testName) &#x2F;&#x2F; 输出 Optional(&quot;test&quot;)</span><br><span class="line"></span><br><span class="line">view.testName &#x3D; &quot;testChange&quot;</span><br><span class="line">print(view.testName) &#x2F;&#x2F; 输出 Optional(&quot;testChange&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>上架个小工具-ImageGotcha</title>
      <link href="/2018/05/18/%E4%B8%8A%E6%9E%B6%E4%B8%AA%E5%B0%8F%E5%B7%A5%E5%85%B7-ImageGotcha/"/>
      <url>/2018/05/18/%E4%B8%8A%E6%9E%B6%E4%B8%AA%E5%B0%8F%E5%B7%A5%E5%85%B7-ImageGotcha/</url>
      
        <content type="html"><![CDATA[<p>上架了个小工具。<a href="https://itunes.apple.com/cn/app/imagegotcha/id1384107130?mt=8&at=1000lMM4" target="_blank" rel="noopener">ImageGotcha</a> 是一个 <code>Safari</code> 的 <code>Action Extension</code>，它可以提取当前网页的图片方便查看和批量保存，比如可以去某些 <code>Instagram</code> 用户的主页批量下载图片，或者下载 <code>Bing</code> 的每日背景图等等。点击 <a href="https://itunes.apple.com/cn/app/imagegotcha/id1384107130?mt=8&at=1000lMM4" target="_blank" rel="noopener">这里</a> 到 <code>AppStore</code> 查看。</p><a id="more"></a><p><img src="https://camo.githubusercontent.com/f473966292ac4b1b3f3f07960e8e9383a4a3bf65/68747470733a2f2f6d6d62697a2e717069632e636e2f6d6d62697a5f6a70672f72346266653378374e3471557141566c666a4e593156685669615546614145363161334a687868543536696357544545685866376175324369633243743762746636706269627a326e53455458737858724e696344696351674f6f512f3634303f77785f666d743d6a7065672674703d7765627026777866726f6d3d352677785f6c617a793d31" alt=""></p><p><code>ImageGotcha</code> 也做了国际化，支持英文、简体中文、繁体中文、日语以及韩语。要想使用<code>ImageGotcha</code>，需先在 <code>Safari</code> 开启这个<code>Extension</code>，<code>App</code> 内有操作指导，如下图是各种语言的指导说明：</p><p><img src="https://camo.githubusercontent.com/f9878ecb46ab65ce8d6c74671ef02f18623408d4/68747470733a2f2f6d6d62697a2e717069632e636e2f6d6d62697a5f706e672f72346266653378374e3471557141566c666a4e5931566856696155466141453631346849493249524c316858316f69614764696250614e46475972326348304162737a5565386f6e43436963675144507469624d754d43677457672f3634303f77785f666d743d706e672674703d7765627026777866726f6d3d352677785f6c617a793d31" alt=""></p><p>这是演示如何启动 <code>ImageGotcha</code> 的 <code>Action Extension</code>：</p><p><embed src="https://imgcache.qq.com/tencentvideo_v1/playerv3/TPout.swf?max_age=86400&v=20161117&vid=o1339za69qd&auto=0" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"></embed></p><p>这是操作的演示：</p><p><embed src="https://imgcache.qq.com/tencentvideo_v1/playerv3/TPout.swf?max_age=86400&v=20161117&vid=w1339c8t6nc&auto=0" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"></embed></p><p>链接：<br><a href="https://itunes.apple.com/cn/app/imagegotcha/id1384107130?mt=8&at=1000lMM4" target="_blank" rel="noopener" style="display:inline-block;overflow:hidden;background:url(https://linkmaker.itunes.apple.com/assets/shared/badges/zh-cn/appstore-lrg.svg) no-repeat;width:135px;height:40px;background-size:contain;">ImageGotcha</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用SVN建立和发布私有CocoaPods库</title>
      <link href="/2018/03/28/%E4%BD%BF%E7%94%A8SVN%E5%BB%BA%E7%AB%8B%E5%92%8C%E5%8F%91%E5%B8%83%E7%A7%81%E6%9C%89CocoaPods%E5%BA%93/"/>
      <url>/2018/03/28/%E4%BD%BF%E7%94%A8SVN%E5%BB%BA%E7%AB%8B%E5%92%8C%E5%8F%91%E5%B8%83%E7%A7%81%E6%9C%89CocoaPods%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="SVN-项目结构"><a href="#SVN-项目结构" class="headerlink" title="SVN 项目结构"></a>SVN 项目结构</h1><p>首先，一般 SVN 项目有如下的结构：</p><ul><li>trunk：项目主干</li><li>branches：开发或者 Bug 分支</li><li>tags：发布的版本</li></ul><p>比如说我们已经写好了一个 CocoaPods 的库，它的名字是 xxxKit，那么它应该在看起来是这样的：<br><img src="" alt=""></p><h1 id="建立-CocoaPods-库"><a href="#建立-CocoaPods-库" class="headerlink" title="建立 CocoaPods 库"></a>建立 CocoaPods 库</h1><p>我们在 trunk 的目录下执行 </p><p><code>pod lib create xxxKit</code></p><p>按照提示输入后，在该目录下就会利用 CocoaPods 的模板生成了一个项目。我们主要关注<code>xxxKit.podspec</code> 这个文件。</p><p>修改 <code>xxxKit.podspec</code>，比如：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">  s.name         &#x3D; &quot;xxxKit&quot;</span><br><span class="line">  s.version      &#x3D; &quot;0.1.1&quot;</span><br><span class="line">  s.summary      &#x3D; &quot;xxxKit.&quot;</span><br><span class="line">  s.homepage     &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;zyphs21&#x2F;&quot;</span><br><span class="line">  s.author       &#x3D; &#123; &quot;zyphs21&quot; &#x3D;&gt; &quot;hansenhs21@live.com&quot; &#125;</span><br><span class="line">  s.source       &#x3D; &#123; :svn &#x3D;&gt; &quot;http:&#x2F;&#x2F;xxxx&#x2F;xxxKit&#x2F;&quot;, :tag &#x3D;&gt; s.version.to_s &#125;</span><br><span class="line">  s.source_files  &#x3D; &quot;xxxKit&#x2F;**&#x2F;*.&#123;swift&#125;&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>主要注意是指定 source 那里，路径填的是 SVN 仓库的地址，并加上 tag。</p><p><code>s.source = { :svn =&gt; &quot;http://xxxx/xxxKit/&quot;, :tag =&gt; s.version.to_s }</code></p><h1 id="打-tags-发布一个版本"><a href="#打-tags-发布一个版本" class="headerlink" title="打 tags 发布一个版本"></a>打 tags 发布一个版本</h1><p>这里以 <code>Cornerstone</code> 这个 Mac 端的 SVN 工具来说明。</p><ol><li><p>去到远程库里进行打 tags，注意只有在远程库操作才能打 tag。</p><p> <img src="" alt=""></p></li><li><p>选择在 trunk 主干上 <code>右键</code> -&gt; <code>Tag…</code>，然后输入 tag 标签，比如 v0.1.1</p><p> <img src="" alt=""></p></li></ol><p>之后只要有开发到了新的版本了，按照这样先打 tag。</p><h1 id="使用私有库"><a href="#使用私有库" class="headerlink" title="使用私有库"></a>使用私有库</h1><p>去到需要使用该库的项目里，在 Podfile 里指定该版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &#39;xxxKit&#39;, :svn &#x3D;&gt; &#39;http:&#x2F;&#x2F;xxxx&#x2F;xxxKit&#x2F;&#39;, :tag &#x3D;&gt; &#39;0.1.1&#39;</span><br></pre></td></tr></table></figure><p>然后执行 <code>pod install</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>通过RunScript给iOS项目自增版本号(Versioin和Build)</title>
      <link href="/2018/03/14/%E9%80%9A%E8%BF%87RunScript%E7%BB%99iOS%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%A2%9E%E7%89%88%E6%9C%AC%E5%8F%B7(Versioin%E5%92%8CBuild)/"/>
      <url>/2018/03/14/%E9%80%9A%E8%BF%87RunScript%E7%BB%99iOS%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%A2%9E%E7%89%88%E6%9C%AC%E5%8F%B7(Versioin%E5%92%8CBuild)/</url>
      
        <content type="html"><![CDATA[<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><ul><li>在打包应用之后，需要自增 <strong>Version 的最后一位</strong> 和 <strong>Build</strong> 的值。<br><img src="https://user-gold-cdn.xitu.io/2018/3/14/162201d291ebc6c1?w=690&h=136&f=png&s=11268" alt=""></li><li>只在 Archive(Release) 的时候触发该自增。</li></ul><h1 id="添加-RunScript"><a href="#添加-RunScript" class="headerlink" title="添加 RunScript"></a>添加 RunScript</h1><p>在 <code>项目Target</code> -&gt; <code>Build Phases</code> -&gt; <code>点击+号</code> -&gt; <code>New Run Script Phase</code></p><p>然后添加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$CONFIGURATION</span> == Release ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前为 Release Configuration,开始自增 Build"</span></span><br><span class="line">plist=<span class="variable">$&#123;INFOPLIST_FILE&#125;</span></span><br><span class="line">buildnum=$(/usr/libexec/PlistBuddy -c <span class="string">"Print CFBundleVersion"</span> <span class="string">"<span class="variable">$&#123;plist&#125;</span>"</span>)</span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$&#123;buildnum&#125;</span>"</span> == <span class="string">""</span> ]]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Error：在Plist文件里没有 Build 值"</span></span><br><span class="line"><span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">buildnum=$(expr <span class="variable">$buildnum</span> + 1)</span><br><span class="line">/usr/libexec/PlistBuddy -c <span class="string">"Set CFBundleVersion <span class="variable">$buildnum</span>"</span> <span class="string">"<span class="variable">$&#123;plist&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"开始自增 Version 最后一位"</span></span><br><span class="line">versionNum=$(/usr/libexec/PlistBuddy -c <span class="string">"Print CFBundleShortVersionString"</span> <span class="string">"<span class="variable">$&#123;plist&#125;</span>"</span>)</span><br><span class="line">thirdPartVersonNum=`<span class="built_in">echo</span> <span class="variable">$versionNum</span> | awk -F <span class="string">"."</span> <span class="string">'&#123;print $3&#125;'</span>`</span><br><span class="line">thirdPartVersonNum=$((<span class="variable">$thirdPartVersonNum</span> + 1))</span><br><span class="line">newVersionStr=`<span class="built_in">echo</span> <span class="variable">$versionNum</span> | awk -F <span class="string">"."</span> <span class="string">'&#123;print $1 "." $2 ".'</span><span class="variable">$thirdPartVersonNum</span><span class="string">'" &#125;'</span>`</span><br><span class="line">/usr/libexec/PlistBuddy -c <span class="string">"Set CFBundleShortVersionString <span class="variable">$newVersionStr</span>"</span> <span class="string">"<span class="variable">$&#123;plist&#125;</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$CONFIGURATION</span> <span class="string">"当前不为 Release Configuration"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>因为我的版本号是<code>xx.xx.xx</code>这样的形式，所以我以 <code>.</code> 拆分版本号后，取出第三个值来增加，最后再拼接回来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">versionNum&#x3D;$(&#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -c &quot;Print CFBundleShortVersionString&quot; &quot;$&#123;plist&#125;&quot;)</span><br><span class="line"># 这里取出第三个值</span><br><span class="line">thirdPartVersonNum&#x3D;&#96;echo $versionNum | awk -F &quot;.&quot; &#39;&#123;print $3&#125;&#39;&#96;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PathToGo诞生记</title>
      <link href="/2018/03/02/PathToGo%E8%AF%9E%E7%94%9F%E8%AE%B0/"/>
      <url>/2018/03/02/PathToGo%E8%AF%9E%E7%94%9F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>不知道大家在使用 Mac 的时候有没有这样的需求:</p><blockquote><p>经常需要获取当前文件或者文件夹的路径，并且复制到粘贴板。</p></blockquote><p>对于我来说经常有这种需要，然后我就从网上再结合自己的经验，找了好几种方法：</p><a id="more"></a><ol><li>右键-选择「显示简介」，然后在弹出的窗口里直接用鼠标拖动复制「位    置」里的路径。</li></ol><p>​    缺点：麻烦。</p><ol start="2"><li>把文件拖到浏览器，在浏览器地址栏复制路径。</li></ol><p>​    缺点：麻烦。</p><ol start="3"><li>打开终端，把文件拖入终端，终端会把文件路径打印出来，然后复制。</li></ol><p>​    缺点：麻烦。</p><ol start="4"><li>打开终端，cd到目标目录，然后输入 「pwd|pbcopy」就可以把路径复制到粘贴板。</li></ol><p>​    缺点：麻烦。</p><ol start="5"><li>选择文件，然后使用快捷键「Option + Command + C」。</li></ol><p>​    缺点：这个快捷键在更低版本的系统中好像不行，而且会与 Alfred 的一个快捷键冲突。还是麻烦。</p><ol start="6"><li>利用 Automator 来建立 Service 服务添加到右键服务菜单。</li></ol><p>​    缺点：麻烦。</p><p>以上几种方法都不能满足我的需求：</p><blockquote><ol><li>直观快捷</li><li>最好可以同时获取多个文件/文件夹的路径。</li></ol></blockquote><p>这时候我想起了很受大家欢迎的一款效率软件：Go2Shell</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/2/161e49096986d7c9?w=262&h=238&f=png&s=66436" alt=""></p><p>这款软件把它拖动到 Finder 的工具栏后，只要点击它就可以立刻启动终端，并且进入到当前的路径。</p><p>那可以不可以也做一款这样的 App 操作和 Go2Shell 类似，选中一个或多个文件或文件夹然后直接一点，就可以把当前选中的文件或文件夹路径复制到粘贴板呢？</p><p>然后经过一番折腾，『PathToGo』这款 App 就诞生了。</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/2/161e490bc920f193?w=554&h=438&f=png&s=151480" alt=""></p><p>虽然一开始是想直接利用 AppleScript 然后导出为应用程序的，可是看着 AppleScript 导出为应用程序的图标实在不够酷，就直接着手做了 PathToGo 这个简单的 Mac App。</p><p>下面看看实际体验效果吧：</p><p>首先是把『PathToGo』拖动到 Finder 的工具栏，记得是按住『command键』来进行拖动。</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/2/161e491134c3825f?w=492&h=214&f=gif&s=199517" alt=""></p><p>拖放好了之后，只需要选中你想要的一个或多个文件/文件夹，然后点击在工具栏上的『PathToGo』的图标，路径就已经复制到粘贴板上了，然后你就能愉快的 用 command+v 就能粘贴出你选择的文件的路径了。</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/2/161e491402bb99d2?w=668&h=366&f=gif&s=297785" alt=""></p><p>怎么样？是不是很方便快捷呢！<br><a href="https://github.com/HansonStudio/PathToGo" target="_blank" rel="noopener">PathToGo</a> 已经开源在 HansonStudio 的 Github 组织下了，大家可以在 Release 页面下载使用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>用SwiftGen管理UIImage等的String-based接口</title>
      <link href="/2017/12/08/%E7%94%A8SwiftGen%E7%AE%A1%E7%90%86UIImage%E7%AD%89%E7%9A%84String-based%E6%8E%A5%E5%8F%A3/"/>
      <url>/2017/12/08/%E7%94%A8SwiftGen%E7%AE%A1%E7%90%86UIImage%E7%AD%89%E7%9A%84String-based%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="问题现状"><a href="#问题现状" class="headerlink" title="问题现状"></a>问题现状</h1><p>平时我们使用UIImage，UIFont，UIColor会遇到很多String-based的接口方法，比如常用的UIImage：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> testImage = <span class="type">UIImage</span>(named: <span class="string">"test"</span>)</span><br></pre></td></tr></table></figure><p>对于上面的代码，如果我们把 <code>test</code> 拼写错了，Xcode 并不会给出提示，只有当我们运行的时候才会收到报错，这样维护起来是有一定成本的。</p><h1 id="代码解决"><a href="#代码解决" class="headerlink" title="代码解决"></a>代码解决</h1><p>我们可以用类似如下的代码来解决这个问题：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit.UIImage</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImageAssets</span> </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> image: <span class="type">UIImage</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> image = <span class="type">UIImage</span>(named: name)</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> result = image <span class="keyword">else</span> &#123; <span class="built_in">fatalError</span>(<span class="string">"Unable to load image named \(name)."</span>) &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Assets</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">AppLogo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> appLogo = <span class="type">ImageAssets</span>(name: <span class="string">"appLogo"</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> grayLogo = <span class="type">ImageAssets</span>(name: <span class="string">"gray_logo"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Arrow</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> arrowBlue = <span class="type">ImageAssets</span>(name: <span class="string">"arrow_blue"</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> arrowBrown = <span class="type">ImageAssets</span>(name: <span class="string">"arrow_brown"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIImage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>!(asset: <span class="type">ImageAssets</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(named: asset.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用上面的代码，我们在新建 UIImage 的时候就不需要去想图片的名字了，而且 Xcode 还会有代码提示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> logo = <span class="type">Asset</span>.<span class="type">AppLogo</span>.appLogo.image</span><br><span class="line"><span class="keyword">let</span> grayLogo = <span class="type">UIImage</span>(asset: <span class="type">Asset</span>.<span class="type">AppLogo</span>.grayLogo)</span><br></pre></td></tr></table></figure><h1 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h1><p>虽然这种方法在调用的时候简单又安全了，但是项目中的图片往往比较多，如果手动编写维护那段代码也是需要不少精力，而且不能保证后续不会添加新的图片，这样每次都要去维护那段代码不免有些反人类。<br>那么现在就要介绍这个开源项目—  <a href="https://github.com/SwiftGen/SwiftGen" target="_blank" rel="noopener"><code>SwiftGen</code></a>了！</p><blockquote><p>SwiftGen is a tool to auto-generate Swift code for resources of your projects, to make them type-safe to use.</p></blockquote><p>利用 SwiftGen 可以帮我们生成这类的代码，但是 SwiftGen 默认生成的代码样式有时候并不是我们想要的，而且默认生成还会有针对 macOS 上的代码，比较好的是 SwiftGen 提供了模板的功能，我们可以按自己的需要来修改模板。</p><h1 id="集成-SwiftGen-在项目中"><a href="#集成-SwiftGen-在项目中" class="headerlink" title="集成 SwiftGen 在项目中"></a>集成 SwiftGen 在项目中</h1><p>SwiftGen 提供了好几种的集成方式，我这里只介绍我自己比较喜欢的方式：就是通过下载它的 Zip 文件解压到项目的目录中，然后通过添加 Run Script 来进行管理。这样可以基本做到不用操心代码。</p><h2 id="1-修改模板"><a href="#1-修改模板" class="headerlink" title="1.修改模板"></a>1.修改模板</h2><ul><li><p>到 SwiftGen仓库的Release页面下载最新的 <a href="https://github.com/SwiftGen/SwiftGen/releases" target="_blank" rel="noopener">swiftgen-5.2.1.zip</a></p></li><li><p>将解压后的 <code>swiftgen-5.2.1</code> 文件夹放到项目所在的目录下(存放<code>xxx.xcodeproj</code> 的位置)，可以将文件夹的名字改为<code>SwiftGen5</code>简洁一点。</p></li><li><p>进入到 <code>SwiftGen5</code> 里的 <code>templates/xcassets</code> 目录下，这里面可以看到有不少模板，我们选择 <code>swift4.stencil</code> 复制一份，命名为 <code>my-swift4.stencil</code> 然后我们就可以在里面修改我们自己想要的模板，我主要是想把 macOS 等其它平台的一些判断代码给删掉:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generated using SwiftGen, using my-templete created by Hanson</span></span><br><span class="line"></span><br><span class="line">&#123;% <span class="keyword">if</span> catalogs %&#125;</span><br><span class="line">&#123;% <span class="keyword">set</span> imageAlias %&#125;&#123;&#123;param.imageAliasName|<span class="keyword">default</span>:<span class="string">"Image"</span>&#125;&#125;&#123;% endset %&#125;</span><br><span class="line"><span class="keyword">import</span> UIKit.UIImage</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> &#123;&#123;imageAlias&#125;&#125; = <span class="type">UIImage</span></span><br><span class="line"></span><br><span class="line">&#123;% <span class="keyword">set</span> enumName %&#125;&#123;&#123;param.enumName|<span class="keyword">default</span>:<span class="string">"Asset"</span>&#125;&#125;&#123;% endset %&#125;</span><br><span class="line">&#123;% <span class="keyword">set</span> imageType %&#125;&#123;&#123;param.imageTypeName|<span class="keyword">default</span>:<span class="string">"ImageAsset"</span>&#125;&#125;&#123;% endset %&#125;</span><br><span class="line"><span class="meta">@available</span>(*, deprecated, renamed: <span class="string">"&#123;&#123;imageType&#125;&#125;"</span>)</span><br><span class="line"><span class="keyword">typealias</span> &#123;&#123;enumName&#125;&#125;<span class="type">Type</span> = &#123;&#123;imageType&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span>&#123;&#123;imageType&#125;&#125; &#123;</span><br><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> image: &#123;&#123;imageAlias&#125;&#125; &#123;</span><br><span class="line"><span class="keyword">let</span> bundle = <span class="type">Bundle</span>(<span class="keyword">for</span>: <span class="type">BundleToken</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="keyword">let</span> image = &#123;&#123;imageAlias&#125;&#125;(named: name, <span class="keyword">in</span>: bundle, compatibleWith: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> result = image <span class="keyword">else</span> &#123; <span class="built_in">fatalError</span>(<span class="string">"Unable to load image named \(name)."</span>) &#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% macro enumBlock assets sp %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% call casesBlock assets sp %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% <span class="keyword">if</span> not param.noAllValues %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% endif %&#125;</span><br><span class="line">&#123;% endmacro %&#125;</span><br><span class="line">&#123;% macro casesBlock assets sp %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% <span class="keyword">for</span> asset <span class="keyword">in</span> assets %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% <span class="keyword">if</span> asset.type == <span class="string">"color"</span> %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  <span class="keyword">static</span> <span class="keyword">let</span> &#123;&#123;asset.name|swiftIdentifier:<span class="string">"pretty"</span>|lowerFirstWord|escapeReservedKeywords&#125;&#125; = &#123;&#123;colorType&#125;&#125;(name: <span class="string">"&#123;&#123;asset.value&#125;&#125;"</span>)</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% elif asset.type == <span class="string">"image"</span> %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  <span class="keyword">static</span> <span class="keyword">let</span> &#123;&#123;asset.name|swiftIdentifier:<span class="string">"pretty"</span>|lowerFirstWord|escapeReservedKeywords&#125;&#125; = &#123;&#123;imageType&#125;&#125;(name: <span class="string">"&#123;&#123;asset.value&#125;&#125;"</span>)</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% elif asset.items %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  <span class="class"><span class="keyword">enum</span> </span>&#123;&#123;asset.name|swiftIdentifier:<span class="string">"pretty"</span>|escapeReservedKeywords&#125;&#125; &#123;</span><br><span class="line">&#123;&#123;sp&#125;&#125;    &#123;% <span class="keyword">set</span> sp2 %&#125;&#123;&#123;sp&#125;&#125;  &#123;% endset %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;    &#123;% call casesBlock asset.items sp2 %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% endif %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% endfor %&#125;</span><br><span class="line">&#123;% endmacro %&#125;</span><br><span class="line">&#123;% macro allValuesBlock assets <span class="built_in">filter</span> <span class="keyword">prefix</span> sp %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% <span class="keyword">for</span> asset <span class="keyword">in</span> assets %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% <span class="keyword">if</span> asset.type == <span class="built_in">filter</span> %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;&#123;<span class="keyword">prefix</span>&#125;&#125;&#123;&#123;asset.name|swiftIdentifier:<span class="string">"pretty"</span>|lowerFirstWord|escapeReservedKeywords&#125;&#125;,</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% elif asset.items %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% <span class="keyword">set</span> prefix2 %&#125;&#123;&#123;<span class="keyword">prefix</span>&#125;&#125;&#123;&#123;asset.name|swiftIdentifier:<span class="string">"pretty"</span>|escapeReservedKeywords&#125;&#125;.&#123;% endset %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% call allValuesBlock asset.items <span class="built_in">filter</span> prefix2 sp %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% endif %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% endfor %&#125;</span><br><span class="line">&#123;% endmacro %&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> </span>&#123;&#123;enumName&#125;&#125; &#123;</span><br><span class="line">&#123;% <span class="keyword">if</span> catalogs.<span class="built_in">count</span> &gt; <span class="number">1</span> %&#125;</span><br><span class="line">&#123;% <span class="keyword">for</span> catalog <span class="keyword">in</span> catalogs %&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> </span>&#123;&#123;catalog.name|swiftIdentifier:<span class="string">"pretty"</span>|escapeReservedKeywords&#125;&#125; &#123;</span><br><span class="line">&#123;% call enumBlock catalog.assets <span class="string">"  "</span> %&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">&#123;% call enumBlock catalogs.first.assets <span class="string">""</span> %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> </span>&#123;&#123;imageAlias&#125;&#125; &#123;</span><br><span class="line"><span class="keyword">convenience</span> <span class="keyword">init</span>!(asset: &#123;&#123;imageType&#125;&#125;) &#123;</span><br><span class="line"><span class="keyword">let</span> bundle = <span class="type">Bundle</span>(<span class="keyword">for</span>: <span class="type">BundleToken</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="keyword">self</span>.<span class="keyword">init</span>(named: asset.name, <span class="keyword">in</span>: bundle, compatibleWith: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BundleToken</span> </span>&#123;&#125;</span><br><span class="line">&#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line"><span class="comment">// No assets found</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h2 id="2-建立RunScript"><a href="#2-建立RunScript" class="headerlink" title="2.建立RunScript"></a>2.建立RunScript</h2></li><li><p>在<code>Xcode</code>中，进入到项目的<code>Target</code>，选择<code>Build Phases</code>,然后点击左上角的 <code>+</code> 号后点击 <code>New Run Script Phase</code>在新建的RunScript里添加如下内容：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">which</span> <span class="string">"<span class="variable">$PROJECT_DIR</span>"</span>/SwiftGen5/bin/swiftgen &gt;/dev/null;</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="string">"<span class="variable">$PROJECT_DIR</span>"</span>/SwiftGen5/bin/swiftgen xcassets -t my-swift4 <span class="string">"<span class="variable">$PROJECT_DIR</span>/swiftGenExample/Assets.xcassets"</span> --output <span class="string">"<span class="variable">$PROJECT_DIR</span>/swiftGenExample/ImageCode/ImageAsset.swift"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"##run echo warning: SwiftGen not installed, download it from https://github.com/SwiftGen/SwiftGen"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>  这段 <code>Run Script</code> 作用就是利用 SwiftGen 生成代码后写入到 <code>ImageAsset.swift</code> 文件中。</p></li><li><p>Build 一下project，我们就可以在 <code>/swiftGenExample/ImageCode/</code> 目录下看到 <code>ImageAsset.swift</code>，此时该文件还没有被项目索引，所以把它拖进项目Xcode对应的目录下就行了，之后即使我们添加了新的图片或者删掉旧的图片，只要每次Build一下项目，代码就会自动更新了。</p></li></ul><p>下面是生成的 <code>ImageAsset.swift</code> 的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ImageAsset.swift</span></span><br><span class="line"><span class="comment">// Generated using SwiftGen, using my-templete created by Hanson</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit.UIImage</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Image</span> = <span class="type">UIImage</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(*, deprecated, renamed: <span class="string">"ImageAsset"</span>)</span><br><span class="line"><span class="keyword">typealias</span> <span class="type">AssetType</span> = <span class="type">ImageAsset</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImageAsset</span> </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> image: <span class="type">Image</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> bundle = <span class="type">Bundle</span>(<span class="keyword">for</span>: <span class="type">BundleToken</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">let</span> image = <span class="type">Image</span>(named: name, <span class="keyword">in</span>: bundle, compatibleWith: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> result = image <span class="keyword">else</span> &#123; <span class="built_in">fatalError</span>(<span class="string">"Unable to load image named \(name)."</span>) &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Asset</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> arrowBlue = <span class="type">ImageAsset</span>(name: <span class="string">"arrow_blue"</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> arrowBrown = <span class="type">ImageAsset</span>(name: <span class="string">"arrow_brown"</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> iconLeftBack = <span class="type">ImageAsset</span>(name: <span class="string">"icon_left_back"</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> startLogo = <span class="type">ImageAsset</span>(name: <span class="string">"start_logo"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>!(asset: <span class="type">ImageAsset</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> bundle = <span class="type">Bundle</span>(<span class="keyword">for</span>: <span class="type">BundleToken</span>.<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(named: asset.name, <span class="keyword">in</span>: bundle, compatibleWith: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BundleToken</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这里只是利用了 <code>SwiftGen</code> 对于 <code>Image</code> 的部分。它还有其它的关于 <code>String</code> ，<code>StroyBoard</code>，<code>Font</code>等等的代码生成。原理基本相同，靠大家按需研究啦。</p><blockquote><p>到我的博客阅读：<a href="http://www.myhanson.com/2017/12/08/%E7%94%A8SwiftGen%E7%AE%A1%E7%90%86UIImage%E7%AD%89%E7%9A%84String-based%E6%8E%A5%E5%8F%A3/#more" target="_blank" rel="noopener">myhanson.com</a><br>本文Demo：<a href="https://github.com/zyphs21/SwiftGenExample" target="_blank" rel="noopener">SwiftGenExample</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift 实现启动屏动画</title>
      <link href="/2017/12/08/Swift%20%E5%AE%9E%E7%8E%B0%E5%90%AF%E5%8A%A8%E5%B1%8F%E5%8A%A8%E7%94%BB/"/>
      <url>/2017/12/08/Swift%20%E5%AE%9E%E7%8E%B0%E5%90%AF%E5%8A%A8%E5%B1%8F%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Github: <a href="https://github.com/zyphs21/SplashAnimate" target="_blank" rel="noopener">SplashAnimate</a></p></blockquote><a id="more"></a><h1 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h1><p>首先我们需要确定作为宣传的图片的宽高比，这个一般是与 UI 确定的。一般启动屏展示会有上下两部分，上面是宣传图片，下面是 App 的 Logo。</p><h1 id="实现基本思路："><a href="#实现基本思路：" class="headerlink" title="实现基本思路："></a>实现基本思路：</h1><p>在 LaunchScreen 结束后，在 AppDelegate 中将 rootViewController 指向展示广告用的 AdViewController，在AdViewController 中设置一段时间后自己销毁，并提供回调方法在 AppDelegate 中将 rootViewController 指向 App 真正的首页。</p><h1 id="实现细节："><a href="#实现细节：" class="headerlink" title="实现细节："></a>实现细节：</h1><p>新建一个 AdViewController 用于放置广告宣传等展示.注意有一个回调方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于 AdViewController 销毁后的回调</span></span><br><span class="line">    <span class="keyword">var</span> completion: (() -&gt; <span class="type">Void</span>)?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> adImage: <span class="type">UIImage?</span></span><br><span class="line">    <span class="keyword">var</span> adView: <span class="type">UIImageView?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ViewDidLoad 方法中配置广告图,同时判断 iPhoneX的特殊情况</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> adViewHeight = (<span class="number">1040</span> / <span class="number">720</span>) * screenWidth</span><br><span class="line">    <span class="keyword">var</span> imageName = <span class="string">"start_page"</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">UIDevice</span>.isiPhoneX() &#123;</span><br><span class="line">        adViewHeight = (<span class="number">1920</span> / <span class="number">1124</span>) * screenWidth</span><br><span class="line">        imageName = <span class="string">"start_page_x"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    adView = <span class="type">UIImageView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: screenWidth, height: adViewHeight))</span><br><span class="line">    adView?.image = <span class="type">UIImage</span>(named: imageName)</span><br><span class="line">    adView?.contentMode = .scaleAspectFill</span><br><span class="line">    <span class="keyword">self</span>.view.addSubview(adView!)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> bottomHolderView = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: screenHeight-<span class="number">120</span>, width: screenWidth, height: <span class="number">120</span>))</span><br><span class="line">    <span class="keyword">self</span>.view.addSubview(bottomHolderView)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> logo = <span class="type">UIImageView</span>(frame: <span class="type">CGRect</span>(x: (screenWidth-<span class="number">120</span>)/<span class="number">2</span>, y: (<span class="number">120</span>-<span class="number">50</span>)/<span class="number">2</span>, width: <span class="number">120</span>, height: <span class="number">50</span>))</span><br><span class="line">    logo.image = <span class="type">UIImage</span>(named: <span class="string">"start_logo"</span>)</span><br><span class="line">    bottomHolderView.addSubview(logo)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> time: <span class="type">TimeInterval</span> = <span class="number">1.0</span></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: <span class="type">DispatchTime</span>.now() + time) &#123;</span><br><span class="line">        <span class="keyword">self</span>.dismissAdView()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中有几个注意的:</p><p>因为图片要撑满屏幕的宽度，所以宽度是固定的，根据图片的高宽比，算出图片实际应有的高度，这样图片可以在各个尺寸的 iPhone 中才不会因为拉伸而变形。但是因为 iPhoneX 特殊的宽高比，所以还是要为它特定一张图片，不然即使图片在 iPhoneX 上不变形，图片所占的高度会太小，或者顶部被刘海遮挡内容而不美观。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> adViewHeight = (<span class="number">1040</span> / <span class="number">720</span>) * screenWidth</span><br><span class="line"><span class="keyword">var</span> imageName = <span class="string">"start_page"</span></span><br><span class="line"><span class="keyword">if</span> <span class="type">UIDevice</span>.isiPhoneX() &#123;</span><br><span class="line">    adViewHeight = (<span class="number">1920</span> / <span class="number">1124</span>) * screenWidth</span><br><span class="line">    imageName = <span class="string">"start_page_x"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面判断是否为 iPhoneX 我是在 UIDevice 里扩展了一个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extension UIDevice &#123;</span><br><span class="line">    public static func isiPhoneX() -&gt; Bool &#123;</span><br><span class="line">        if UIScreen.main.bounds.height &#x3D;&#x3D; 812 &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有注意在执行销毁时调用回调方法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> time: <span class="type">TimeInterval</span> = <span class="number">1.0</span></span><br><span class="line"><span class="type">DispatchQueue</span>.main.asyncAfter(deadline: <span class="type">DispatchTime</span>.now() + time) &#123;</span><br><span class="line">    <span class="keyword">self</span>.dismissAdView()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 AppDelegate 中 didFinishLaunchingWithOptions 方法中调用下面的 setUpWindowAndRootView() 来管理页面展示</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AppDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setUpWindowAndRootView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        window = <span class="type">UIWindow</span>(frame: <span class="type">UIScreen</span>.main.bounds)</span><br><span class="line">        window!.backgroundColor = <span class="type">UIColor</span>.white</span><br><span class="line">        window!.makeKeyAndVisible()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> adVC = <span class="type">AdViewController</span>()</span><br><span class="line">        adVC.completion = &#123;</span><br><span class="line">            <span class="keyword">let</span> vc = <span class="type">ViewController</span>()</span><br><span class="line">            vc.adView = adVC.view</span><br><span class="line">            <span class="keyword">self</span>.window!.rootViewController = vc</span><br><span class="line">        &#125;</span><br><span class="line">        window!.rootViewController = adVC</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在 AdViewController 销毁的回调方法中，将 AdViewController 的 view 传给真正的首页，让首页来执行动画</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adVC.completion = &#123;</span><br><span class="line">    <span class="keyword">let</span> vc = <span class="type">ViewController</span>()</span><br><span class="line">    <span class="comment">// 将 AdViewController 的 view 传给真正的首页，让首页来执行动画</span></span><br><span class="line">    vc.adView = adVC.view</span><br><span class="line">    <span class="keyword">self</span>.window!.rootViewController = vc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在首页 ViewController 里我们有如下方法来执行 AdViewController 的销毁动画，这里配置的动画是常见的扩大渐变消失</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> advertiseView: <span class="type">UIView?</span></span><br><span class="line"><span class="keyword">var</span> adView: <span class="type">UIView?</span> &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        advertiseView = adView!</span><br><span class="line">        advertiseView?.frame = <span class="keyword">self</span>.view.bounds</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(advertiseView!)</span><br><span class="line">        <span class="type">UIView</span>.animate(withDuration: <span class="number">1.5</span>, animations: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>?.advertiseView?.transform = <span class="type">CGAffineTransform</span>(scaleX: <span class="number">1.2</span>, y: <span class="number">1.2</span>)</span><br><span class="line">            <span class="keyword">self</span>?.advertiseView?.alpha = <span class="number">0</span></span><br><span class="line">        &#125;) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (isFinish) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>?.advertiseView?.removeFromSuperview()</span><br><span class="line">            <span class="keyword">self</span>?.advertiseView = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，一个简单的启动屏动画就完成了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>记一次失败的 Swift 元组数组实践</title>
      <link href="/2017/11/28/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%20Swift%20%E5%85%83%E7%BB%84%E6%95%B0%E7%BB%84%E5%AE%9E%E8%B7%B5/"/>
      <url>/2017/11/28/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%20Swift%20%E5%85%83%E7%BB%84%E6%95%B0%E7%BB%84%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>想建立一个元组的数组，来简单存放构建 TabViewController 的信息首先我的做法是</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> homeTab = (vc: <span class="type">VYHomeViewController</span>(), title: <span class="string">"Home"</span>, image: <span class="string">"home_gray"</span>, selectedImage: <span class="string">"home_blue"</span>)</span><br><span class="line"><span class="keyword">let</span> infoTab = (vc: <span class="type">VYInformationViewController</span>(), title: <span class="string">"Info"</span>, image: <span class="string">"home_gray"</span>, selectedImage: <span class="string">"home_blue"</span>)</span><br><span class="line"><span class="keyword">let</span> marketTab = (vc: <span class="type">VYMarketViewController</span>(), title: <span class="string">"Market"</span>, image: <span class="string">"home_gray"</span>, selectedImage: <span class="string">"home_blue"</span>)</span><br><span class="line"><span class="keyword">let</span> userTab = (vc: <span class="type">VYUserCenterViewController</span>(), title: <span class="string">"Me"</span>, image: <span class="string">"home_gray"</span>, selectedImage: <span class="string">"home_blue"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面报错：Heterogeneous collection literal could only be inferred to '[Any]'; add explicit type annotation if this is intentional</span></span><br><span class="line"><span class="keyword">let</span> data = [homeTab, infoTab, marketTab, userTab]</span><br></pre></td></tr></table></figure><p>但是会报错，Xcode 的修改提示是后面添加  <code>as [Any]</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [selfSelectedTab, infoTab, marketTab, userTab] <span class="keyword">as</span> [<span class="type">Any</span>]</span><br></pre></td></tr></table></figure><p>但是这样做已经不是原来的做一个元组数组的初衷了。无法在遍历数组的时候使用命名元组来获取信息</p><a id="more"></a><p>接着我用 <code>typealias</code> 的方法改成如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">TabInfo</span> = (vc: <span class="type">UIViewController</span>, title: <span class="type">String</span>, image: <span class="type">String</span>, selectedImage: <span class="type">String</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tabInfo: [<span class="type">TabInfo</span>] = [<span class="type">TabInfo</span>]()</span><br><span class="line"><span class="keyword">let</span> homeTab = (vc: <span class="type">VYHomeViewController</span>(), title: <span class="string">"Home"</span>, image: <span class="string">"home_gray"</span>, selectedImage: <span class="string">"home_blue"</span>)</span><br><span class="line"><span class="keyword">let</span> infoTab = (vc: <span class="type">VYHomeViewController</span>(), title: <span class="string">"Info"</span>, image: <span class="string">"home_gray"</span>, selectedImage: <span class="string">"home_blue"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面报错：Cannot express tuple conversion '(vc: VYInformationViewController, title: String, image: String, selectedImage: String)' to '(vc: UIViewController, title: String, image: String, selectedImage: String)'</span></span><br><span class="line">tabInfo.append(homeTab)</span><br></pre></td></tr></table></figure><p>给数组添加元素的时候报错，因为元组不支持类型转换，<code>VYHomeViewController</code> 虽然继承 <code>UIViewController</code>，但是元组看来它们不是同一类型。</p><p>最后还是放弃了用元组数组的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> homeTab = (vc: <span class="type">VYHomePageViewController</span>(), title: <span class="type">Home</span>, image: <span class="string">"new_home_gray"</span>, selectedImage: <span class="string">"new_home_blue"</span>)</span><br><span class="line"><span class="keyword">let</span> infoTab = (vc: <span class="type">VYInformationViewController</span>(), title: <span class="type">Info</span>, image: <span class="string">"msg_gray"</span>, selectedImage: <span class="string">"msg_blue"</span>)</span><br><span class="line"><span class="keyword">let</span> marketTab = (vc: <span class="type">VYMarketViewController</span>(), title: <span class="type">Market</span>, image: <span class="string">"hangqing_gray"</span>, selectedImage: <span class="string">"hangqing_blue"</span>)</span><br><span class="line"><span class="keyword">let</span> userTab = (vc: <span class="type">VYUserCenterViewController</span>(), title: <span class="type">Me</span>, image: <span class="string">"mine_gray"</span>, selectedImage: <span class="string">"mine_blue"</span>)</span><br><span class="line"></span><br><span class="line">addViewController(homeTab.vc, title: homeTab.title, image: homeTab.image, selectedIamge: homeTab.selectedImage)</span><br><span class="line">addViewController(infoTab.vc, title: infoTab.title, image: infoTab.image, selectedIamge: infoTab.selectedImage)</span><br><span class="line">addViewController(marketTab.vc, title: marketTab.title, image: marketTab.image, selectedIamge: marketTab.selectedImage)</span><br><span class="line">addViewController(userTab.vc, title: userTab.title, image: userTab.image, selectedIamge: userTab.selectedImage)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自定义 UISegmentedControl 样式</title>
      <link href="/2017/05/09/%E8%87%AA%E5%AE%9A%E4%B9%89%20UISegmentedControl%20%E6%A0%B7%E5%BC%8F/"/>
      <url>/2017/05/09/%E8%87%AA%E5%AE%9A%E4%B9%89%20UISegmentedControl%20%E6%A0%B7%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>系统的 UISegmentedControl 是个挺方便的控件，这里来讲讲在 Swift3 下自定义 UISegmentedControl 的样式，包括修改底色，边框颜色等等。</p><p>要了解 UISegmentedControl 各个部分的组成，可以在官方的文档中找到 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/UIKitUICatalog/UISegmentedControl.html" target="_blank" rel="noopener">UISegmentedControl 文档</a> 。着重注意这个图：<br>   <img src="http://upload-images.jianshu.io/upload_images/757687-3d89e1b80b4e17b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>上面这幅图明确的列出了 UISegmentedControl 各个部分所控制的方法。下面就开始自定义吧。  </p><a id="more"></a><p>首先我们先做一个通过颜色生成图片的的一个扩展方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIImage</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">renderImageWithColor</span>(<span class="title">_</span> <span class="title">color</span>: <span class="title">UIColor</span>, <span class="title">size</span>: <span class="title">CGSize</span>) -&gt; <span class="title">UIImage</span> </span>&#123;</span><br><span class="line">        <span class="type">UIGraphicsBeginImageContext</span>(size)</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>() <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">            <span class="keyword">return</span> <span class="type">UIImage</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        context.setFillColor(color.cgColor);</span><br><span class="line">        context.fill(<span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: size.width, height: size.height));</span><br><span class="line">        <span class="keyword">let</span> img = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">        <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">        <span class="keyword">return</span> img ?? <span class="type">UIImage</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们可以为 UISegmentedControl 建立一个可以自定义颜色的扩展方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UISegmentedControl</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 自定义样式</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameters:</span></span><br><span class="line">    <span class="comment">///   - normalColor: 普通状态下背景色</span></span><br><span class="line">    <span class="comment">///   - selectedColor: 选中状态下背景色</span></span><br><span class="line">    <span class="comment">///   - dividerColor: 选项之间的分割线颜色</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setSegmentStyle</span><span class="params">(normalColor: UIColor, selectedColor: UIColor, dividerColor: UIColor)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> normalColorImage = <span class="type">UIImage</span>.renderImageWithColor(normalColor, size: <span class="type">CGSize</span>(width: <span class="number">1.0</span>, height: <span class="number">1.0</span>))</span><br><span class="line">        <span class="keyword">let</span> selectedColorImage = <span class="type">UIImage</span>.renderImageWithColor(selectedColor, size: <span class="type">CGSize</span>(width: <span class="number">1.0</span>, height: <span class="number">1.0</span>))</span><br><span class="line">        <span class="keyword">let</span> dividerColorImage = <span class="type">UIImage</span>.renderImageWithColor(dividerColor, size: <span class="type">CGSize</span>(width: <span class="number">1.0</span>, height: <span class="number">1.0</span>))</span><br><span class="line">        </span><br><span class="line">        setBackgroundImage(normalColorImage, <span class="keyword">for</span>: .normal, barMetrics: .<span class="keyword">default</span>)</span><br><span class="line">        setBackgroundImage(selectedColorImage, <span class="keyword">for</span>: .selected, barMetrics: .<span class="keyword">default</span>)</span><br><span class="line">        setDividerImage(dividerColorImage, forLeftSegmentState: .normal, rightSegmentState: .normal, barMetrics: .<span class="keyword">default</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> segAttributesNormal: <span class="type">NSDictionary</span> = [<span class="type">NSForegroundColorAttributeName</span>: <span class="type">UIColor</span>.gray, <span class="type">NSFontAttributeName</span>: <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">14</span>)]</span><br><span class="line">        <span class="keyword">let</span> segAttributesSeleted: <span class="type">NSDictionary</span> = [<span class="type">NSForegroundColorAttributeName</span>: <span class="type">UIColor</span>.white,<span class="type">NSFontAttributeName</span>: <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">14</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 文字在两种状态下的颜色</span></span><br><span class="line">        setTitleTextAttributes(segAttributesNormal <span class="keyword">as</span> [<span class="type">NSObject</span> : <span class="type">AnyObject</span>], <span class="keyword">for</span>: <span class="type">UIControlState</span>.normal)</span><br><span class="line">        setTitleTextAttributes(segAttributesSeleted <span class="keyword">as</span> [<span class="type">NSObject</span> : <span class="type">AnyObject</span>], <span class="keyword">for</span>: <span class="type">UIControlState</span>.selected)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 边界颜色、圆角</span></span><br><span class="line">        <span class="keyword">self</span>.layer.borderWidth = <span class="number">0.7</span></span><br><span class="line">        <span class="keyword">self</span>.layer.cornerRadius = <span class="number">5.0</span></span><br><span class="line">        <span class="keyword">self</span>.layer.borderColor = dividerColor.cgColor</span><br><span class="line">        <span class="keyword">self</span>.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个扩展方法我只暴露了三种颜色的修改，大家可以根据自己需求修改。<br>最后就是使用了，注意这里如果进行了自定义，不能用 autoLayout 了, 需指定 Segement 的位置大小，不然显示出来的效果被压缩成了一条线，我估计是 setBackgroundImage 的方法需要把 1x1 的颜色图片进行填充，如果不指定大小会出差错。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> segment = <span class="type">UISegmentedControl</span>(items: [<span class="string">"测试"</span>, <span class="string">"测试"</span>, <span class="string">"测试"</span>])</span><br><span class="line">segment.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">150</span>, height: <span class="number">40</span>)</span><br><span class="line">segment.setSegmentStyle(normalColor: <span class="type">UIColor</span>.clear, selectedColor: <span class="type">UIColor</span>.cyan, dividerColor: <span class="type">UIColor</span>.gray)</span><br><span class="line">segment.selectedSegmentIndex = <span class="number">0</span></span><br><span class="line">view.addSubview(segment)</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/757687-b2cff0c753e73846.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>个人比较喜欢用 extension 扩展方法，这里大家直接拷贝就能够使用了，祝大家自定义愉快吧~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HSStockChart介绍</title>
      <link href="/2017/05/03/HSStockChart%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/05/03/HSStockChart%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>HSStockChart 是一个绘制股票分时图、K 线图的库。支持流畅的回弹拖动，长按十字线，捏合放大缩小等功能，主要使用了 CAShapeLayer 来绘图，相比使用 Core Graphics 和重写 drawRect 的方法更高效，占用内存更小。<br><a href="https://github.com/zyphs21/HSStockChart" target="_blank" rel="noopener">GitHub 地址：HSStockChart</a>  </p><p><img src="http://upload-images.jianshu.io/upload_images/757687-92b2069869929ccd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><a id="more"></a><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li><input checked="" disabled="" type="checkbox"> 支持绘制分时图，五日分时图，K 线图，MA 线指标，交易量柱等。</li><li><input checked="" disabled="" type="checkbox"> 支持横屏查看。</li><li><input checked="" disabled="" type="checkbox"> K 线图利用 <code>UIScrollView</code> 达到流畅的滑动查看效果。</li><li><input checked="" disabled="" type="checkbox"> 使用 <code>CAShapeLayer</code> 绘图，内存占用更小，效率更高。</li></ul><h2 id="版本需求"><a href="#版本需求" class="headerlink" title="版本需求"></a>版本需求</h2><ul><li>iOS 8.0+</li><li>Swift 3</li></ul><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ol><li><p>之前绘图的方法是重写 <code>drawRect</code> 方法，在方法里获取 <code>CGContext</code> 然后利用Core Graphics 来进行绘图，调用 <code>setNeedsDisplay</code> 来刷新。但是这种方法有个问题是：</p><blockquote><p>一旦你实现了 CALayerDelegate 协议中的 -drawLayer:inContext: 方法或者 UIView 中的 -drawRect: 方法（其实就是前者的包装方法），图层就创建了一个绘制上下文，这个上下文需要的内存可从这个公式得出：图层宽x图层高x4字节，宽高的单位均为像素。对于一个在 Retina iPad 上的全屏图层来说，这个内存量就是 2048x1526x4字节，相当于12MB内存，图层每次重绘的时候都需要重新抹掉内存然后重新分配。【摘自 iOS Core Animation- Advanced Techniques 中文译本 高效绘图一章】</p></blockquote><p>因为我要达到流畅滑动查看的效果，所以在 <code>UIScrollView</code> 上添加了一个 <code>UIView</code> 这个 View 的宽度会依据当前展示数据的多少而变化，结合 <code>UIScrollView</code> 的 <code>ContentSize</code> 就能达到很好的滑动效果。</p><p><img src="http://upload-images.jianshu.io/upload_images/757687-36a3d278fd71fc4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>如果我用之前重写 <code>drawRect</code> 的方法，那么这个 View 会根据数据量的变大而变大，从而导致绘图内存急剧上升，数据量大的时候会崩溃。基于此，我采用了 <code>CAShapeLayer</code> 的方式绘图，此方式的特点如下：</p><blockquote><p>CAShapeLayer 是一个通过矢量图形而不是 bitmap 来绘制的图层子类。你指定诸如颜色和线宽等属性，用 CGPath 来定义想要绘制的图形，最后就自动渲染出来了。当然，你也可以用 Core Graphics 直接向原始的内容中绘制一个路径，相比之下，使用 CAShapeLayer 有以下一些优点:</p><ul><li>渲染快速。CAShapeLayer 使用了硬件加速，绘制同一图形会比用 Core Graphics 快很多。</li><li>高效使用内存。一个 CAShapeLayer 不需要像普通 CALayer 一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。 </li><li>不会被图层边界剪裁掉，一个 CAShapeLayer 可以在边界之外绘制。你的图层路径不会像在使用 Core Graphics 的普通 CALayer 一样被剪裁掉。</li><li>不会出现像素化。当你给 CAShapeLayer 做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化</li></ul></blockquote><p>最终在真机上测试(注意是在真机上测试)两种方式的结果如图，内存大大降低并且稳定在13M左右</p><p> <img src="http://upload-images.jianshu.io/upload_images/757687-a773aeda8ac7ff01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>自定义 CAShapeLayer，重写 action(forKey event: String) 方法。目的是 关闭 CAShapeLayer 的隐式动画，避免滑动时候或者十字线出现时有残影的现象(实际上是因为 Layer 的 position 属性变化而产生的隐式动画)</p></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HSCAShapeLayer</span>: <span class="title">CAShapeLayer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">action</span><span class="params">(forKey event: String)</span></span> -&gt; <span class="type">CAAction?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>Released under MIT License.</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
