<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PathToGo “没什么卵用” 的更新</title>
      <link href="/2020/06/28/PathToGo%E6%B2%A1%E4%BB%80%E4%B9%88%E5%8D%B5%E7%94%A8%E7%9A%84%E6%9B%B4%E6%96%B0/"/>
      <url>/2020/06/28/PathToGo%E6%B2%A1%E4%BB%80%E4%B9%88%E5%8D%B5%E7%94%A8%E7%9A%84%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<p>PathToGo 是一个可以复制当前选中文件的路径到粘贴板的小 Mac App。具体可以看看之前写的文章 <a href="">《PathToGo诞生记》</a> 。</p><a id="more"></a><h3 id="用户反馈"><a href="#用户反馈" class="headerlink" title="用户反馈"></a>用户反馈</h3><p>PathToGo 解决的是一个很冷门的需求，即便是我，也不会经常用它。甚至很多人觉得它 <code>“没有什么卵用”</code>。但是它仍然收获了一部分用户，甚至还收到用户的反馈：</p><p><img src="https://imgkr.cn-bj.ufileos.com/ccdab9e6-bae4-4fa5-9f4c-a245b16894e7.png" alt=""></p><p>这个用户的需求是希望复制出来的文件路径可以带上 <code>反斜杠转义符</code>，这样他可以直接复制到他的终端里跳转路径使用。</p><p>很明显，这个用户并不知道 <code>Go2Shell</code> ，这款给了 <code>PathToGo</code> 诞生灵感的 App。如果他使用 <code>Go2Shell</code>  的话应该能够很好地解决他真正的需求。</p><h3 id="我的吐槽"><a href="#我的吐槽" class="headerlink" title="我的吐槽"></a>我的吐槽</h3><p>Anyway，既然有用户反馈，我有了一点点更新它的动力。不过最大的动力还是来自于我对 <code>PathToGo</code> 的不满：<strong>它实在太丑了！</strong></p><p>因为 <code>PathToGo</code> 的使用场景，注定它要常驻在 Finder 的 Toolbar 上。而当初在设计图标的时候，脑抽地给它设置了一个<strong>半透明背景</strong> 😂。在 macOS 的浅色模式下还好，但是在深色模式下的样子真的一言难尽：</p><p><img src="https://imgkr.cn-bj.ufileos.com/a416976a-2092-4f0c-801a-057cbfc20a4a.png" alt="浅色模式下显示"></p><p><img src="https://imgkr.cn-bj.ufileos.com/62b41f1b-cbf7-4cce-9b06-0863befd9df6.png" alt="深色模式下显示"></p><p>如上图，真的太丑了！而且图标的大小与 Toolbar 上的其它 icon 相比显得是如此的格格不入。</p><h3 id="重新设计图标"><a href="#重新设计图标" class="headerlink" title="重新设计图标"></a>重新设计图标</h3><p>所以，更新 PathToGo 的首要任务是重新设计图标！</p><p>设计不是我的长项，所以我给自己订的只有两个要求：</p><ol><li>改掉背景色 </li><li>图标尺寸在 Finder 上不要显得那么突兀</li></ol><p>打开 Sketch，一顿操作后，PathToGo 的图标现在长这样了：</p><p><img src="https://imgkr.cn-bj.ufileos.com/8459c5a7-cd62-4bf6-a9d9-a32766274a5c.png" alt="PathToGo图标"></p><p>然后它在 Finder 上是这样子的：</p><p><img src="https://imgkr.cn-bj.ufileos.com/9fd7a8c4-f2ad-4cf5-8587-f139480f978e.png" alt=""></p><p>嗯嗯，看着还可以。</p><p>不过还能更进一步吗？能在好看的同时又能够满足上面用户反馈的需求吗？</p><p>这时候，我发现了一个东西：<strong><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/Finder.html" target="_blank" rel="noopener">FinderSync</a></strong></p><h3 id="用-FinderSync-改造"><a href="#用-FinderSync-改造" class="headerlink" title="用 FinderSync 改造"></a>用 FinderSync 改造</h3><p>FinderSync 是苹果提供的一个扩展功能，它的目的是可以让开发者自定义 Finder 文件的界面，以提示用户文件的监听使用状态等。比如你的 App 可以进行文件同步的功能，你希望让用户知道当前文件是否已经同步完成了，可以通过 FinderSync 这个扩展来给文件添加 icon 以达到提示的作用：</p><p><img src="https://imgkr.cn-bj.ufileos.com/f2ad6a3f-ef5c-4c0d-9ec6-5f78b9774ea3.png" alt=""></p><p>我注意到 FinderSync 可以给 Finder 添加一个原生的 Toolbar！如果 PathToGo 可以做成一个原生样式的 Toolbar 按钮，那不就太完美了吗？</p><p>不过 FinderSync 只支持有下拉选项的 Toolbar 按钮样式，那其实可以将上面用户反馈的功能做到这里：</p><p>点击下拉出两个选项，一个是复制纯文本，一个是复制出带有反斜杠转义的文本。</p><p>这样就既能保留 PathToGo 原有的功能基础上，扩展出了新的功能，尽管与 PathToGo <code>一点击即达</code> 的初衷有点违背，但是我认为这是<strong>在权衡好看和功能性两者之间的最好妥协</strong>。</p><p>于是，PathToGo 在支持原来拖动放置在 Finder Toolbar 的形式的基础上，多了一种以 FinderSync 为踏板的新形式，<strong>终于让它很好地融入了 Toolbar 上</strong>：</p><p><img src="https://imgkr.cn-bj.ufileos.com/51709307-f8e5-4715-90a8-a1eea46296ba.png" alt="PathToGo 在 Finder Toolbar 上"></p><p>添加的方式是：右击 Finder Toolbar 空白处，进入自定义 Toolbar，找到 PathToGo 并拖动添加到 Toolbar 上就可以啦！</p><p><img src="https://imgkr.cn-bj.ufileos.com/464ba02e-a880-425c-8da3-9032d820fd1e.png" alt=""></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>尽管在很多人看来 PathToGo 还是一个没什么卵用的东西，但是这次从出现更新的念头，到最后利用 FinderSync “曲线救国”的实现过程，我是觉得很有意思的。</p><blockquote><p>PathToGo 下载地址：<code>https://github.com/HansonStudio/PathToGo/releases</code></p></blockquote><blockquote><p>欢迎关注我的公众号：HansonTalk<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/qrcode/HansonTalk.jpg" alt=""></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 开源/产品 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>通过 DeveloperID证书分发 Mac App 的经验</title>
      <link href="/2020/06/12/%E9%80%9A%E8%BF%87%20DeveloperID%E8%AF%81%E4%B9%A6%E5%88%86%E5%8F%91%20Mac%20App%20%E7%9A%84%E7%BB%8F%E9%AA%8C/"/>
      <url>/2020/06/12/%E9%80%9A%E8%BF%87%20DeveloperID%E8%AF%81%E4%B9%A6%E5%88%86%E5%8F%91%20Mac%20App%20%E7%9A%84%E7%BB%8F%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>对 Mac App 打包后，我们可以选择通过 <code>Developer ID</code> 方式直接向我们的客户分发 Mac App 而不用将 App 传到 Mac App Store。</p><p><img src="https://imgkr.cn-bj.ufileos.com/e0d7c2cf-f9a7-4f3c-8351-282e3ac12094.png" alt=""></p><p>在这个过程中遇到了一些坑，故总结分享一下。</p><a id="more"></a><h2 id="Developer-ID-证书"><a href="#Developer-ID-证书" class="headerlink" title="Developer ID 证书"></a>Developer ID 证书</h2><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>首先我们需要创建 Developer ID 证书，具体如何创建可以看苹果的这个 <a href="https://help.apple.com/developer-account/#/dev04fd06d56" target="_blank" rel="noopener">文档: 创建 Developer ID 证书</a>。</p><p>但是这里有个需要很注意的问题：使用开发者帐户或 Xcode 可以创建 <code>最多五个</code> Developer ID App 证书。</p><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><p>撤销删除 Developer ID App 证书 并不是随意操作的，不管你的苹果开发者账号的角色是什么，需通过 <code>product-security@apple.com</code> 向 Apple 发送请求，才可以删除。</p><p>而且注意，<strong>如果您撤销了 Developer ID 证书，用户便无法安装使用该证书签名的 app。</strong></p><blockquote><p>更详细的撤销证书权限可以看这个 <a href="https://help.apple.com/developer-account/#/dev138c9fac7" target="_blank" rel="noopener">文档: 撤销权限</a></p></blockquote><p>所以这里需要注意保管好 Developer ID 证书的私钥。我就试过换了电脑后，本地证书没有私钥的尴尬情况，就是常见的 <code>Missing Private key</code> 错误，如果你的 Developer ID 证书数量刚好达到了上限，无法创建新的证书，又丢失了旧的证书的私钥的话，这个情况就只能通过 <code>product-security@apple.com</code> 向 Apple 发送请求撤销旧的证书，再创建新的了。所以这里建议可以事先在 KeyChain Access.app 里导出 p12 文件做好保管。</p><h2 id="Notarization-苹果公证"><a href="#Notarization-苹果公证" class="headerlink" title="Notarization 苹果公证"></a>Notarization 苹果公证</h2><p>从 <code>macOS 10.14.5</code> 之后，通过 Developer ID 证书分发的 App，苹果建议都需要通过苹果的公证(Notarized)，以代表这个 App 不含有恶意内容，否则的话每次用户初次打开你的 App 的时候都会有 <code>无法检查是否包含恶意软件</code> 的安全提示，类似如下图：</p><p><img src="https://imgkr.cn-bj.ufileos.com/c7fb34a3-d41d-4003-beb8-3bc2ba3061da.png" alt=""></p><p>这时候需要去到系统设置的安全与隐私那里，选择仍要打开：</p><p><img src="https://imgkr.cn-bj.ufileos.com/3ac18848-7e5e-4ea5-b942-64c9b54efad7.png" alt=""></p><p>这时候还会有个安全提示，但是这次是有 <code>打开</code> 选项的：</p><p><img src="https://imgkr.cn-bj.ufileos.com/9cb935ba-b1d0-417b-9a28-318bfd5459f4.png" alt=""></p><p>这一顿操作下来其实对用户的体验很不友好，让人产生对 App 的不信任感。</p><p>所以这里还是建议大家把 App 上传给苹果进行公证。如下图在打包的时候可以选择 <code>Upload</code> 给苹果进行 Notarize</p><p><img src="https://imgkr.cn-bj.ufileos.com/15ed1b9d-485e-4c5a-90ed-66a329d5d246.png" alt=""></p><blockquote><p>关于 Notarization 这块更详细的内容，可以查看这个 <a href="https://developer.apple.com/documentation/xcode/notarizing_macos_software_before_distribution" target="_blank" rel="noopener">文档: Notarizing macOS Software Before Distribution</a></p></blockquote><blockquote><p>欢迎关注我的个人公众号：HansonTalk，分享点有意思的。<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/qrcode/HansonTalk.jpg" alt=""></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>利用 Vision给无人机图传加上人脸识别功能</title>
      <link href="/2020/06/08/%E5%88%A9%E7%94%A8%20Vision%20%E7%BB%99%E6%97%A0%E4%BA%BA%E6%9C%BA%E5%9B%BE%E4%BC%A0%E5%8A%A0%E4%B8%8A%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%8A%9F%E8%83%BD/"/>
      <url>/2020/06/08/%E5%88%A9%E7%94%A8%20Vision%20%E7%BB%99%E6%97%A0%E4%BA%BA%E6%9C%BA%E5%9B%BE%E4%BC%A0%E5%8A%A0%E4%B8%8A%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>Vision 是 iOS 上一个机器视觉的框架，它可以对图片和视频进行多种机器视觉相关的任务处理。Vision 里的人脸识别功能是最常用的功能之一，经过几次的迭代，它的识别效果已经很不错了，具体可以看看 <code>WWDC2017 Session 506</code>, <code>WWDC2018 Session 716、717</code> 和 <code>WWDC 2019 Session 222</code>，本文的 <a href="https://github.com/zyphs21/VisionDetect" target="_blank" rel="noopener">Demo-VisoinDetect</a> 有些代码就是从这些 Session 中的示例代码修改而来。</p><p>这里我们要做的东西是: 将 DJISDK 提供给我们的视频流数据，传入 Vision 框架进行人脸识别，然后拿到人脸信息在图传界面显示出来。效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyphs21/VisionDetect/detectFace.gif" alt=""></p><a id="more"></a><h2 id="一、获取无人机图传视频流"><a href="#一、获取无人机图传视频流" class="headerlink" title="一、获取无人机图传视频流"></a>一、获取无人机图传视频流</h2><blockquote><p>相信大家对无人机App激活连接这部分已经比较熟悉了，这里就不赘述，不熟悉的话请查阅 DJISDK 文档</p></blockquote><h3 id="1-注册-VideoFrameProcessor，获取到-VideoFrameYUV"><a href="#1-注册-VideoFrameProcessor，获取到-VideoFrameYUV" class="headerlink" title="1. 注册 VideoFrameProcessor，获取到 VideoFrameYUV"></a>1. 注册 VideoFrameProcessor，获取到 VideoFrameYUV</h3><p>视频流数据其实就是一帧帧的图片，而 Vision 可以接收 <code>CVPixelBuffer</code> 的图片数据，所以我们需要把图传数据转换成 <code>CVPixelBuffer</code> 。</p><p>这里我们利用 DJIWidget 的 <code>VideoFrameProcessor</code> 来获取视频流的帧数据。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> DJISDK</span><br><span class="line"><span class="keyword">import</span> DJIWidget</span><br><span class="line"></span><br><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> videoPreview: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="type">DJIVideoPreviewer</span>.instance().setView(videoPreview)</span><br><span class="line">    <span class="type">DJIVideoPreviewer</span>.instance().enableHardwareDecode = <span class="literal">true</span></span><br><span class="line">    <span class="type">DJIVideoPreviewer</span>.instance().enableFastUpload = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewWillAppear(animated)</span><br><span class="line">    </span><br><span class="line">    <span class="type">DJIVideoPreviewer</span>.instance().type = .autoAdapt</span><br><span class="line">    <span class="comment">// 调用 registFrameProcessor 方法</span></span><br><span class="line">    <span class="type">DJIVideoPreviewer</span>.instance()?.registFrameProcessor(<span class="keyword">self</span>)</span><br><span class="line">    <span class="type">DJIVideoPreviewer</span>.instance()?.start()</span><br><span class="line">    <span class="type">DJISDKManager</span>.videoFeeder()?.primaryVideoFeed.add(<span class="keyword">self</span>, with: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillDisappear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewWillDisappear(animated)</span><br><span class="line">    </span><br><span class="line">    <span class="type">DJISDKManager</span>.videoFeeder()?.primaryVideoFeed.remove(<span class="keyword">self</span>)</span><br><span class="line">    <span class="type">DJIVideoPreviewer</span>.instance().unSetView()</span><br><span class="line">    <span class="type">DJIVideoPreviewer</span>.instance().close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是我们常规获取视频流的方法，不过我们还调用了 <code>registFrameProcessor</code> 的方法，调用了该方法后，我们需要实现 <code>VideoFrameProcessor</code> 的代理方法，从代理方法中可以获取到视频流的 <code>VideoFrameYUV</code> 数据。</p><h3 id="2-将-VideoFrameYUV-转换成-CVPixelBuffer"><a href="#2-将-VideoFrameYUV-转换成-CVPixelBuffer" class="headerlink" title="2. 将 VideoFrameYUV 转换成 CVPixelBuffer"></a>2. 将 VideoFrameYUV 转换成 CVPixelBuffer</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: - VideoFrameProcessor</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DJIVideoViewController</span>: <span class="title">VideoFrameProcessor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">videoProcessorEnabled</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">videoProcessFrame</span><span class="params">(<span class="number">_</span> frame: UnsafeMutablePointer&lt;VideoFrameYUV&gt;!)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> resolution = <span class="type">CGSize</span>(width: <span class="type">CGFloat</span>(frame.pointee.width), height: <span class="type">CGFloat</span>(frame.pointee.height))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> frame.pointee.cv_pixelbuffer_fastupload != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 把 cv_pixelbuffer_fastupload 转换成 CVPixelBuffer 对象</span></span><br><span class="line">            <span class="keyword">let</span> cvBuf = <span class="built_in">unsafeBitCast</span>(frame.pointee.cv_pixelbuffer_fastupload, to: <span class="type">CVPixelBuffer</span>.<span class="keyword">self</span>)</span><br><span class="line">            setupCaptureDeviceResolution(resolution)</span><br><span class="line">            detectFace(pixelBuffer: cvBuf)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 自行构建 CVPixelBuffer 对象</span></span><br><span class="line">            <span class="keyword">let</span> pixelBuffer = frame.pointee.createPixelBuffer()</span><br><span class="line">            setupCaptureDeviceResolution(resolution)</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> cvBuf = pixelBuffer <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            detectFace(pixelBuffer: cvBuf)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>func videoProcessFrame(_ frame: UnsafeMutablePointer&lt;VideoFrameYUV&gt;!)</code> 的代理方法中，我们可以拿到 <code>VideoFrameYUV</code> 的数据。</p><p>理论上，在支持 HardwareDecode 的设备上，如果开启了 <code>HardwareDecode</code> 和 <code>Fastupload</code> , 返回的 <code>VideoFrameYUV</code> 里的 <code>luma</code>, <code>chromaB</code> and <code>chromaR</code> 可能会是空的(就无法构建 CVPixelBuffer)，这时候可以通过 <code>cv_pixelbuffer_fastupload</code> 获取到 <code>CVPixelBuffer</code> 的值。所以上面的代码里先判断 <code>frame.pointee.cv_pixelbuffer_fastupload</code> 是否不为 nil。</p><p>如果 cv_pixelbuffer_fastupload 为 nil 则我们需要自行构建 <code>CVPixelBuffer</code>，这里我们给 <code>VideoFrameYUV</code> 添加了一个扩展方法 <code>createPixelBuffer()</code> 以构建 <code>CVPixelBuffer</code>，这里就不贴代码了，具体可以查看 <a href="https://github.com/zyphs21/VisionDetect" target="_blank" rel="noopener">Github</a> 上的源码。</p><blockquote><p>针对开启 HardwareDecode 获取到 cv_pixelbuffer_fastupload 的情况，目前我手头上的设备是无法获取得到，总是需要进行构建 CVPixelBuffer。这个问题在 <a href="https://github.com/dji-sdk/DJIWidget/issues/9" target="_blank" rel="noopener">DJIWidget Github issue9</a> 有相关的讨论。</p></blockquote><h2 id="二、把-CVPixelBuffer-传给-Vision-处理"><a href="#二、把-CVPixelBuffer-传给-Vision-处理" class="headerlink" title="二、把 CVPixelBuffer 传给 Vision 处理"></a>二、把 CVPixelBuffer 传给 Vision 处理</h2><p>Vision 对数据的处理逻辑可以分为三步：</p><table><thead><tr><th>步骤</th><th></th></tr></thead><tbody><tr><td>做什么</td><td>VNRequest</td></tr><tr><td>怎么做</td><td>VNImageRequestHandler<br/>VNSequenceRequestHandler</td></tr><tr><td>处理结果</td><td>VNObservation</td></tr></tbody></table><h4 id="1-做什么-识别人脸及五官信息"><a href="#1-做什么-识别人脸及五官信息" class="headerlink" title="1. 做什么: 识别人脸及五官信息"></a>1. 做什么: 识别人脸及五官信息</h4><p>为了识别人脸及其五官信息，我们需要创建 <code>VNDetectFaceLandmarksRequest</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> detectFaceRequest = <span class="type">VNDetectFaceLandmarksRequest</span>(completionHandler: detectedFace)</span><br></pre></td></tr></table></figure><h4 id="2-怎么做-VNSequenceRequestHandler"><a href="#2-怎么做-VNSequenceRequestHandler" class="headerlink" title="2. 怎么做: VNSequenceRequestHandler"></a>2. 怎么做: VNSequenceRequestHandler</h4><p>因为我们需要处理视频流的一帧帧图片数据，所以我们用 <code>VNSequenceRequestHandler</code> 来执行 <code>FaceLandmarksRequest</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 注意无人机图传中照片都是 downMirrored 的，即(0, 0)在左下角</span></span><br><span class="line">    <span class="keyword">try</span> sequenceRequestHandler.perform([detectFaceRequest], on: pixelBuffer, orientation: .downMirrored)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"----执行 sequenceRequestHandler 失败: \(error.localizedDescription)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 perform 方法时，除了传入要执行的 request 和 pixelBuffer 外，还需要注意传入图片的 Orientation 信息，以让 Vision 知道这个图片是倒着的还是反转的等等。因为我们的视频流是从无人机传过来的，这里测试发现都是 <code>downMirrored</code> 的，即照片的 (0, 0) 点在左下角。</p><h4 id="3-处理结果：绘制人脸图层"><a href="#3-处理结果：绘制人脸图层" class="headerlink" title="3. 处理结果：绘制人脸图层"></a>3. 处理结果：绘制人脸图层</h4><p>最终得到的结果是封装在 <code>VNFaceObservation</code> 的对象里的，通过该对象可以拿到人脸相对于图片的坐标：<code>boundingBox</code> 以及五官的坐标信息 <code>landmarks</code>，从而可以绘制在图传界面上。具体绘制方法 <code>drawFaceObservations</code> 可以在 <a href="https://github.com/zyphs21/VisionDetect" target="_blank" rel="noopener">Github</a> 上查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func detectedFace(request: VNRequest, error: Error?) &#123;</span><br><span class="line">    if let error &#x3D; error &#123;</span><br><span class="line">        print(&quot;---detectedFaceRequest Error: \(error.localizedDescription)&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    guard let results &#x3D; request.results as? [VNFaceObservation] else &#123; return &#125;</span><br><span class="line"></span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">        self.drawFaceObservations(results)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里的关键点是在于：如何从无人机图传视频流里拿到 <code>CVPixelBuffer</code> ———— 这个 Vision 可以接受的数据。</p><p>另外一个的关键点是如何在图传界面上绘制出人脸信息，这里涉及到如何获取到视频图片的真实大小(Pixel单位)、ordination 等。</p><p>一旦处理好这些关键点，其余的问题就迎刃而解了。</p><blockquote><p>欢迎关注我的公众号：HansonTalk<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/qrcode/HansonTalk.jpg" alt=""></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CoreLocation 中的 Course 和 Heading 简析</title>
      <link href="/2020/04/15/CoreLocation%E4%B8%AD%E7%9A%84Course%E5%92%8CHeading%E7%AE%80%E6%9E%90/"/>
      <url>/2020/04/15/CoreLocation%E4%B8%AD%E7%9A%84Course%E5%92%8CHeading%E7%AE%80%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>很多地图 App 都会有一个当前定位的标记，该标记可以根据用户手持手机的朝向不同而改变方向。如图：</p><img src="https://imgkr.cn-bj.ufileos.com/6a305cfc-4d8e-4f17-ad25-d40534e29aec.png" width = "80" height = "80" alt="带方向的定位标记" align=center /><p>如果要实现这个带方向定位的标记点，需要什么数据呢？</p><a id="more"></a><ul><li>定位数据</li><li>手机朝向数据</li></ul><p>定位数据获取很简单，调用 <code>CLLocationManager</code> 的 <code>startUpdatingLocation()</code> 方法，然后在 <code>didUpdateLocations</code> 的回调方法中可以得到的 <code>CLLocation</code> 属性值。</p><p><code>CLLocation</code> 对象中，除了有我们需要的 coordinate 位置数据外，还有一个 <code>course</code> 属性。</p><p>这个 <code>course</code> 属性是不是我们需要的手机朝向数据呢？</p><blockquote><p>course:<br>The direction in which the device is traveling, measured in degrees and relative to due north.</p></blockquote><blockquote><p>Course values are measured in degrees starting at due north and continue clockwise around the compass. Thus, north is 0 degrees, east is 90 degrees, south is 180 degrees, and so on. Course values may not be available on all devices. A negative value indicates that the course information is invalid.</p></blockquote><p>从文档的解释来看，它是一个相对于地理北极以顺时针方向的角度数据，手机朝着正北方是 0 度，朝着东边是 90度，依次类推。</p><p>看起来是我们想要的值。但是从实际测试(真机室内测试)结果看，<strong>这个值一直是返回 -1 。（负数代表此值当前不可用）</strong></p><p>排除使用方式的不对，我们从文档 <a href="https://developer.apple.com/documentation/corelocation/getting_heading_and_course_information" target="_blank" rel="noopener">Getting Heading and Course Information</a> 发现，我们要获取的其实是 <code>heading</code>  的数据。</p><p>通过调用 CLLocationManager 中的 </p><pre><code>startUpdatingHeading()</code></pre><p>然后在 <code>locationManager(_:didUpdateHeading:)</code> 的回调方法中就可以获取到 heading 的数据了。</p><h2 id="Course-和-Heading"><a href="#Course-和-Heading" class="headerlink" title="Course 和 Heading"></a>Course 和 Heading</h2><p>从字面意思上我们可以将它们区分为 <code>航向</code> 和 <code>朝向</code></p><p><code>Course(航向)信息</code> 反映的是设备移动的速度和方向，并且仅在具有GPS硬件条件的设备上可用。</p><p>注意不要将 <code>Course(航向)</code> 与 <code>Heading(朝向)</code> 混淆。Course(航向) 反映的是设备移动时的方向，是<strong>从GPS信息中获取到，它与设备的物理方向无关</strong>。</p><p>而 <code>Heading(朝向)信息</code> 则是通过计算手机上传感器的值而获取到的相对于地理北极的角度信息。</p><h3 id="Course"><a href="#Course" class="headerlink" title="Course"></a>Course</h3><p>Course 常常是用在进行导航的情况下。比如平时我们开车进行导航的时候，有时候车子转弯过快，会发现导航上的朝向并没有及时更新到正确的方向，要过一会才会更新，这就是因为 GPS 信息没有及时更新过来，故 Course 信息也就无法有足够的数据支持它更新。</p><h3 id="Heading"><a href="#Heading" class="headerlink" title="Heading"></a>Heading</h3><p>Heading 是与物理设备有关的值，所以我们在获取 Heading 信息的时候，注意要配置 CLLocationManager 的 <code>headingOrientation</code> 属性。</p><p>headingOrientation 默认值是 <code>portrait</code> ，即我们平时正面拿着手机。而当我们正面横着拿手机的时候，需要将 <code>headingOrientation</code> 属性根据实际情况改成 <code>landscapeLeft</code> 或者 <code>landscapeRight</code>，这样系统才能通过手机的持有方位计算正确的 <code>Heading</code> 值，不然 Heading 就一直是默认以 portrait 的形式计算得到。</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算地图缩放等级 zoomLevel</title>
      <link href="/2019/05/08/%E8%AE%A1%E7%AE%97%E5%9C%B0%E5%9B%BE%E7%BC%A9%E6%94%BE%E7%AD%89%E7%BA%A7zoomLevel/"/>
      <url>/2019/05/08/%E8%AE%A1%E7%AE%97%E5%9C%B0%E5%9B%BE%E7%BC%A9%E6%94%BE%E7%AD%89%E7%BA%A7zoomLevel/</url>
      
        <content type="html"><![CDATA[<h2 id="背景及问题分析"><a href="#背景及问题分析" class="headerlink" title="背景及问题分析"></a>背景及问题分析</h2><p>在一些第三方的地图 SDK 中，往往会有 <code>zoomLevel</code> 这样一个属性，常用于设置地图的缩放等级。</p><p>但是在 iOS 自带的地图控件 <code>MKMapView</code> 是没有这样一个属性的。取而代之的是利用 <code>MKCoordinateRegion</code> 和 <code>MKCoordinateSpan</code> 来配置地图显示的中心和区域缩放的大小。</p><h3 id="MKCoordinateRegion-和-MKCoordinateSpan"><a href="#MKCoordinateRegion-和-MKCoordinateSpan" class="headerlink" title="MKCoordinateRegion 和 MKCoordinateSpan"></a>MKCoordinateRegion 和 MKCoordinateSpan</h3><p>我们先来看看 <code>MKCoordinateRegion</code> 和 <code>MKCoordinateSpan</code> 的这两个初始化方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MKCoordinateRegion(center: CLLocationCoordinate2D, span: MKCoordinateSpan)</span><br><span class="line">MKCoordinateSpan(latitudeDelta: CLLocationDegrees, longitudeDelta: CLLocationDegrees)</span><br></pre></td></tr></table></figure><p>结合 <a href="https://developer.apple.com/documentation/mapkit/mkcoordinatespan" target="_blank" rel="noopener">文档</a> ，我们可以将 <code>MKCoordinateRegion</code> 理解为地图上一块方形区域， <code>center</code> 是这块方形区域的中心地理坐标，而 <code>MKCoordinateSpan</code> 是这块区域的 <strong>经纬度范围</strong>，那么它的两个参数的取值范围是：</p><ul><li>latitudeDelta：[0, 180]</li><li>longitudeDelta: [0, 360]</li></ul><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/zoomlevel/lnglatDelta.jpg" width = "450" height = "320" alt="" align=center /><h2 id="Tiled-web-map"><a href="#Tiled-web-map" class="headerlink" title="Tiled web map"></a>Tiled web map</h2><p>了解了 <code>MKCoordinateRegion</code> 和 <code>MKCoordinateSpan</code> 后，我们该如何利用它们来计算出 <code>zoomLevel</code> 呢？这里我们需要先了解一下 <a href="https://en.wikipedia.org/wiki/Tiled_web_map" target="_blank" rel="noopener">Tiled web map</a> 这个概念。<code>Tiled web map</code> 的设计初衷是为了能在网络上更好的传输和展示地图，其中最早应用起来的是 <code>Google Maps</code>， 然后慢慢地成为了地图工具中一个不成文的标准。它把地图以图片的形式切割成很多个小块: <code>Tile</code>，当用户在地图上滑动或者缩放时，就会加载更多的 <code>Tile</code>，对比以前直接加载一大块图片的方式效率更高，用户体验更好。</p><p>大部分的 <code>Tiled web map</code> 会依据 Google Maps 的一些实现标准：</p><ul><li>一个 <code>Tile</code> 是 256x256 像素。</li><li>zoom Level 为 0 时，整个世界地图可以显示在单个 <code>Tile</code> 上。</li><li>每增加一个地图缩放等级，一个 <code>Tile</code> 的像素会加倍。也就是说一个 <code>Tile</code> 会被四个 <code>Tile</code> 替换掉。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/zoomlevel/tileMap.jpg" alt=""></p><blockquote><p>上面原图片来自 <a href="http://troybrant.net/blog/2010/01/mkmapview-and-zoom-levels-a-visual-guide/" target="_blank" rel="noopener">troybrant.net</a>，由原图拼接而成。</p></blockquote><p>根据上面的标准，我们可以得出这样一个公式：</p><p>$W=256 \times 2^{zoomlevel}$</p><p>W 表示地图一边长的像素。</p><h2 id="zoomLevel-算法解析"><a href="#zoomLevel-算法解析" class="headerlink" title="zoomLevel 算法解析"></a>zoomLevel 算法解析</h2><p>我们知道地球经度一周360度，那么一个经度范围占 <code>Tiled web map</code> 的多少像素呢？简单的除法可以得知：</p><p>$\frac{360}{256 \times 2^{zoomlevel}}$</p><p>上面说到 <code>MKCoordinateSpan</code> 它表示地图显示区域的 <strong>经纬度范围</strong>，假设我们把 <code>MKMapView</code> 的宽度设置为 <code>width</code>, 而 <code>MKCoordinateSpan.longitudeDelta</code> 是当前 <code>MKMapView</code> 显示区域的<strong>经度</strong>范围。那么我们可以得到这样一个等式：</p><p>$\frac{360}{256 \times 2^{zoomlevel}} = \frac{longitudeDelta}{width}$</p><p>一个简单的转换，即可得出 <code>zoomLevel</code> 的计算公式：</p><p>$zoomLevel = log_2{\frac{360 \times width}{longitudeDelta \times 256}}$</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>用代码形式展示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mapWidth = mapView.frame.size.width</span><br><span class="line"><span class="keyword">let</span> zoomLevel = log2(<span class="number">360</span> * <span class="type">Double</span>(mapWidth) / <span class="number">256.0</span> / mapView.region.span.longitudeDelta)</span><br></pre></td></tr></table></figure><p>我们还可以给 <code>MKMapView</code> 扩展一下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MKMapView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> zoomLevel: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> log2(<span class="number">360</span> * <span class="type">Double</span>(frame.size.width) / <span class="number">256.0</span> / region.span.longitudeDelta)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://en.wikipedia.org/wiki/Tiled_web_map" target="_blank" rel="noopener">维基百科: Tiled web map</a></li><li><a href="https://blog.mapbox.com/512-map-tiles-cb5bfd6e72ba" target="_blank" rel="noopener">Mapbox Medium blog: 512 map tiles</a></li><li><a href="https://stackoverflow.com/questions/4189621/setting-the-zoom-level-for-a-mkmapview/15020534#15020534" target="_blank" rel="noopener">Stackoverflow: Setting the zoom level for a MKMapView</a></li><li><a href="http://troybrant.net/blog/2010/01/mkmapview-and-zoom-levels-a-visual-guide/" target="_blank" rel="noopener">troybrant blog: mkmapview and zoom levels a visual guide</a></li><li><a href="https://www.microimages.com/documentation/TechGuides/80TilesetZoom.pdf" target="_blank" rel="noopener">Microimages: Setting Zoom Levels</a></li></ul><details open><summary><strong>欢迎关注我的公众号</strong></summary><table><thead><tr><th align="center">HansonTalk</th><th align="center">iOSTypist</th></tr></thead><tbody><tr><td align="center"><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/qrcode/HansonTalk.jpg" alt="HansonTalk" align=center /></td><td align="center"><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/qrcode/iOSTypist.jpg" alt="iOSTypist" align=center /></td></tr></tbody></table></details>]]></content>
      
      
      <categories>
          
          <category> 算法实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算一个多边形的重心点坐标</title>
      <link href="/2019/05/05/%E8%AE%A1%E7%AE%97%E4%B8%80%E4%B8%AA%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E9%87%8D%E5%BF%83%E7%82%B9%E5%9D%90%E6%A0%87/"/>
      <url>/2019/05/05/%E8%AE%A1%E7%AE%97%E4%B8%80%E4%B8%AA%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E9%87%8D%E5%BF%83%E7%82%B9%E5%9D%90%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h2 id="背景介绍与问题分析"><a href="#背景介绍与问题分析" class="headerlink" title="背景介绍与问题分析"></a>背景介绍与问题分析</h2><p>在之前的《如何判断一个多边形是否合法》 一文中有提到，用无人机规划飞行路线前，往往需要框选一个多边形的区域。</p><p>而在地图控件上显示这个多边形区域时，往往会遇到这样一个需求：需要把所要测绘的多边形区域移动到地图中心。</p><p>实现这个需求的基本思路就是：获取到多边形区域的重心点坐标，然后利用地图控件的 <code>setCenter</code>方法，就可以把地图的显示中心移动到多边形区域重心了。那么问题来了，如何求出一个多边形的重心点坐标呢？</p><blockquote><p>这里所说的重心，也常常叫几何中心</p></blockquote><p>这里首先给出一个公式:</p><p>平面多边形 $X$ 可以被剖分为 n个有限的简单图形 $X_1,X_2,….X_n$，这些简单图形的重心点为 $C_1$，面积为 $A_1$，那么这个平面多边形的重心点坐标为 $(C_x,C_y)$<br>$$C_x = \frac{\sum C_{i_x} A_i}{\sum A_i}, C_y = \frac{\sum C_{i_y} A_i}{\sum A_i}$$</p><blockquote><p>公式参考: <a href="https://en.wikipedia.org/wiki/Centroid#Centroid_of_polygon" target="_blank" rel="noopener">维基百科</a></p></blockquote><p>一般来说我们可以给多边形进行三角剖分，而 $\sum{A_i}$ 即为多边形的总面积，那么这个公式可以理解为：</p><p>多边形重心横坐标 = 多边形剖分的每一个三角形重心的横坐标 * 该三角形的面积之和 / 多边形总面积</p><p>多边形重心纵坐标 = 多边形剖分的每一个三角形重心的纵坐标 * 该三角形的面积之和 / 多边形总面积</p><p>所以这里就把问题拆分成了三个小问题：</p><ul><li>求每个剖分出来的三角形的重心。</li><li>求每个剖分出来的三角形的面积。</li><li>求多边形的面积。</li></ul><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><h3 id="1-求三角形的重心"><a href="#1-求三角形的重心" class="headerlink" title="1. 求三角形的重心"></a>1. 求三角形的重心</h3><p><img src="https://user-gold-cdn.xitu.io/2019/4/30/16a6cfc2430378e5?w=495&h=359&f=png&s=6343" alt="三角形重心"><br>三角形的重心：三条中线的交点。其中重心到其中一个顶点的距离是重心到该顶点对边中点的距离的2倍。<br />即：GC = 2 * GP，也就是说重心坐标在 CP 线段上距离 AB 的中点 P 的 1/3 处。<br>假设 A,B,C 三点的坐标为：<br>$$A:(x_1,y_1),B:(x_2,y_2),C:(x_3,y_3)$$</p><p>那么通过简单坐标计算，可以得出其重心坐标为 $(x,y)$<br>$$x = \frac{(x_1+x_2+x_3)}{3} , y = \frac{(y_1+y_2+y_3)}{3}$$</p><h3 id="2-求三角形面积"><a href="#2-求三角形面积" class="headerlink" title="2. 求三角形面积"></a>2. 求三角形面积</h3><p>计算三角形的面积，我们这里利用 <code>向量积</code>来计算，我们知道平面中的两个向量的叉乘的模等于以这两个向量为边的平行四边形的面积，那么以这个两个向量为边的三角形，则是这个平行四边形的面积的一半。</p><blockquote><p>参考：<a href="https://zh.wikipedia.org/wiki/%E5%8F%89%E7%A7%AF" target="_blank" rel="noopener">向量叉积</a></p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/4/30/16a6cfc2411ec119?w=426&h=271&f=png&s=3768" alt=""></p><p>如上图，已知平面上两点 $A:(x_1,y_1),B(x_2,y_2)$ ，以 A，B和坐标原点 $P(0,0)$ 构成的三角形的面积 S 为：<br>$$S=\frac{\vec{PB}\times\vec{PA}}{2} = \frac{x_2y_1 - x_1y_2 }{2}$$</p><p>这里给出运算草稿：<br><img src="https://user-gold-cdn.xitu.io/2019/4/30/16a6cfc2446ff8cb?w=845&h=215&f=png&s=225564" alt=""></p><p>为什么这里我们会以原点作为第三个点构成三角形呢？其实是跟接下来求多边形面积是有关联的。</p><h3 id="3-求多边形的面积"><a href="#3-求多边形的面积" class="headerlink" title="3. 求多边形的面积"></a>3. 求多边形的面积</h3><p>我们在上面给出的求平面多边形重心的公式中有说到，一般我们会把多边形剖分为多个三角形。<br>那么这个剖分点 P 我们可以设在哪里呢？这里先给出结论：这个剖分点可以设置在多边形的内部，也可以设置到外部。</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/30/16a6cfc2424f444d?w=493&h=243&f=png&s=7753" alt=""></p><p>为什么这个剖分点可以设置到外部呢？我们可以通过简单的三角形情况来推广到多边形的情况。<br>对于三角形ABC，我们把剖分点设置在其外部 P 的一点上<br><img src="https://user-gold-cdn.xitu.io/2019/4/30/16a6cfc24423917c?w=381&h=260&f=png&s=5277" alt=""></p><p>如果大家还记得 <a href="https://juejin.im/post/5cc7eea351882512fa03a481" target="_blank" rel="noopener">《如何判断一个多边形是否合法》</a> 一文中有讲过向量叉积是有正负之分的，并且根据上面所说的计算三角形面积，那么以 P 为剖分点，通过向量积可以得出这个三角形的面积 A 为：<br>$$A = \frac{1}{2}(\vec{PB} \times \vec{PC} + \vec{PC} \times \vec{PA} + \vec{PA} \times \vec{PB})$$</p><p>因为 向量PB 在 向量PA 的顺时针方向，所以 $\vec{PA} \times \vec{PB}$ 的结果是负数的。那么上面的面积计算公式其实就可以理解为：</p><p>三角形ABC的面积 = 三角形PBC面积 + 三角形PCA面积 - 三角形PAB面积</p><p>假设这四个点的坐标为：$P(x_0,y_0), A(x_1,y_1), B(x_2,y_2), C(x_3,y_3)$，通过上面的公式进行计算，具体的演算过程我就不给出了，这里直接给出计算结果：<br>$$A = x_1y_2-x_2y_1+x_2y_3-x_3y_2+x_3y_1-x_1y_3$$</p><p>我们可以发现，计算结果中没有 $x_0,y_0$ 的项，因为它们在计算过程中给消去了，数学就是这么奇妙！所以我们可以得出一个结论，多边形的面积结果与这个剖分点的位置是无关的。那么为了计算方便，我们当然选择把这个 P 点设置到原点上啦。</p><p>那么只要我们知道多边形的每一个顶点，通过原点进行剖分成多个三角形，然后通过向量的叉乘求出每个三角的面积，最后相加，就可以求出多边形的面积了。</p><h2 id="示例代码及解析"><a href="#示例代码及解析" class="headerlink" title="示例代码及解析"></a>示例代码及解析</h2><p>好了，说到这里，我们已经找到所有满足最开始的计算多边形重心点坐标的所有计算元素了。是时候上代码了，这里构建一个函数<code>calculatePolygonGravityCenter(coordinates: [CLLocationCoordinate2D])</code>，这个函数传入的参数是多边形在地图上的坐标点数组。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculatePolygonGravityCenter</span><span class="params">(coordinates: [CLLocationCoordinate2D])</span></span> -&gt; <span class="type">CLLocationCoordinate2D</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> area = <span class="number">0.0</span> <span class="comment">// 多边形面积</span></span><br><span class="line">    <span class="keyword">var</span> gravityLat = <span class="number">0.0</span> <span class="comment">// 重心点 latitude</span></span><br><span class="line">    <span class="keyword">var</span> gravityLng = <span class="number">0.0</span> <span class="comment">// 重心点 longitude</span></span><br><span class="line">    <span class="keyword">for</span> (index, coordinate) <span class="keyword">in</span> coordinates.enumerated() &#123;</span><br><span class="line">          <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">let</span> lat = coordinate.latitude</span><br><span class="line">        <span class="keyword">let</span> lng = coordinate.longitude</span><br><span class="line">        <span class="keyword">let</span> nextLat = coordinates[(index + <span class="number">1</span>) % coordinates.<span class="built_in">count</span>].latitude</span><br><span class="line">        <span class="keyword">let</span> nextLng = coordinates[(index + <span class="number">1</span>) % coordinates.<span class="built_in">count</span>].longitude</span><br><span class="line">          <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">let</span> tempArea = (nextLat * lng - nextLng * lat) / <span class="number">2.0</span></span><br><span class="line">          <span class="comment">// 3</span></span><br><span class="line">        area += tempArea</span><br><span class="line">          <span class="comment">// 4</span></span><br><span class="line">        gravityLat += tempArea * (lat + nextLat) / <span class="number">3</span></span><br><span class="line">        gravityLng += tempArea * (lng + nextLng) / <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 5</span></span><br><span class="line">    gravityLat = gravityLat / area</span><br><span class="line">    gravityLng = gravityLng / area</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">CLLocationCoordinate2D</span>(latitude: gravityLat, longitude: gravityLng)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应上面代码的注释：</p><ol><li>拿到多边形上连续两个点的坐标，我们可以把 latitude 看做横坐标，longitude 是纵坐标。</li><li>利用向量叉乘计算这两个点与原点组成的三角形的面积。</li><li>所有面积之和得出多边形的面积，就是求公式 $C_x = \frac{\sum C_{i_x} A_i}{\sum A_i}$ 中的 $\sum A_i$。</li><li><code>(lat + nextLat) / 3</code> 是以这两个点和原点组成的三角形的重心横坐标，这样的累加<code>gravityLat += tempArea * (lat + nextLat) / 3</code> 其实是求公式 $C_x = \frac{\sum C_{i_x} A_i}{\sum A_i}$ 中的 $\sum C_{i_x} A_i$ 的值。</li><li>到这一步就简单了，直接套用公式 $C_x = \frac{\sum C_{i_x} A_i}{\sum A_i}$。</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://en.wikipedia.org/wiki/Centroid#Centroid_of_polygon" target="_blank" rel="noopener">维基百科-Centroid</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%8F%89%E7%A7%AF" target="_blank" rel="noopener">维基百科-叉积</a></li><li><a href="http://www.cnblogs.com/xiexinxinlove/p/3708147.html" target="_blank" rel="noopener">cnblogs-用向量积（叉积）计算三角形的面积和多边形面积</a></li><li><a href="https://www.zhihu.com/question/22902370" target="_blank" rel="noopener">知乎-两个向量的叉乘为什么是面积</a></li><li><a href="https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CFJD&dbname=CJFDLAST2018&filename=SXTB200210014&v=MDk4NThSOGVYMUx1eFlTN0RoMVQzcVRyV00xRnJDVVJMT2ZZK1Z2RmlIblZydk9OalhmYkxHNEh0UE5yNDlFWUk=" target="_blank" rel="noopener">中国知网-任意多边形匀面重心的计算方法</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何判断一个多边形是否合法</title>
      <link href="/2019/02/17/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95/"/>
      <url>/2019/02/17/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>利用无人机对一片区域进行测绘前，我们会先在地图上框选一个区域，然后再规划飞行的路线，而需要测绘的这片区域往往是一个多边形。这就涉及判断多边形是否合法的问题。</p><p>首先我们要确定一个标准：<strong>怎么样才算一个不合法的多边形</strong> ？我们可以简单地通过下面这幅图来解释一下：<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/judgePolygonValid/polygonDesc.png" alt=""></p><a id="more"></a><p>我们可以看出前面两个分别是凹多边形和凸多边形，而最后一张则是我们所说的不合法多边形，可以看出这个不合法的多边形的特征就是：<strong>它存在某条边与另外一条边相交的情况</strong> 。</p><p>那么要判断一个多边形是否合法，我们只要判断组成多边形的所有线段是否存在相交的情况即可，当然，我们这里所说的相交是 <strong>规范相交</strong> ，即 <strong>交点不在线段的端点上</strong> 。</p><p>好了，那么现在的问题可以简化成：<strong>如何判断两条线段是否规范相交</strong> 。</p><p>这里我们需要借助 <strong>向量的叉积</strong> 来进行判断。</p><blockquote><p>叉积，又称向量积，是对三维空间中的两个向量的二元运算。</p></blockquote><p>这里推荐 3Blue1Brown 的 <a href="https://www.bilibili.com/video/av6731067/?p=11" target="_blank" rel="noopener">视频</a> 来快速回顾一下叉积的概念(下面的两幅截图来自此视频)。我们只需知道叉积的结果是有正负的，比如我们以向量 $\vec{v}$ 为标准，如下图，向量  $\vec{w}$  在  $\vec{v}$ 的 <strong>顺时针方向</strong>，那么   $\vec{v} \times \vec{w} &lt; 0$ ：</p><p><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/judgePolygonValid/vetorvw.png" alt=""><br>$$\vec{v} \times \vec{w} &lt; 0$$</p><p>如果向量 $\vec{w}$  在  $\vec{v}$ 的 <strong>逆时针方向</strong>，那么 $\vec{v} \times \vec{w} &gt; 0$ ：</p><p><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/judgePolygonValid/vetorwv.png" alt=""><br>$$\vec{v} \times \vec{w} &gt; 0$$</p><p>那么我们如何利用叉积的特性运用到判断线段是否相交上呢？</p><p>我们先看下面最直接的一个线段相交的情况：<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/judgePolygonValid/line1.png" alt=""></p><p>线段 $P_1P_2$ 和 线段 $Q_1Q_2$ 明显存在一个交点，从上面这张图我们可以做一个简单的结论：<strong>如果一条的线段的两个端点在另外一条线段两侧，那么这两条线段可能相交</strong>，注意这里说的是可能相交，稍后会讲到另外一种情况。</p><p>我们可以将上面的图转换为向量的情况来看：<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/judgePolygonValid/line2.png" alt=""></p><p>是不是觉得似曾相识，这跟上面提到的叉积的情况是不是很类似？<br>向量  $\vec{P_1Q_1}$  在  $\vec{P_1P_2}$ 的逆时针方向，那么：$\vec{P_1P_2} \times \vec{P_1Q_1} &gt; 0$<br>向量  $\vec{P_1Q_2}$  在  $\vec{P_1P_2}$ 的顺时针方向，那么：$\vec{P_1P_2} \times \vec{P_1Q_2} &lt; 0$</p><p>用 A 表示 $\vec{P_1P_2} \times \vec{P_1Q_1} $ 的叉积结果，用 B 表示 $\vec{P_1P_2} \times \vec{P_1Q_2}$ 的叉积结果，那么 <strong>一条的线段的两个端点在另外一条线段两侧</strong> 这个几何现象可以用这个公式表示 ：A*B &lt; 0</p><p>我们前面提到 <strong>如果一条的线段的两个端点在另外一条线段两侧，那么这两条线段可能相交</strong> ，为什么是可能相交呢？如果我们将 线段 $Q_1Q_2$ 往右边移动一下，会存在下面这种情况：<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/judgePolygonValid/line3.png" alt=""><br>从上图可以看出，线段 $Q_1Q_2$ 的两个端点在线段 $P_1P_2$  两侧，但是它们并没有相交。</p><p>那么如何排除这种情况呢？其实很简单，我们之前都是以线段 $P_1P_2$ 作为主视角，如果将主视角换成线段 $Q_1Q_2$，那么我们很容易看出 线段 $P_1P_2$ 的两个端点并没有在 线段 $Q_1Q_2$ 的两侧。所以我们再次看回上面相交的那幅图，为了能够充分的判断两条线段相交，这次以 $Q_1Q_2$ 为主视角看待这个问题，求叉积：<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/judgePolygonValid/line4.png" alt=""><br>向量  $\vec{Q_1P_2}$  在  $\vec{Q_1Q_2}$ 的逆时针方向，那么：$\vec{Q_1Q_2} \times \vec{Q_1P_2} &gt; 0$<br>向量  $\vec{Q_1P_1}$  在  $\vec{Q_1Q_2}$ 的顺时针方向，那么：$\vec{Q_1Q_2} \times \vec{Q_1P_1} &lt; 0$</p><p>综上，我们可以得出：<br>A =  $\vec{P_1P_2} \times \vec{P_1Q_1} $<br>B = $\vec{P_1P_2} \times \vec{P_1Q_2} $<br>C = $\vec{Q_1Q_2} \times \vec{Q_1P_1} $<br>D = $\vec{Q_1Q_2} \times \vec{Q_1P_2} $<br>当 A * B &lt; 0 &amp;&amp; C * D &lt; 0 的时候，两条线段规范相交。<br>至于向量的叉积如何运算，这里就不细写了，给出一张计算草稿给大家过目一下：<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/judgePolygonValid/calcraft.png" alt=""><br>根据计算草稿的内容，我们就很容易通过代码来实现了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private func isIntersect(line1: (CGPoint, CGPoint), line2: (CGPoint, CGPoint)) -&gt; Bool &#123;</span><br><span class="line">        let p1 &#x3D; line1.0</span><br><span class="line">        let p2 &#x3D; line1.1</span><br><span class="line">        let q1 &#x3D; line2.0</span><br><span class="line">        let q2 &#x3D; line2.1</span><br><span class="line"></span><br><span class="line">        let a1 &#x3D; (p2.x - p1.x) * (q1.y - p1.y) - (q1.x - p1.x) * (p2.y - p1.y)</span><br><span class="line">        let a2 &#x3D; (p2.x - p1.x) * (q2.y - p1.y) - (q2.x - p1.x) * (p2.y - p1.y)</span><br><span class="line">        </span><br><span class="line">        let b1 &#x3D; (q2.x - q1.x) * (p1.y - q1.y) - (p1.x - q1.x) * (q2.y - q1.y)</span><br><span class="line">        let b2 &#x3D; (q2.x - q1.x) * (p2.y - q1.y) - (p2.x - q1.x) * (q2.y - q1.y)</span><br><span class="line">        </span><br><span class="line">        if a1 * a2 &lt; 0 &amp;&amp; b1 * b2 &lt; 0 &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于笔者能力有限，文中如有错误还请各位读者不吝赐教。</p><br><br><details open><summary><strong>欢迎关注我的公众号</strong></summary><table><thead><tr><th align="center">HansonTalk</th><th align="center">iOSTypist</th></tr></thead><tbody><tr><td align="center"><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/qrcode/HansonTalk.jpg" alt="HansonTalk" align=center /></td><td align="center"><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/qrcode/iOSTypist.jpg" alt="iOSTypist" align=center /></td></tr></tbody></table></details>]]></content>
      
      
      <categories>
          
          <category> 算法实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift的泛型小总结</title>
      <link href="/2018/08/05/Swift%E7%9A%84%E6%B3%9B%E5%9E%8B%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/05/Swift%E7%9A%84%E6%B3%9B%E5%9E%8B%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><strong>本文针对网上一些关于泛型的知识点进行汇总和总结，已在文中标记出参考文章的链接</strong></p><blockquote><p>泛型是程序设计语言的一种特性。允许程序员在强类型程序设计语言中编写代码时定义一些可变部分，那些部分在使用前必须作出指明。</p></blockquote><a id="more"></a><p><code>Objective-C</code> 缺乏一个重要特性:不支持泛型。幸运地是，<code>Swift</code>拥有这一特性。==泛型允许你声明的函数、类以及结构体支持不同的数据类型==。</p><p>泛型代码可以让你写出根据自我需求定义、适用于任何类型的，灵活且可重用的函数和类型。它的可以让你避免重复的代码，用一种清晰和抽象的方式来表达代码的意图。</p><p>泛型是 Swift 强大特征中的其中一个，许多 Swift 标准库是通过泛型代码构建出来的。事实上，泛型的使用贯穿了整本语言手册，只是你没有发现而已。 <span style="border-bottom:2px solid brown;">例如，Swift 的数组和字典类型都是泛型集。你可以创建一个Int数组，也可创建一个String数组，或者甚至于可以是任何其他 Swift 的类型数据数组。同样的，你也可以创建存储任何指定类型的字典（dictionary），而且这些类型可以是没有限制的。</span></p><blockquote><p><a href="https://swift.gg/2015/09/16/swift-generics/" target="_blank" rel="noopener">参考</a></p></blockquote><h2 id="实现栈的例子，说明泛型的作用"><a href="#实现栈的例子，说明泛型的作用" class="headerlink" title="实现栈的例子，说明泛型的作用"></a>实现栈的例子，说明泛型的作用</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntStack</span></span>&#123;</span><br><span class="line">  <span class="comment">// 采用数组作为容器保存数据 类型为Int</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> stackItems:[<span class="type">Int</span>] = []</span><br><span class="line">  <span class="comment">// 入栈操作 即Push 添加最新数据到容器最顶部</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">pushItem</span><span class="params">(item:Int)</span></span>&#123;</span><br><span class="line">    stackItems.append(item)    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 出栈操作 即Pop 将容器最顶部数据移除</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">popItem</span><span class="params">()</span></span>-&gt;<span class="type">Int?</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastItem = stackItems.last</span><br><span class="line">    stackItems.removeLast()</span><br><span class="line">    <span class="keyword">return</span> lastItem</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这栈能够处理<code>Int</code>类型数据。但是如果要一个能够处理<code>String</code>类型的栈呢？我们需要替换所有<code>Int</code>为<code>String</code>，不过这显然是一个糟糕的解决方法。此外另外一种方法是用<code>AnyObject</code>，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class AnyObjectStack&#123;</span><br><span class="line">  &#x2F;&#x2F; 采用数组作为容器保存数据 类型为AnyObject</span><br><span class="line">  private var stackItems:[AnyObject] &#x3D; []</span><br><span class="line">  </span><br><span class="line">  func pushItem(item:AnyObject)&#123;</span><br><span class="line">    stackItems.append(item)    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  func popItem()-&gt;AnyObject?&#123;</span><br><span class="line">    let lastItem &#x3D; stackItems.last</span><br><span class="line">    stackItems.removeLast()</span><br><span class="line">    return lastItem</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这种情况下我们就失去了数据类型的安全，并且每当我们对栈进行操作时,都需要进行一系列繁琐的类型转换(casting操作,使用as来进行类型转换)</p><ul><li>通过泛型来解决：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Stack&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">  private var stackItems: [T] &#x3D; []  </span><br><span class="line"></span><br><span class="line">  func pushItem(item:T) &#123;</span><br><span class="line">    stackItems.append(item)</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  func popItem() -&gt; T? &#123;</span><br><span class="line">    let lastItem &#x3D; stackItems.last</span><br><span class="line">    stackItems.removeLast()</span><br><span class="line">    return lastItem</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型定义方式:由一对尖括号(&lt;&gt;)包裹，命名方式通常为大写字母开头(这里我们命名为T)。在初始化阶段，我们通过明确的类型(这里为Int)来定义参数,之后编译器将所有的泛型T替换成Int类型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 指定了泛型T 就是 Int </span><br><span class="line">&#x2F;&#x2F; 编译器会替换所有T为Int</span><br><span class="line">let aStack &#x3D; Stack&lt;Int&gt;()</span><br><span class="line"></span><br><span class="line">aStack.pushItem(10)</span><br><span class="line">if let lastItem &#x3D; aStack.popItem() &#123;</span><br><span class="line">  print(&quot;last item: \(lastItem)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型扩展"><a href="#泛型扩展" class="headerlink" title="泛型扩展"></a>泛型扩展</h2><blockquote><p><a href="http://swifter.tips/extension-generic/" target="_blank" rel="noopener">参考</a></p></blockquote><p>Swift 对于泛型的支持使得我们可以避免为类似的功能多次书写重复的代码，这是一种很好的简化。而对于泛型类型，我们也可以使用 extension 为泛型类型添加新的方法。</p><p>与为普通的类型添加扩展不同的是，<span style="border-bottom: 2px solid brown">泛型类型在类型定义时就引入了类型标志，我们可以直接使用</span>。例如 Swift 的 Array 类型的定义是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public struct Array&lt;Element&gt; : CollectionType, Indexable, ... &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个定义中，已经声明了 <code>Element</code> 为泛型类型。在为类似这样的泛型类型写扩展的时候，我们不需要在 extension 关键字后的声明中重复地去写 <code>&lt;Element&gt;</code> 这样的泛型类型名字 (其实编译器也不允许我们这么做)，在扩展中可以使用和原来所定义一样的符号即可指代类型本体声明的泛型。比如我们想在扩展中实现一个 random 方法来随机地取出 Array 中的一个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extension Array &#123;</span><br><span class="line">    var random: Element? &#123;</span><br><span class="line">        return self.count !&#x3D; 0 ?</span><br><span class="line">          self[Int.random(in: 0..&lt;self.count)] : nil</span><br><span class="line">        &#x2F;&#x2F; self[Int(arc4random_uniform(UInt32(self.count)))]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let languages &#x3D; [&quot;Swift&quot;,&quot;ObjC&quot;,&quot;C++&quot;,&quot;Java&quot;]</span><br><span class="line">languages.random!</span><br><span class="line">&#x2F;&#x2F; 随机输出是这四个字符串中的某个</span><br><span class="line"></span><br><span class="line">let ranks &#x3D; [1,2,3,4]</span><br><span class="line">ranks.random!</span><br><span class="line">&#x2F;&#x2F; 随机输出是这四个数字中的某个</span><br></pre></td></tr></table></figure><p><span style="border-bottom: 2px solid brown">在扩展中是不能添加整个类型可用的新泛型符号的，但是对于某个特定的方法来说，我们可以添加 T 以外的其他泛型符号</span>。比如在刚才的扩展中加上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func appendRandomDescription</span><br><span class="line">    &lt;U: CustomStringConvertible&gt;(input: U) -&gt; String &#123;</span><br><span class="line"></span><br><span class="line">        if let element &#x3D; self.random &#123;</span><br><span class="line">            return &quot;\(element) &quot; + input.description</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &quot;empty array&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们限定了只接受实现了 <code>CustomStringConvertible</code> 的参数作为参数，然后将这个内容附加到自身的某个随机元素的描述上。因为参数 input 实现了 <code>CustomStringConvertible</code>，所以在方法中我们可以使用 description 来获取描述字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let languages &#x3D; [&quot;Swift&quot;,&quot;ObjC&quot;,&quot;C++&quot;,&quot;Java&quot;]</span><br><span class="line">languages.random!</span><br><span class="line"></span><br><span class="line">let ranks &#x3D; [1,2,3,4]</span><br><span class="line">ranks.random!</span><br><span class="line"></span><br><span class="line">languages.appendRandomDescription(ranks.random!)</span><br><span class="line">&#x2F;&#x2F; 随机组合 languages 和 ranks 中的各一个元素，然后输出</span><br></pre></td></tr></table></figure><p>虽然这是个生造的需求，但是能说明泛型在扩展里的使用方式。简单说就是我们++不能通过扩展来重新定义当前已有的泛型符号，但是可以对其进行使用；在扩展中也不能为这个类型添加泛型符号；但只要名字不冲突，我们是可以在新声明的方法中定义和使用新的泛型符号的++。</p><h2 id="typealias-和-泛型"><a href="#typealias-和-泛型" class="headerlink" title="typealias 和 泛型"></a>typealias 和 泛型</h2><h3 id="typealias-作用"><a href="#typealias-作用" class="headerlink" title="typealias 作用"></a>typealias 作用</h3><blockquote><p><a href="http://swifter.tips/typealias/" target="_blank" rel="noopener">参考</a></p></blockquote><p>typealias 是用来为已经存在的类型重新定义名字的，通过命名，可以使代码变得更加清晰。使用的语法也很简单，使用 typealias 关键字像使用普通的赋值语句一样，可以将某个已经存在的类型赋值为新的名字。比如在计算二维平面上的距离和位置的时候，我们一般使用 Double 来表示距离，用 CGPoint 来表示位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func distanceBetweenPoint(point: CGPoint, toPoint: CGPoint) -&gt; Double &#123;</span><br><span class="line">    let dx &#x3D; Double(toPoint.x - point.x)</span><br><span class="line">    let dy &#x3D; Double(toPoint.y - point.y)</span><br><span class="line">    return sqrt(dx * dx + dy * dy)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let origin: CGPoint &#x3D; CGPoint(x: 0, y: 0)</span><br><span class="line">let point: CGPoint &#x3D; CGPoint(x: 1, y: 1)</span><br><span class="line"></span><br><span class="line">let distance: Double &#x3D;  distanceBetweenPoint(origin, point)</span><br></pre></td></tr></table></figure><p>虽然在数学上和最后的程序运行上都没什么问题，但是阅读和维护的时候总是觉得有哪里不对。因为我们没有将数学抽象和实际问题结合起来，使得在阅读代码时我们还需要在大脑中进行一次额外的转换：CGPoint 代表一个点，而这个点就是我们在定义的坐标系里的位置；Double 是一个数字，它代表两个点之间的距离。</p><p>如果我们使用 typealias，就可以将这种转换直接写在代码里，从而减轻阅读和维护的负担：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">typealias Location &#x3D; CGPoint</span><br><span class="line">typealias Distance &#x3D; Double</span><br><span class="line"></span><br><span class="line">func distanceBetweenPoint(location: Location,</span><br><span class="line">    toLocation: Location) -&gt; Distance &#123;</span><br><span class="line">        let dx &#x3D; Distance(location.x - toLocation.x)</span><br><span class="line">        let dy &#x3D; Distance(location.y - toLocation.y)</span><br><span class="line">        return sqrt(dx * dx + dy * dy)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let origin: Location &#x3D; Location(x: 0, y: 0)</span><br><span class="line">let point: Location &#x3D; Location(x: 1, y: 1)</span><br><span class="line"></span><br><span class="line">let distance: Distance &#x3D;  distanceBetweenPoint(origin, toLocation: point)</span><br></pre></td></tr></table></figure><p>同样的代码，在 typealias 的帮助下，读起来就轻松多了。</p><h3 id="用-typealias-给泛型重命名"><a href="#用-typealias-给泛型重命名" class="headerlink" title="用 typealias 给泛型重命名"></a>用 typealias 给泛型重命名</h3><p>泛型类型的确定性得到保证后，才可以重命名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Person&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">typealias WorkId &#x3D; String</span><br><span class="line">typealias Worker &#x3D; Person&lt;WorkId&gt;</span><br></pre></td></tr></table></figure><h2 id="在协议中使用-associatedtype"><a href="#在协议中使用-associatedtype" class="headerlink" title="在协议中使用 associatedtype"></a>在协议中使用 associatedtype</h2><blockquote><p><a href="https://numbbbbb.gitbooks.io/-the-swift-programming-language-/content/chapter2/22_Generics.html" target="_blank" rel="noopener">参考</a></p></blockquote><p>定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分将会非常有用。关联类型为协议中的某个类型提供了一个占位名（或者说别名），其代表的实际类型在协议被采纳时才会被指定。你可以通过 associatedtype 关键字来指定关联类型。</p><p>新建一个Container协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protocol Container &#123;</span><br><span class="line">    associatedtype Item</span><br><span class="line">    mutating func append(_ item: Item)</span><br><span class="line">    var count: Int &#123; get &#125;</span><br><span class="line">    subscript(i: Int) -&gt; Item &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以给协议里的关联类型添加类型注释，让遵守协议的类型必须遵循这个约束条件。例如，下面的代码定义了一个 Item 必须遵循 Equatable 的 Container 类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protocol Container &#123;</span><br><span class="line">    associatedtype Item: Equatable</span><br><span class="line">    mutating func append(_ item: Item)</span><br><span class="line">    var count: Int &#123; get &#125;</span><br><span class="line">    subscript(i: Int) -&gt; Item &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成遵循Container协议的泛型Stack:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct Stack&lt;T&gt;: Container &#123;</span><br><span class="line">    &#x2F;&#x2F; original Stack&lt;T&gt; implementation</span><br><span class="line">    var items &#x3D; [T]()</span><br><span class="line">    mutating func push(_ item: T) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    mutating func pop() -&gt; T &#123;</span><br><span class="line">        return items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 遵循Container协议的实现</span><br><span class="line">    mutating func append(_ item: T) &#123;</span><br><span class="line">        self.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    var count: Int &#123;</span><br><span class="line">        return items.count</span><br><span class="line">    &#125;</span><br><span class="line">    subscript(i: Int) -&gt; T &#123;</span><br><span class="line">        return items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h2><blockquote><p><a href="https://numbbbbb.gitbooks.io/-the-swift-programming-language-/content/chapter2/22_Generics.html" target="_blank" rel="noopener">参考</a></p></blockquote><h3 id="实现Equtable协议-使得泛型可以比较"><a href="#实现Equtable协议-使得泛型可以比较" class="headerlink" title="实现Equtable协议,使得泛型可以比较"></a>实现Equtable协议,使得泛型可以比较</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Stack&lt;T:Equatable&gt; &#123;</span><br><span class="line"></span><br><span class="line">  private var stackItems: [T] &#x3D; []</span><br><span class="line"></span><br><span class="line">  func pushItem(item:T) &#123;</span><br><span class="line">    .append(item)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  func popItem() -&gt; T? &#123;</span><br><span class="line">    let lastItem &#x3D; stackItems.last</span><br><span class="line">    stackItems.removeLast()</span><br><span class="line">    return lastItem</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  func isItemInStack(item:T) -&gt; Bool &#123;</span><br><span class="line">    var found &#x3D; false</span><br><span class="line">    for stackItem in stackItems &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果没有 &lt;T:Equatable&gt; 这里会报错</span><br><span class="line">      if stackItem &#x3D;&#x3D; item &#123;</span><br><span class="line">        ound &#x3D; true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return found</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Where-语句"><a href="#Where-语句" class="headerlink" title="Where 语句"></a>Where 语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func allItemsMatch&lt;</span><br><span class="line">    C1: Container, C2: Container</span><br><span class="line">    where C1.ItemType &#x3D;&#x3D; C2.ItemType, C1.ItemType: Equatable&gt;</span><br><span class="line">    (someContainer: C1, anotherContainer: C2) -&gt; Bool &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 检查两个Container的元素个数是否相同</span><br><span class="line">        if someContainer.count !&#x3D; anotherContainer.count &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 检查两个Container相应位置的元素彼此是否相等</span><br><span class="line">        for i in 0..&lt;someContainer.count &#123;</span><br><span class="line">            if someContainer[i] !&#x3D; anotherContainer[i] &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果所有元素检查都相同则返回true</span><br><span class="line">        return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在Swift扩展里添加&quot;存储属性&quot;</title>
      <link href="/2018/07/17/%E5%9C%A8Swift%E6%89%A9%E5%B1%95%E9%87%8C%E6%B7%BB%E5%8A%A0%22%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7%22/"/>
      <url>/2018/07/17/%E5%9C%A8Swift%E6%89%A9%E5%B1%95%E9%87%8C%E6%B7%BB%E5%8A%A0%22%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7%22/</url>
      
        <content type="html"><![CDATA[<p>能在 Swift 扩展里添加”存储属性”吗？</p><a id="more"></a><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>最近 <a href="https://itunes.apple.com/cn/app/imagegotcha/id1384107130?mt=8" target="_blank" rel="noopener">ImageGotcha</a> 收到了第一封用户反馈的邮件。<br><img src="" alt=""><br>这个用户希望可以有 <code>Dark Mode</code>。<code>ImageGotcha</code> 只是一个工具类 <code>App</code> ，好像也没有什么必要加上这个黑夜模式，不过我还是去想了想如何给应用加上黑夜模式，或者说加上一个换肤的功能。</p><p>基本的思路就是 <code>post</code> 一个自定义的 <code>NSNotification</code>，然后在需要修改颜色的地方监听这个通知然后进行修改。<br>按照惯例，我还是去 <code>Github</code> 上搜搜，看看别人是怎么做的。然后发现一部分人的做法是给现有的 <code>UIKit</code> 控件添加扩展属性，然后可以在定义这些控件的时候指定不同模式下的颜色，这的确是一种好方法。那么是如何在 <code>Swift</code> 的 <code>Extension 扩展</code> 里添加所谓的<code>&quot;存储属性&quot;</code>呢？</p><p>我们都知道，在 <code>Swift</code> 的 <code>Extension</code> 里是不能添加<code>存储属性</code>的，这里可以类比 <code>Objective-C</code>的 <code>Category 分类</code>，分类是不能添加实例变量和属性的。</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>这里就有个问题了，为什么不能添加呢？</p><blockquote><p>因为不管是 <code>Swift</code> 的 <code>Extension</code> 还是 <code>Objective-C</code> 的 <code>Category</code> 都不能改变原有的类或者结构体的内存结构，在实例化这些类的时候，内存结构是确定的，而添加属性或者实例变量需要内存空间，会改变原有的内存结构。</p></blockquote><h2 id="利用关联对象"><a href="#利用关联对象" class="headerlink" title="利用关联对象"></a>利用关联对象</h2><p>在 <code>Objective-C</code> 中我们常常用运行时 <code>Associated Object 关联对象</code> 来给 <code>Category</code> 添加属性，而在 <code>Swift</code> 里，我们同样可以利用关联对象在 <code>Extension</code> 中添加计算属性，以达到所谓的<code>存储属性</code>的效果。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AssociatedKeys</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> testNameKey: <span class="type">String</span> = <span class="string">"testNameKey"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> testName: <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">AssociatedKeys</span>.testNameKey) <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">AssociatedKeys</span>.testNameKey, newValue, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&amp;AssociatedKeys.testNameKey</code>: <code>&amp;</code> 操作符是取出地址作为 <code>UnsafeRawPointer</code> 参数传入。<br><code>.OBJC_ASSOCIATION_RETAIN_NONATOMIC</code>: 是一个 <code>objc_AssociationPolicy</code> 枚举，它有以下几种选择(从字面意思可以猜测是与Objective-C中的属性修饰符相关)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public enum objc_AssociationPolicy : UInt &#123;</span><br><span class="line">    case OBJC_ASSOCIATION_ASSIGN</span><br><span class="line">    case OBJC_ASSOCIATION_RETAIN_NONATOMIC</span><br><span class="line">    case OBJC_ASSOCIATION_COPY_NONATOMIC</span><br><span class="line">    case OBJC_ASSOCIATION_RETAIN</span><br><span class="line">    case OBJC_ASSOCIATION_COPY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var testString &#x3D; &quot;test&quot;</span><br><span class="line"></span><br><span class="line">let view &#x3D; UIView()</span><br><span class="line"></span><br><span class="line">view.testName &#x3D; testString</span><br><span class="line">print(view.testName) &#x2F;&#x2F; 输出 Optional(&quot;test&quot;)</span><br><span class="line"></span><br><span class="line">testString.append(&quot;change&quot;)</span><br><span class="line">print(view.testName) &#x2F;&#x2F; 输出 Optional(&quot;test&quot;)</span><br><span class="line"></span><br><span class="line">view.testName &#x3D; &quot;testChange&quot;</span><br><span class="line">print(view.testName) &#x2F;&#x2F; 输出 Optional(&quot;testChange&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>上架个小工具-ImageGotcha</title>
      <link href="/2018/05/18/%E4%B8%8A%E6%9E%B6%E4%B8%AA%E5%B0%8F%E5%B7%A5%E5%85%B7-ImageGotcha/"/>
      <url>/2018/05/18/%E4%B8%8A%E6%9E%B6%E4%B8%AA%E5%B0%8F%E5%B7%A5%E5%85%B7-ImageGotcha/</url>
      
        <content type="html"><![CDATA[<p>上架了个小工具。<a href="https://itunes.apple.com/cn/app/imagegotcha/id1384107130?mt=8&at=1000lMM4" target="_blank" rel="noopener">ImageGotcha</a> 是一个 <code>Safari</code> 的 <code>Action Extension</code>，它可以提取当前网页的图片方便查看和批量保存，比如可以去某些 <code>Instagram</code> 用户的主页批量下载图片，或者下载 <code>Bing</code> 的每日背景图等等。点击 <a href="https://itunes.apple.com/cn/app/imagegotcha/id1384107130?mt=8&at=1000lMM4" target="_blank" rel="noopener">这里</a> 到 <code>AppStore</code> 查看。</p><a id="more"></a><p><img src="https://camo.githubusercontent.com/f473966292ac4b1b3f3f07960e8e9383a4a3bf65/68747470733a2f2f6d6d62697a2e717069632e636e2f6d6d62697a5f6a70672f72346266653378374e3471557141566c666a4e593156685669615546614145363161334a687868543536696357544545685866376175324369633243743762746636706269627a326e53455458737858724e696344696351674f6f512f3634303f77785f666d743d6a7065672674703d7765627026777866726f6d3d352677785f6c617a793d31" alt=""></p><p><code>ImageGotcha</code> 也做了国际化，支持英文、简体中文、繁体中文、日语以及韩语。要想使用<code>ImageGotcha</code>，需先在 <code>Safari</code> 开启这个<code>Extension</code>，<code>App</code> 内有操作指导，如下图是各种语言的指导说明：</p><p><img src="https://camo.githubusercontent.com/f9878ecb46ab65ce8d6c74671ef02f18623408d4/68747470733a2f2f6d6d62697a2e717069632e636e2f6d6d62697a5f706e672f72346266653378374e3471557141566c666a4e5931566856696155466141453631346849493249524c316858316f69614764696250614e46475972326348304162737a5565386f6e43436963675144507469624d754d43677457672f3634303f77785f666d743d706e672674703d7765627026777866726f6d3d352677785f6c617a793d31" alt=""></p><p>这是演示如何启动 <code>ImageGotcha</code> 的 <code>Action Extension</code>：</p><p><embed src="https://imgcache.qq.com/tencentvideo_v1/playerv3/TPout.swf?max_age=86400&v=20161117&vid=o1339za69qd&auto=0" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"></embed></p><p>这是操作的演示：</p><p><embed src="https://imgcache.qq.com/tencentvideo_v1/playerv3/TPout.swf?max_age=86400&v=20161117&vid=w1339c8t6nc&auto=0" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"></embed></p><p>链接：<br><a href="https://itunes.apple.com/cn/app/imagegotcha/id1384107130?mt=8&at=1000lMM4" target="_blank" rel="noopener" style="display:inline-block;overflow:hidden;background:url(https://linkmaker.itunes.apple.com/assets/shared/badges/zh-cn/appstore-lrg.svg) no-repeat;width:135px;height:40px;background-size:contain;">ImageGotcha</a></p>]]></content>
      
      
      <categories>
          
          <category> 开源/产品 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用SVN建立和发布私有CocoaPods库</title>
      <link href="/2018/03/28/%E4%BD%BF%E7%94%A8SVN%E5%BB%BA%E7%AB%8B%E5%92%8C%E5%8F%91%E5%B8%83%E7%A7%81%E6%9C%89CocoaPods%E5%BA%93/"/>
      <url>/2018/03/28/%E4%BD%BF%E7%94%A8SVN%E5%BB%BA%E7%AB%8B%E5%92%8C%E5%8F%91%E5%B8%83%E7%A7%81%E6%9C%89CocoaPods%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="SVN-项目结构"><a href="#SVN-项目结构" class="headerlink" title="SVN 项目结构"></a>SVN 项目结构</h2><p>首先，一般 SVN 项目有如下的结构：</p><ul><li>trunk：项目主干</li><li>branches：开发或者 Bug 分支</li><li>tags：发布的版本</li></ul><p>比如说我们已经写好了一个 CocoaPods 的库，它的名字是 xxxKit，那么它应该在看起来是这样的：<br><img src="" alt=""></p><h2 id="建立-CocoaPods-库"><a href="#建立-CocoaPods-库" class="headerlink" title="建立 CocoaPods 库"></a>建立 CocoaPods 库</h2><p>我们在 trunk 的目录下执行 </p><p><code>pod lib create xxxKit</code></p><p>按照提示输入后，在该目录下就会利用 CocoaPods 的模板生成了一个项目。我们主要关注<code>xxxKit.podspec</code> 这个文件。</p><p>修改 <code>xxxKit.podspec</code>，比如：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">  s.name         &#x3D; &quot;xxxKit&quot;</span><br><span class="line">  s.version      &#x3D; &quot;0.1.1&quot;</span><br><span class="line">  s.summary      &#x3D; &quot;xxxKit.&quot;</span><br><span class="line">  s.homepage     &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;zyphs21&#x2F;&quot;</span><br><span class="line">  s.author       &#x3D; &#123; &quot;zyphs21&quot; &#x3D;&gt; &quot;hansenhs21@live.com&quot; &#125;</span><br><span class="line">  s.source       &#x3D; &#123; :svn &#x3D;&gt; &quot;http:&#x2F;&#x2F;xxxx&#x2F;xxxKit&#x2F;&quot;, :tag &#x3D;&gt; s.version.to_s &#125;</span><br><span class="line">  s.source_files  &#x3D; &quot;xxxKit&#x2F;**&#x2F;*.&#123;swift&#125;&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>主要注意是指定 source 那里，路径填的是 SVN 仓库的地址，并加上 tag。</p><p><code>s.source = { :svn =&gt; &quot;http://xxxx/xxxKit/&quot;, :tag =&gt; s.version.to_s }</code></p><h2 id="打-tags-发布一个版本"><a href="#打-tags-发布一个版本" class="headerlink" title="打 tags 发布一个版本"></a>打 tags 发布一个版本</h2><p>这里以 <code>Cornerstone</code> 这个 Mac 端的 SVN 工具来说明。</p><ol><li><p>去到远程库里进行打 tags，注意只有在远程库操作才能打 tag。</p><p> <img src="" alt=""></p></li><li><p>选择在 trunk 主干上 <code>右键</code> -&gt; <code>Tag…</code>，然后输入 tag 标签，比如 v0.1.1</p><p> <img src="" alt=""></p></li></ol><p>之后只要有开发到了新的版本了，按照这样先打 tag。</p><h2 id="使用私有库"><a href="#使用私有库" class="headerlink" title="使用私有库"></a>使用私有库</h2><p>去到需要使用该库的项目里，在 Podfile 里指定该版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &#39;xxxKit&#39;, :svn &#x3D;&gt; &#39;http:&#x2F;&#x2F;xxxx&#x2F;xxxKit&#x2F;&#39;, :tag &#x3D;&gt; &#39;0.1.1&#39;</span><br></pre></td></tr></table></figure><p>然后执行 <code>pod install</code></p>]]></content>
      
      
      <categories>
          
          <category> 工具教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>通过RunScript给iOS项目自增版本号(Versioin和Build)</title>
      <link href="/2018/03/14/%E9%80%9A%E8%BF%87RunScript%E7%BB%99iOS%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%A2%9E%E7%89%88%E6%9C%AC%E5%8F%B7(Versioin%E5%92%8CBuild)/"/>
      <url>/2018/03/14/%E9%80%9A%E8%BF%87RunScript%E7%BB%99iOS%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%A2%9E%E7%89%88%E6%9C%AC%E5%8F%B7(Versioin%E5%92%8CBuild)/</url>
      
        <content type="html"><![CDATA[<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ul><li>在打包应用之后，需要自增 <strong>Version 的最后一位</strong> 和 <strong>Build</strong> 的值。<br><img src="https://user-gold-cdn.xitu.io/2018/3/14/162201d291ebc6c1?w=690&h=136&f=png&s=11268" alt=""></li><li>只在 Archive(Release) 的时候触发该自增。</li></ul><h2 id="添加-RunScript"><a href="#添加-RunScript" class="headerlink" title="添加 RunScript"></a>添加 RunScript</h2><p>在 <code>项目Target</code> -&gt; <code>Build Phases</code> -&gt; <code>点击+号</code> -&gt; <code>New Run Script Phase</code></p><p>然后添加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$CONFIGURATION</span> == Release ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前为 Release Configuration,开始自增 Build"</span></span><br><span class="line">plist=<span class="variable">$&#123;INFOPLIST_FILE&#125;</span></span><br><span class="line">buildnum=$(/usr/libexec/PlistBuddy -c <span class="string">"Print CFBundleVersion"</span> <span class="string">"<span class="variable">$&#123;plist&#125;</span>"</span>)</span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$&#123;buildnum&#125;</span>"</span> == <span class="string">""</span> ]]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Error：在Plist文件里没有 Build 值"</span></span><br><span class="line"><span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">buildnum=$(expr <span class="variable">$buildnum</span> + 1)</span><br><span class="line">/usr/libexec/PlistBuddy -c <span class="string">"Set CFBundleVersion <span class="variable">$buildnum</span>"</span> <span class="string">"<span class="variable">$&#123;plist&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"开始自增 Version 最后一位"</span></span><br><span class="line">versionNum=$(/usr/libexec/PlistBuddy -c <span class="string">"Print CFBundleShortVersionString"</span> <span class="string">"<span class="variable">$&#123;plist&#125;</span>"</span>)</span><br><span class="line">thirdPartVersonNum=`<span class="built_in">echo</span> <span class="variable">$versionNum</span> | awk -F <span class="string">"."</span> <span class="string">'&#123;print $3&#125;'</span>`</span><br><span class="line">thirdPartVersonNum=$((<span class="variable">$thirdPartVersonNum</span> + 1))</span><br><span class="line">newVersionStr=`<span class="built_in">echo</span> <span class="variable">$versionNum</span> | awk -F <span class="string">"."</span> <span class="string">'&#123;print $1 "." $2 ".'</span><span class="variable">$thirdPartVersonNum</span><span class="string">'" &#125;'</span>`</span><br><span class="line">/usr/libexec/PlistBuddy -c <span class="string">"Set CFBundleShortVersionString <span class="variable">$newVersionStr</span>"</span> <span class="string">"<span class="variable">$&#123;plist&#125;</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$CONFIGURATION</span> <span class="string">"当前不为 Release Configuration"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>因为我的版本号是<code>xx.xx.xx</code>这样的形式，所以我以 <code>.</code> 拆分版本号后，取出第三个值来增加，最后再拼接回来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">versionNum&#x3D;$(&#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -c &quot;Print CFBundleShortVersionString&quot; &quot;$&#123;plist&#125;&quot;)</span><br><span class="line"># 这里取出第三个值</span><br><span class="line">thirdPartVersonNum&#x3D;&#96;echo $versionNum | awk -F &quot;.&quot; &#39;&#123;print $3&#125;&#39;&#96;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PathToGo诞生记</title>
      <link href="/2018/03/02/PathToGo%E8%AF%9E%E7%94%9F%E8%AE%B0/"/>
      <url>/2018/03/02/PathToGo%E8%AF%9E%E7%94%9F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>不知道大家在使用 Mac 的时候有没有这样的需求:</p><blockquote><p>经常需要获取当前文件或者文件夹的路径，并且复制到粘贴板。</p></blockquote><p>对于我来说经常有这种需要，然后我就从网上再结合自己的经验，找了好几种方法：</p><a id="more"></a><ol><li>右键-选择「显示简介」，然后在弹出的窗口里直接用鼠标拖动复制「位    置」里的路径。</li></ol><p>​    缺点：麻烦。</p><ol start="2"><li>把文件拖到浏览器，在浏览器地址栏复制路径。</li></ol><p>​    缺点：麻烦。</p><ol start="3"><li>打开终端，把文件拖入终端，终端会把文件路径打印出来，然后复制。</li></ol><p>​    缺点：麻烦。</p><ol start="4"><li>打开终端，cd到目标目录，然后输入 「pwd|pbcopy」就可以把路径复制到粘贴板。</li></ol><p>​    缺点：麻烦。</p><ol start="5"><li>选择文件，然后使用快捷键「Option + Command + C」。</li></ol><p>​    缺点：这个快捷键在更低版本的系统中好像不行，而且会与 Alfred 的一个快捷键冲突。还是麻烦。</p><ol start="6"><li>利用 Automator 来建立 Service 服务添加到右键服务菜单。</li></ol><p>​    缺点：麻烦。</p><p>以上几种方法都不能满足我的需求：</p><blockquote><ol><li>直观快捷</li><li>最好可以同时获取多个文件/文件夹的路径。</li></ol></blockquote><p>这时候我想起了很受大家欢迎的一款效率软件：Go2Shell</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/2/161e49096986d7c9?w=262&h=238&f=png&s=66436" alt=""></p><p>这款软件把它拖动到 Finder 的工具栏后，只要点击它就可以立刻启动终端，并且进入到当前的路径。</p><p>那可以不可以也做一款这样的 App 操作和 Go2Shell 类似，选中一个或多个文件或文件夹然后直接一点，就可以把当前选中的文件或文件夹路径复制到粘贴板呢？</p><p>然后经过一番折腾，『PathToGo』这款 App 就诞生了。</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/2/161e490bc920f193?w=554&h=438&f=png&s=151480" alt=""></p><p>虽然一开始是想直接利用 AppleScript 然后导出为应用程序的，可是看着 AppleScript 导出为应用程序的图标实在不够酷，就直接着手做了 PathToGo 这个简单的 Mac App。</p><p>下面看看实际体验效果吧：</p><p>首先是把『PathToGo』拖动到 Finder 的工具栏，记得是按住『command键』来进行拖动。</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/2/161e491134c3825f?w=492&h=214&f=gif&s=199517" alt=""></p><p>拖放好了之后，只需要选中你想要的一个或多个文件/文件夹，然后点击在工具栏上的『PathToGo』的图标，路径就已经复制到粘贴板上了，然后你就能愉快的 用 command+v 就能粘贴出你选择的文件的路径了。</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/2/161e491402bb99d2?w=668&h=366&f=gif&s=297785" alt=""></p><p>怎么样？是不是很方便快捷呢！<br><a href="https://github.com/HansonStudio/PathToGo" target="_blank" rel="noopener">PathToGo</a> 已经开源在 HansonStudio 的 Github 组织下了，大家可以在 Release 页面下载使用。</p>]]></content>
      
      
      <categories>
          
          <category> 开源/产品 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用SwiftGen管理UIImage等的String-based接口</title>
      <link href="/2017/12/08/%E7%94%A8SwiftGen%E7%AE%A1%E7%90%86UIImage%E7%AD%89%E7%9A%84String-based%E6%8E%A5%E5%8F%A3/"/>
      <url>/2017/12/08/%E7%94%A8SwiftGen%E7%AE%A1%E7%90%86UIImage%E7%AD%89%E7%9A%84String-based%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="问题现状"><a href="#问题现状" class="headerlink" title="问题现状"></a>问题现状</h1><p>平时我们使用UIImage，UIFont，UIColor会遇到很多String-based的接口方法，比如常用的UIImage：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> testImage = <span class="type">UIImage</span>(named: <span class="string">"test"</span>)</span><br></pre></td></tr></table></figure><p>对于上面的代码，如果我们把 <code>test</code> 拼写错了，Xcode 并不会给出提示，只有当我们运行的时候才会收到报错，这样维护起来是有一定成本的。</p><h1 id="代码解决"><a href="#代码解决" class="headerlink" title="代码解决"></a>代码解决</h1><p>我们可以用类似如下的代码来解决这个问题：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit.UIImage</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImageAssets</span> </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> image: <span class="type">UIImage</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> image = <span class="type">UIImage</span>(named: name)</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> result = image <span class="keyword">else</span> &#123; <span class="built_in">fatalError</span>(<span class="string">"Unable to load image named \(name)."</span>) &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Assets</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">AppLogo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> appLogo = <span class="type">ImageAssets</span>(name: <span class="string">"appLogo"</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> grayLogo = <span class="type">ImageAssets</span>(name: <span class="string">"gray_logo"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Arrow</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> arrowBlue = <span class="type">ImageAssets</span>(name: <span class="string">"arrow_blue"</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> arrowBrown = <span class="type">ImageAssets</span>(name: <span class="string">"arrow_brown"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIImage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>!(asset: <span class="type">ImageAssets</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(named: asset.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用上面的代码，我们在新建 UIImage 的时候就不需要去想图片的名字了，而且 Xcode 还会有代码提示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> logo = <span class="type">Asset</span>.<span class="type">AppLogo</span>.appLogo.image</span><br><span class="line"><span class="keyword">let</span> grayLogo = <span class="type">UIImage</span>(asset: <span class="type">Asset</span>.<span class="type">AppLogo</span>.grayLogo)</span><br></pre></td></tr></table></figure><h1 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h1><p>虽然这种方法在调用的时候简单又安全了，但是项目中的图片往往比较多，如果手动编写维护那段代码也是需要不少精力，而且不能保证后续不会添加新的图片，这样每次都要去维护那段代码不免有些反人类。<br>那么现在就要介绍这个开源项目—  <a href="https://github.com/SwiftGen/SwiftGen" target="_blank" rel="noopener"><code>SwiftGen</code></a>了！</p><blockquote><p>SwiftGen is a tool to auto-generate Swift code for resources of your projects, to make them type-safe to use.</p></blockquote><p>利用 SwiftGen 可以帮我们生成这类的代码，但是 SwiftGen 默认生成的代码样式有时候并不是我们想要的，而且默认生成还会有针对 macOS 上的代码，比较好的是 SwiftGen 提供了模板的功能，我们可以按自己的需要来修改模板。</p><h1 id="集成-SwiftGen-在项目中"><a href="#集成-SwiftGen-在项目中" class="headerlink" title="集成 SwiftGen 在项目中"></a>集成 SwiftGen 在项目中</h1><p>SwiftGen 提供了好几种的集成方式，我这里只介绍我自己比较喜欢的方式：就是通过下载它的 Zip 文件解压到项目的目录中，然后通过添加 Run Script 来进行管理。这样可以基本做到不用操心代码。</p><h2 id="1-修改模板"><a href="#1-修改模板" class="headerlink" title="1.修改模板"></a>1.修改模板</h2><ul><li><p>到 SwiftGen仓库的Release页面下载最新的 <a href="https://github.com/SwiftGen/SwiftGen/releases" target="_blank" rel="noopener">swiftgen-5.2.1.zip</a></p></li><li><p>将解压后的 <code>swiftgen-5.2.1</code> 文件夹放到项目所在的目录下(存放<code>xxx.xcodeproj</code> 的位置)，可以将文件夹的名字改为<code>SwiftGen5</code>简洁一点。</p></li><li><p>进入到 <code>SwiftGen5</code> 里的 <code>templates/xcassets</code> 目录下，这里面可以看到有不少模板，我们选择 <code>swift4.stencil</code> 复制一份，命名为 <code>my-swift4.stencil</code> 然后我们就可以在里面修改我们自己想要的模板，我主要是想把 macOS 等其它平台的一些判断代码给删掉:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generated using SwiftGen, using my-templete created by Hanson</span></span><br><span class="line"></span><br><span class="line">&#123;% <span class="keyword">if</span> catalogs %&#125;</span><br><span class="line">&#123;% <span class="keyword">set</span> imageAlias %&#125;&#123;&#123;param.imageAliasName|<span class="keyword">default</span>:<span class="string">"Image"</span>&#125;&#125;&#123;% endset %&#125;</span><br><span class="line"><span class="keyword">import</span> UIKit.UIImage</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> &#123;&#123;imageAlias&#125;&#125; = <span class="type">UIImage</span></span><br><span class="line"></span><br><span class="line">&#123;% <span class="keyword">set</span> enumName %&#125;&#123;&#123;param.enumName|<span class="keyword">default</span>:<span class="string">"Asset"</span>&#125;&#125;&#123;% endset %&#125;</span><br><span class="line">&#123;% <span class="keyword">set</span> imageType %&#125;&#123;&#123;param.imageTypeName|<span class="keyword">default</span>:<span class="string">"ImageAsset"</span>&#125;&#125;&#123;% endset %&#125;</span><br><span class="line"><span class="meta">@available</span>(*, deprecated, renamed: <span class="string">"&#123;&#123;imageType&#125;&#125;"</span>)</span><br><span class="line"><span class="keyword">typealias</span> &#123;&#123;enumName&#125;&#125;<span class="type">Type</span> = &#123;&#123;imageType&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span>&#123;&#123;imageType&#125;&#125; &#123;</span><br><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> image: &#123;&#123;imageAlias&#125;&#125; &#123;</span><br><span class="line"><span class="keyword">let</span> bundle = <span class="type">Bundle</span>(<span class="keyword">for</span>: <span class="type">BundleToken</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="keyword">let</span> image = &#123;&#123;imageAlias&#125;&#125;(named: name, <span class="keyword">in</span>: bundle, compatibleWith: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> result = image <span class="keyword">else</span> &#123; <span class="built_in">fatalError</span>(<span class="string">"Unable to load image named \(name)."</span>) &#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% macro enumBlock assets sp %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% call casesBlock assets sp %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% <span class="keyword">if</span> not param.noAllValues %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% endif %&#125;</span><br><span class="line">&#123;% endmacro %&#125;</span><br><span class="line">&#123;% macro casesBlock assets sp %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% <span class="keyword">for</span> asset <span class="keyword">in</span> assets %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% <span class="keyword">if</span> asset.type == <span class="string">"color"</span> %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  <span class="keyword">static</span> <span class="keyword">let</span> &#123;&#123;asset.name|swiftIdentifier:<span class="string">"pretty"</span>|lowerFirstWord|escapeReservedKeywords&#125;&#125; = &#123;&#123;colorType&#125;&#125;(name: <span class="string">"&#123;&#123;asset.value&#125;&#125;"</span>)</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% elif asset.type == <span class="string">"image"</span> %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  <span class="keyword">static</span> <span class="keyword">let</span> &#123;&#123;asset.name|swiftIdentifier:<span class="string">"pretty"</span>|lowerFirstWord|escapeReservedKeywords&#125;&#125; = &#123;&#123;imageType&#125;&#125;(name: <span class="string">"&#123;&#123;asset.value&#125;&#125;"</span>)</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% elif asset.items %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  <span class="class"><span class="keyword">enum</span> </span>&#123;&#123;asset.name|swiftIdentifier:<span class="string">"pretty"</span>|escapeReservedKeywords&#125;&#125; &#123;</span><br><span class="line">&#123;&#123;sp&#125;&#125;    &#123;% <span class="keyword">set</span> sp2 %&#125;&#123;&#123;sp&#125;&#125;  &#123;% endset %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;    &#123;% call casesBlock asset.items sp2 %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% endif %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% endfor %&#125;</span><br><span class="line">&#123;% endmacro %&#125;</span><br><span class="line">&#123;% macro allValuesBlock assets <span class="built_in">filter</span> <span class="keyword">prefix</span> sp %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% <span class="keyword">for</span> asset <span class="keyword">in</span> assets %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% <span class="keyword">if</span> asset.type == <span class="built_in">filter</span> %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;&#123;<span class="keyword">prefix</span>&#125;&#125;&#123;&#123;asset.name|swiftIdentifier:<span class="string">"pretty"</span>|lowerFirstWord|escapeReservedKeywords&#125;&#125;,</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% elif asset.items %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% <span class="keyword">set</span> prefix2 %&#125;&#123;&#123;<span class="keyword">prefix</span>&#125;&#125;&#123;&#123;asset.name|swiftIdentifier:<span class="string">"pretty"</span>|escapeReservedKeywords&#125;&#125;.&#123;% endset %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% call allValuesBlock asset.items <span class="built_in">filter</span> prefix2 sp %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% endif %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% endfor %&#125;</span><br><span class="line">&#123;% endmacro %&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> </span>&#123;&#123;enumName&#125;&#125; &#123;</span><br><span class="line">&#123;% <span class="keyword">if</span> catalogs.<span class="built_in">count</span> &gt; <span class="number">1</span> %&#125;</span><br><span class="line">&#123;% <span class="keyword">for</span> catalog <span class="keyword">in</span> catalogs %&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> </span>&#123;&#123;catalog.name|swiftIdentifier:<span class="string">"pretty"</span>|escapeReservedKeywords&#125;&#125; &#123;</span><br><span class="line">&#123;% call enumBlock catalog.assets <span class="string">"  "</span> %&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">&#123;% call enumBlock catalogs.first.assets <span class="string">""</span> %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> </span>&#123;&#123;imageAlias&#125;&#125; &#123;</span><br><span class="line"><span class="keyword">convenience</span> <span class="keyword">init</span>!(asset: &#123;&#123;imageType&#125;&#125;) &#123;</span><br><span class="line"><span class="keyword">let</span> bundle = <span class="type">Bundle</span>(<span class="keyword">for</span>: <span class="type">BundleToken</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="keyword">self</span>.<span class="keyword">init</span>(named: asset.name, <span class="keyword">in</span>: bundle, compatibleWith: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BundleToken</span> </span>&#123;&#125;</span><br><span class="line">&#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line"><span class="comment">// No assets found</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h2 id="2-建立RunScript"><a href="#2-建立RunScript" class="headerlink" title="2.建立RunScript"></a>2.建立RunScript</h2></li><li><p>在<code>Xcode</code>中，进入到项目的<code>Target</code>，选择<code>Build Phases</code>,然后点击左上角的 <code>+</code> 号后点击 <code>New Run Script Phase</code>在新建的RunScript里添加如下内容：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">which</span> <span class="string">"<span class="variable">$PROJECT_DIR</span>"</span>/SwiftGen5/bin/swiftgen &gt;/dev/null;</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="string">"<span class="variable">$PROJECT_DIR</span>"</span>/SwiftGen5/bin/swiftgen xcassets -t my-swift4 <span class="string">"<span class="variable">$PROJECT_DIR</span>/swiftGenExample/Assets.xcassets"</span> --output <span class="string">"<span class="variable">$PROJECT_DIR</span>/swiftGenExample/ImageCode/ImageAsset.swift"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"##run echo warning: SwiftGen not installed, download it from https://github.com/SwiftGen/SwiftGen"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>  这段 <code>Run Script</code> 作用就是利用 SwiftGen 生成代码后写入到 <code>ImageAsset.swift</code> 文件中。</p></li><li><p>Build 一下project，我们就可以在 <code>/swiftGenExample/ImageCode/</code> 目录下看到 <code>ImageAsset.swift</code>，此时该文件还没有被项目索引，所以把它拖进项目Xcode对应的目录下就行了，之后即使我们添加了新的图片或者删掉旧的图片，只要每次Build一下项目，代码就会自动更新了。</p></li></ul><p>下面是生成的 <code>ImageAsset.swift</code> 的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ImageAsset.swift</span></span><br><span class="line"><span class="comment">// Generated using SwiftGen, using my-templete created by Hanson</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit.UIImage</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Image</span> = <span class="type">UIImage</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(*, deprecated, renamed: <span class="string">"ImageAsset"</span>)</span><br><span class="line"><span class="keyword">typealias</span> <span class="type">AssetType</span> = <span class="type">ImageAsset</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImageAsset</span> </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> image: <span class="type">Image</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> bundle = <span class="type">Bundle</span>(<span class="keyword">for</span>: <span class="type">BundleToken</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">let</span> image = <span class="type">Image</span>(named: name, <span class="keyword">in</span>: bundle, compatibleWith: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> result = image <span class="keyword">else</span> &#123; <span class="built_in">fatalError</span>(<span class="string">"Unable to load image named \(name)."</span>) &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Asset</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> arrowBlue = <span class="type">ImageAsset</span>(name: <span class="string">"arrow_blue"</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> arrowBrown = <span class="type">ImageAsset</span>(name: <span class="string">"arrow_brown"</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> iconLeftBack = <span class="type">ImageAsset</span>(name: <span class="string">"icon_left_back"</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> startLogo = <span class="type">ImageAsset</span>(name: <span class="string">"start_logo"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>!(asset: <span class="type">ImageAsset</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> bundle = <span class="type">Bundle</span>(<span class="keyword">for</span>: <span class="type">BundleToken</span>.<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(named: asset.name, <span class="keyword">in</span>: bundle, compatibleWith: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BundleToken</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这里只是利用了 <code>SwiftGen</code> 对于 <code>Image</code> 的部分。它还有其它的关于 <code>String</code> ，<code>StroyBoard</code>，<code>Font</code>等等的代码生成。原理基本相同，靠大家按需研究啦。</p><blockquote><p>到我的博客阅读：<a href="http://www.myhanson.com/2017/12/08/%E7%94%A8SwiftGen%E7%AE%A1%E7%90%86UIImage%E7%AD%89%E7%9A%84String-based%E6%8E%A5%E5%8F%A3/#more" target="_blank" rel="noopener">myhanson.com</a><br>本文Demo：<a href="https://github.com/zyphs21/SwiftGenExample" target="_blank" rel="noopener">SwiftGenExample</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift 实现启动屏动画</title>
      <link href="/2017/12/08/Swift%20%E5%AE%9E%E7%8E%B0%E5%90%AF%E5%8A%A8%E5%B1%8F%E5%8A%A8%E7%94%BB/"/>
      <url>/2017/12/08/Swift%20%E5%AE%9E%E7%8E%B0%E5%90%AF%E5%8A%A8%E5%B1%8F%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Github: <a href="https://github.com/zyphs21/SplashAnimate" target="_blank" rel="noopener">SplashAnimate</a></p></blockquote><a id="more"></a><h2 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h2><p>首先我们需要确定作为宣传的图片的宽高比，这个一般是与 UI 确定的。一般启动屏展示会有上下两部分，上面是宣传图片，下面是 App 的 Logo。</p><h2 id="实现基本思路："><a href="#实现基本思路：" class="headerlink" title="实现基本思路："></a>实现基本思路：</h2><p>在 LaunchScreen 结束后，在 AppDelegate 中将 rootViewController 指向展示广告用的 AdViewController，在AdViewController 中设置一段时间后自己销毁，并提供回调方法在 AppDelegate 中将 rootViewController 指向 App 真正的首页。</p><h2 id="实现细节："><a href="#实现细节：" class="headerlink" title="实现细节："></a>实现细节：</h2><p>新建一个 AdViewController 用于放置广告宣传等展示.注意有一个回调方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于 AdViewController 销毁后的回调</span></span><br><span class="line">    <span class="keyword">var</span> completion: (() -&gt; <span class="type">Void</span>)?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> adImage: <span class="type">UIImage?</span></span><br><span class="line">    <span class="keyword">var</span> adView: <span class="type">UIImageView?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ViewDidLoad 方法中配置广告图,同时判断 iPhoneX的特殊情况</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> adViewHeight = (<span class="number">1040</span> / <span class="number">720</span>) * screenWidth</span><br><span class="line">    <span class="keyword">var</span> imageName = <span class="string">"start_page"</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">UIDevice</span>.isiPhoneX() &#123;</span><br><span class="line">        adViewHeight = (<span class="number">1920</span> / <span class="number">1124</span>) * screenWidth</span><br><span class="line">        imageName = <span class="string">"start_page_x"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    adView = <span class="type">UIImageView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: screenWidth, height: adViewHeight))</span><br><span class="line">    adView?.image = <span class="type">UIImage</span>(named: imageName)</span><br><span class="line">    adView?.contentMode = .scaleAspectFill</span><br><span class="line">    <span class="keyword">self</span>.view.addSubview(adView!)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> bottomHolderView = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: screenHeight-<span class="number">120</span>, width: screenWidth, height: <span class="number">120</span>))</span><br><span class="line">    <span class="keyword">self</span>.view.addSubview(bottomHolderView)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> logo = <span class="type">UIImageView</span>(frame: <span class="type">CGRect</span>(x: (screenWidth-<span class="number">120</span>)/<span class="number">2</span>, y: (<span class="number">120</span>-<span class="number">50</span>)/<span class="number">2</span>, width: <span class="number">120</span>, height: <span class="number">50</span>))</span><br><span class="line">    logo.image = <span class="type">UIImage</span>(named: <span class="string">"start_logo"</span>)</span><br><span class="line">    bottomHolderView.addSubview(logo)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> time: <span class="type">TimeInterval</span> = <span class="number">1.0</span></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: <span class="type">DispatchTime</span>.now() + time) &#123;</span><br><span class="line">        <span class="keyword">self</span>.dismissAdView()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中有几个注意的:</p><p>因为图片要撑满屏幕的宽度，所以宽度是固定的，根据图片的高宽比，算出图片实际应有的高度，这样图片可以在各个尺寸的 iPhone 中才不会因为拉伸而变形。但是因为 iPhoneX 特殊的宽高比，所以还是要为它特定一张图片，不然即使图片在 iPhoneX 上不变形，图片所占的高度会太小，或者顶部被刘海遮挡内容而不美观。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> adViewHeight = (<span class="number">1040</span> / <span class="number">720</span>) * screenWidth</span><br><span class="line"><span class="keyword">var</span> imageName = <span class="string">"start_page"</span></span><br><span class="line"><span class="keyword">if</span> <span class="type">UIDevice</span>.isiPhoneX() &#123;</span><br><span class="line">    adViewHeight = (<span class="number">1920</span> / <span class="number">1124</span>) * screenWidth</span><br><span class="line">    imageName = <span class="string">"start_page_x"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面判断是否为 iPhoneX 我是在 UIDevice 里扩展了一个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extension UIDevice &#123;</span><br><span class="line">    public static func isiPhoneX() -&gt; Bool &#123;</span><br><span class="line">        if UIScreen.main.bounds.height &#x3D;&#x3D; 812 &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有注意在执行销毁时调用回调方法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> time: <span class="type">TimeInterval</span> = <span class="number">1.0</span></span><br><span class="line"><span class="type">DispatchQueue</span>.main.asyncAfter(deadline: <span class="type">DispatchTime</span>.now() + time) &#123;</span><br><span class="line">    <span class="keyword">self</span>.dismissAdView()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 AppDelegate 中 didFinishLaunchingWithOptions 方法中调用下面的 setUpWindowAndRootView() 来管理页面展示</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AppDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setUpWindowAndRootView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        window = <span class="type">UIWindow</span>(frame: <span class="type">UIScreen</span>.main.bounds)</span><br><span class="line">        window!.backgroundColor = <span class="type">UIColor</span>.white</span><br><span class="line">        window!.makeKeyAndVisible()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> adVC = <span class="type">AdViewController</span>()</span><br><span class="line">        adVC.completion = &#123;</span><br><span class="line">            <span class="keyword">let</span> vc = <span class="type">ViewController</span>()</span><br><span class="line">            vc.adView = adVC.view</span><br><span class="line">            <span class="keyword">self</span>.window!.rootViewController = vc</span><br><span class="line">        &#125;</span><br><span class="line">        window!.rootViewController = adVC</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在 AdViewController 销毁的回调方法中，将 AdViewController 的 view 传给真正的首页，让首页来执行动画</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adVC.completion = &#123;</span><br><span class="line">    <span class="keyword">let</span> vc = <span class="type">ViewController</span>()</span><br><span class="line">    <span class="comment">// 将 AdViewController 的 view 传给真正的首页，让首页来执行动画</span></span><br><span class="line">    vc.adView = adVC.view</span><br><span class="line">    <span class="keyword">self</span>.window!.rootViewController = vc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在首页 ViewController 里我们有如下方法来执行 AdViewController 的销毁动画，这里配置的动画是常见的扩大渐变消失</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> advertiseView: <span class="type">UIView?</span></span><br><span class="line"><span class="keyword">var</span> adView: <span class="type">UIView?</span> &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        advertiseView = adView!</span><br><span class="line">        advertiseView?.frame = <span class="keyword">self</span>.view.bounds</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(advertiseView!)</span><br><span class="line">        <span class="type">UIView</span>.animate(withDuration: <span class="number">1.5</span>, animations: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>?.advertiseView?.transform = <span class="type">CGAffineTransform</span>(scaleX: <span class="number">1.2</span>, y: <span class="number">1.2</span>)</span><br><span class="line">            <span class="keyword">self</span>?.advertiseView?.alpha = <span class="number">0</span></span><br><span class="line">        &#125;) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (isFinish) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>?.advertiseView?.removeFromSuperview()</span><br><span class="line">            <span class="keyword">self</span>?.advertiseView = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，一个简单的启动屏动画就完成了。</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>记一次失败的 Swift 元组数组实践</title>
      <link href="/2017/11/28/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%20Swift%20%E5%85%83%E7%BB%84%E6%95%B0%E7%BB%84%E5%AE%9E%E8%B7%B5/"/>
      <url>/2017/11/28/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%20Swift%20%E5%85%83%E7%BB%84%E6%95%B0%E7%BB%84%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>想建立一个元组的数组，来简单存放构建 TabViewController 的信息首先我的做法是</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> homeTab = (vc: <span class="type">VYHomeViewController</span>(), title: <span class="string">"Home"</span>, image: <span class="string">"home_gray"</span>, selectedImage: <span class="string">"home_blue"</span>)</span><br><span class="line"><span class="keyword">let</span> infoTab = (vc: <span class="type">VYInformationViewController</span>(), title: <span class="string">"Info"</span>, image: <span class="string">"home_gray"</span>, selectedImage: <span class="string">"home_blue"</span>)</span><br><span class="line"><span class="keyword">let</span> marketTab = (vc: <span class="type">VYMarketViewController</span>(), title: <span class="string">"Market"</span>, image: <span class="string">"home_gray"</span>, selectedImage: <span class="string">"home_blue"</span>)</span><br><span class="line"><span class="keyword">let</span> userTab = (vc: <span class="type">VYUserCenterViewController</span>(), title: <span class="string">"Me"</span>, image: <span class="string">"home_gray"</span>, selectedImage: <span class="string">"home_blue"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面报错：Heterogeneous collection literal could only be inferred to '[Any]'; add explicit type annotation if this is intentional</span></span><br><span class="line"><span class="keyword">let</span> data = [homeTab, infoTab, marketTab, userTab]</span><br></pre></td></tr></table></figure><p>但是会报错，Xcode 的修改提示是后面添加  <code>as [Any]</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [selfSelectedTab, infoTab, marketTab, userTab] <span class="keyword">as</span> [<span class="type">Any</span>]</span><br></pre></td></tr></table></figure><p>但是这样做已经不是原来的做一个元组数组的初衷了。无法在遍历数组的时候使用命名元组来获取信息</p><a id="more"></a><p>接着我用 <code>typealias</code> 的方法改成如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">TabInfo</span> = (vc: <span class="type">UIViewController</span>, title: <span class="type">String</span>, image: <span class="type">String</span>, selectedImage: <span class="type">String</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tabInfo: [<span class="type">TabInfo</span>] = [<span class="type">TabInfo</span>]()</span><br><span class="line"><span class="keyword">let</span> homeTab = (vc: <span class="type">VYHomeViewController</span>(), title: <span class="string">"Home"</span>, image: <span class="string">"home_gray"</span>, selectedImage: <span class="string">"home_blue"</span>)</span><br><span class="line"><span class="keyword">let</span> infoTab = (vc: <span class="type">VYHomeViewController</span>(), title: <span class="string">"Info"</span>, image: <span class="string">"home_gray"</span>, selectedImage: <span class="string">"home_blue"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面报错：Cannot express tuple conversion '(vc: VYInformationViewController, title: String, image: String, selectedImage: String)' to '(vc: UIViewController, title: String, image: String, selectedImage: String)'</span></span><br><span class="line">tabInfo.append(homeTab)</span><br></pre></td></tr></table></figure><p>给数组添加元素的时候报错，因为元组不支持类型转换，<code>VYHomeViewController</code> 虽然继承 <code>UIViewController</code>，但是元组看来它们不是同一类型。</p><p>最后还是放弃了用元组数组的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> homeTab = (vc: <span class="type">VYHomePageViewController</span>(), title: <span class="type">Home</span>, image: <span class="string">"new_home_gray"</span>, selectedImage: <span class="string">"new_home_blue"</span>)</span><br><span class="line"><span class="keyword">let</span> infoTab = (vc: <span class="type">VYInformationViewController</span>(), title: <span class="type">Info</span>, image: <span class="string">"msg_gray"</span>, selectedImage: <span class="string">"msg_blue"</span>)</span><br><span class="line"><span class="keyword">let</span> marketTab = (vc: <span class="type">VYMarketViewController</span>(), title: <span class="type">Market</span>, image: <span class="string">"hangqing_gray"</span>, selectedImage: <span class="string">"hangqing_blue"</span>)</span><br><span class="line"><span class="keyword">let</span> userTab = (vc: <span class="type">VYUserCenterViewController</span>(), title: <span class="type">Me</span>, image: <span class="string">"mine_gray"</span>, selectedImage: <span class="string">"mine_blue"</span>)</span><br><span class="line"></span><br><span class="line">addViewController(homeTab.vc, title: homeTab.title, image: homeTab.image, selectedIamge: homeTab.selectedImage)</span><br><span class="line">addViewController(infoTab.vc, title: infoTab.title, image: infoTab.image, selectedIamge: infoTab.selectedImage)</span><br><span class="line">addViewController(marketTab.vc, title: marketTab.title, image: marketTab.image, selectedIamge: marketTab.selectedImage)</span><br><span class="line">addViewController(userTab.vc, title: userTab.title, image: userTab.image, selectedIamge: userTab.selectedImage)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自定义 UISegmentedControl 样式</title>
      <link href="/2017/05/09/%E8%87%AA%E5%AE%9A%E4%B9%89%20UISegmentedControl%20%E6%A0%B7%E5%BC%8F/"/>
      <url>/2017/05/09/%E8%87%AA%E5%AE%9A%E4%B9%89%20UISegmentedControl%20%E6%A0%B7%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>系统的 UISegmentedControl 是个挺方便的控件，这里来讲讲在 Swift3 下自定义 UISegmentedControl 的样式，包括修改底色，边框颜色等等。</p><p>要了解 UISegmentedControl 各个部分的组成，可以在官方的文档中找到 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/UIKitUICatalog/UISegmentedControl.html" target="_blank" rel="noopener">UISegmentedControl 文档</a> 。着重注意这个图：</p><p>   <img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/uisegment/uisegment.png" alt="image.png"></p><p>上面这幅图明确的列出了 UISegmentedControl 各个部分所控制的方法。下面就开始自定义吧。  </p><a id="more"></a><p>首先我们先做一个通过颜色生成图片的的一个扩展方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIImage</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">renderImageWithColor</span>(<span class="title">_</span> <span class="title">color</span>: <span class="title">UIColor</span>, <span class="title">size</span>: <span class="title">CGSize</span>) -&gt; <span class="title">UIImage</span> </span>&#123;</span><br><span class="line">        <span class="type">UIGraphicsBeginImageContext</span>(size)</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>() <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">            <span class="keyword">return</span> <span class="type">UIImage</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        context.setFillColor(color.cgColor);</span><br><span class="line">        context.fill(<span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: size.width, height: size.height));</span><br><span class="line">        <span class="keyword">let</span> img = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">        <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">        <span class="keyword">return</span> img ?? <span class="type">UIImage</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们可以为 UISegmentedControl 建立一个可以自定义颜色的扩展方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UISegmentedControl</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 自定义样式</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameters:</span></span><br><span class="line">    <span class="comment">///   - normalColor: 普通状态下背景色</span></span><br><span class="line">    <span class="comment">///   - selectedColor: 选中状态下背景色</span></span><br><span class="line">    <span class="comment">///   - dividerColor: 选项之间的分割线颜色</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setSegmentStyle</span><span class="params">(normalColor: UIColor, selectedColor: UIColor, dividerColor: UIColor)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> normalColorImage = <span class="type">UIImage</span>.renderImageWithColor(normalColor, size: <span class="type">CGSize</span>(width: <span class="number">1.0</span>, height: <span class="number">1.0</span>))</span><br><span class="line">        <span class="keyword">let</span> selectedColorImage = <span class="type">UIImage</span>.renderImageWithColor(selectedColor, size: <span class="type">CGSize</span>(width: <span class="number">1.0</span>, height: <span class="number">1.0</span>))</span><br><span class="line">        <span class="keyword">let</span> dividerColorImage = <span class="type">UIImage</span>.renderImageWithColor(dividerColor, size: <span class="type">CGSize</span>(width: <span class="number">1.0</span>, height: <span class="number">1.0</span>))</span><br><span class="line">        </span><br><span class="line">        setBackgroundImage(normalColorImage, <span class="keyword">for</span>: .normal, barMetrics: .<span class="keyword">default</span>)</span><br><span class="line">        setBackgroundImage(selectedColorImage, <span class="keyword">for</span>: .selected, barMetrics: .<span class="keyword">default</span>)</span><br><span class="line">        setDividerImage(dividerColorImage, forLeftSegmentState: .normal, rightSegmentState: .normal, barMetrics: .<span class="keyword">default</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> segAttributesNormal: <span class="type">NSDictionary</span> = [<span class="type">NSForegroundColorAttributeName</span>: <span class="type">UIColor</span>.gray, <span class="type">NSFontAttributeName</span>: <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">14</span>)]</span><br><span class="line">        <span class="keyword">let</span> segAttributesSeleted: <span class="type">NSDictionary</span> = [<span class="type">NSForegroundColorAttributeName</span>: <span class="type">UIColor</span>.white,<span class="type">NSFontAttributeName</span>: <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">14</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 文字在两种状态下的颜色</span></span><br><span class="line">        setTitleTextAttributes(segAttributesNormal <span class="keyword">as</span> [<span class="type">NSObject</span> : <span class="type">AnyObject</span>], <span class="keyword">for</span>: <span class="type">UIControlState</span>.normal)</span><br><span class="line">        setTitleTextAttributes(segAttributesSeleted <span class="keyword">as</span> [<span class="type">NSObject</span> : <span class="type">AnyObject</span>], <span class="keyword">for</span>: <span class="type">UIControlState</span>.selected)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 边界颜色、圆角</span></span><br><span class="line">        <span class="keyword">self</span>.layer.borderWidth = <span class="number">0.7</span></span><br><span class="line">        <span class="keyword">self</span>.layer.cornerRadius = <span class="number">5.0</span></span><br><span class="line">        <span class="keyword">self</span>.layer.borderColor = dividerColor.cgColor</span><br><span class="line">        <span class="keyword">self</span>.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个扩展方法我只暴露了三种颜色的修改，大家可以根据自己需求修改。<br>最后就是使用了，注意这里如果进行了自定义，不能用 autoLayout 了, 需指定 Segement 的位置大小，不然显示出来的效果被压缩成了一条线，我估计是 setBackgroundImage 的方法需要把 1x1 的颜色图片进行填充，如果不指定大小会出差错。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> segment = <span class="type">UISegmentedControl</span>(items: [<span class="string">"测试"</span>, <span class="string">"测试"</span>, <span class="string">"测试"</span>])</span><br><span class="line">segment.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">150</span>, height: <span class="number">40</span>)</span><br><span class="line">segment.setSegmentStyle(normalColor: <span class="type">UIColor</span>.clear, selectedColor: <span class="type">UIColor</span>.cyan, dividerColor: <span class="type">UIColor</span>.gray)</span><br><span class="line">segment.selectedSegmentIndex = <span class="number">0</span></span><br><span class="line">view.addSubview(segment)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/uisegment/testSegment.png" alt="image.png"></p><p>个人比较喜欢用 extension 扩展方法，这里大家直接拷贝就能够使用了，祝大家自定义愉快吧~</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HSStockChart介绍</title>
      <link href="/2017/05/03/HSStockChart%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/05/03/HSStockChart%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>HSStockChart 是一个绘制股票分时图、K 线图的库。支持流畅的回弹拖动，长按十字线，捏合放大缩小等功能，主要使用了 CAShapeLayer 来绘图，相比使用 Core Graphics 和重写 drawRect 的方法更高效，占用内存更小。<br><a href="https://github.com/zyphs21/HSStockChart" target="_blank" rel="noopener">GitHub 地址：HSStockChart</a>  </p><p><img src="http://upload-images.jianshu.io/upload_images/757687-92b2069869929ccd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><a id="more"></a><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li><input checked="" disabled="" type="checkbox"> 支持绘制分时图，五日分时图，K 线图，MA 线指标，交易量柱等。</li><li><input checked="" disabled="" type="checkbox"> 支持横屏查看。</li><li><input checked="" disabled="" type="checkbox"> K 线图利用 <code>UIScrollView</code> 达到流畅的滑动查看效果。</li><li><input checked="" disabled="" type="checkbox"> 使用 <code>CAShapeLayer</code> 绘图，内存占用更小，效率更高。</li></ul><h2 id="版本需求"><a href="#版本需求" class="headerlink" title="版本需求"></a>版本需求</h2><ul><li>iOS 8.0+</li><li>Swift 3</li></ul><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ol><li><p>之前绘图的方法是重写 <code>drawRect</code> 方法，在方法里获取 <code>CGContext</code> 然后利用Core Graphics 来进行绘图，调用 <code>setNeedsDisplay</code> 来刷新。但是这种方法有个问题是：</p><blockquote><p>一旦你实现了 CALayerDelegate 协议中的 -drawLayer:inContext: 方法或者 UIView 中的 -drawRect: 方法（其实就是前者的包装方法），图层就创建了一个绘制上下文，这个上下文需要的内存可从这个公式得出：图层宽x图层高x4字节，宽高的单位均为像素。对于一个在 Retina iPad 上的全屏图层来说，这个内存量就是 2048x1526x4字节，相当于12MB内存，图层每次重绘的时候都需要重新抹掉内存然后重新分配。【摘自 iOS Core Animation- Advanced Techniques 中文译本 高效绘图一章】</p></blockquote><p>因为我要达到流畅滑动查看的效果，所以在 <code>UIScrollView</code> 上添加了一个 <code>UIView</code> 这个 View 的宽度会依据当前展示数据的多少而变化，结合 <code>UIScrollView</code> 的 <code>ContentSize</code> 就能达到很好的滑动效果。</p><p><img src="http://upload-images.jianshu.io/upload_images/757687-36a3d278fd71fc4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>如果我用之前重写 <code>drawRect</code> 的方法，那么这个 View 会根据数据量的变大而变大，从而导致绘图内存急剧上升，数据量大的时候会崩溃。基于此，我采用了 <code>CAShapeLayer</code> 的方式绘图，此方式的特点如下：</p><blockquote><p>CAShapeLayer 是一个通过矢量图形而不是 bitmap 来绘制的图层子类。你指定诸如颜色和线宽等属性，用 CGPath 来定义想要绘制的图形，最后就自动渲染出来了。当然，你也可以用 Core Graphics 直接向原始的内容中绘制一个路径，相比之下，使用 CAShapeLayer 有以下一些优点:</p><ul><li>渲染快速。CAShapeLayer 使用了硬件加速，绘制同一图形会比用 Core Graphics 快很多。</li><li>高效使用内存。一个 CAShapeLayer 不需要像普通 CALayer 一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。 </li><li>不会被图层边界剪裁掉，一个 CAShapeLayer 可以在边界之外绘制。你的图层路径不会像在使用 Core Graphics 的普通 CALayer 一样被剪裁掉。</li><li>不会出现像素化。当你给 CAShapeLayer 做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化</li></ul></blockquote><p>最终在真机上测试(注意是在真机上测试)两种方式的结果如图，内存大大降低并且稳定在13M左右</p><p> <img src="http://upload-images.jianshu.io/upload_images/757687-a773aeda8ac7ff01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>自定义 CAShapeLayer，重写 action(forKey event: String) 方法。目的是 关闭 CAShapeLayer 的隐式动画，避免滑动时候或者十字线出现时有残影的现象(实际上是因为 Layer 的 position 属性变化而产生的隐式动画)</p></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HSCAShapeLayer</span>: <span class="title">CAShapeLayer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">action</span><span class="params">(forKey event: String)</span></span> -&gt; <span class="type">CAAction?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>Released under MIT License.</p>]]></content>
      
      
      <categories>
          
          <category> 开源/产品 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
