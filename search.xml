<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>自然常数 e 为什么冠以“自然”二字</title>
      <link href="/2020/11/19/%E8%87%AA%E7%84%B6%E5%B8%B8%E6%95%B0e%20%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%A0%E4%BB%A5%E8%87%AA%E7%84%B6%E4%BA%8C%E5%AD%97/"/>
      <url>/2020/11/19/%E8%87%AA%E7%84%B6%E5%B8%B8%E6%95%B0e%20%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%A0%E4%BB%A5%E8%87%AA%E7%84%B6%E4%BA%8C%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p> $\pi$ 应该是我们最熟悉的数学常数了，但是除了 $\pi$ 以外，还有一个数学常数  $e$，它同样重要，同样与我们生活息息相关，甚至被冠名为 <code>自然常数</code>，它是对数函数的底数，有时候也称它为欧拉数（Euler number），以瑞士数学家欧拉命名。</p><p>它的一个数学定义是这样的：<br>$$<br>e = \lim\limits_{n \to \infty} (1+\frac{1}{n})^n<br>$$</p><p>其数值约等于（小数点后25位）： <code>2.71828 18284 59045 23536 02874</code></p><p>相信大家前段时间都玩过或听过《荒野乱斗》这个游戏，我司前端大佬 Fred 哥也一直在为升杯而努力，玩这个游戏很大的一个动力是攒个宝箱开个英雄出来。</p><p><img src="https://cdn.jsdelivr.net/gh/zhenwanping/cdn-assets@master/photo/20201116095953.png" alt="荒野乱斗超级宝箱"></p><p>假设现在有一个超级宝箱，它开出英雄的概率是 0.1%（1/1000），千分之一。我们的 Fred 哥又很有钱，那他氪金氪它个 1000 发，是不是一定能开出个英雄来？基于我们的数学常识，明显不是的。</p><p>那么我们可不可以求一下 Fred 哥倒霉的概率呢？他买了 1000 个超级宝箱，一个英雄都没开出的概率是多少呢？</p><p>一个超级宝箱，它开出英雄的概率是 0.1%（1/1000），那开不出英雄的概率就是：<br>$$<br>1-\frac{1}{1000}<br>$$<br>第一次开不中概率是 $(1-\frac{1}{1000})$，那两次开不中的概率是 $(1-\frac{1}{1000})(1-\frac{1}{1000})$ ，以此类推，那开 1000 个宝箱都不中的概率是：<br>$$<br>(1-\frac{1}{1000})^{1000} \approx 0.36769542477096404462680613922046134399<br>$$<br>乍一看，好像跟我们的 $e$ 没啥联系啊。</p><p>但是如果我们把 <code>0.367695424770964044626...</code> 这个值倒转一下：<br>$$<br>\frac{1}{0.367695424770964044626..} \approx 2.71964221644285036539755346440401494764<br>$$<br>怎么样？结果的 <code>2.719642216442...</code> 这个数值是不是似曾相识？这非常接近我们的自然常数  $e$ 的值。</p><p>如果宝箱开出英雄的概率变成 0.01%，万分之一，Fred 哥买的宝箱数目也增大到一万个，那这个值又会如何变化呢：<br>$$<br>(1-\frac{1}{10000})^{10000} \approx 0.3678610464329299241113356722185087445<br>$$</p><p>$$<br>\frac{1}{0.3678610464329299241113356722185087445} \approx 2.7184177550104492651837311208355930494<br>$$</p><p>如果继续将开出英雄的概率变低，Fred 哥买的宝箱数目也相应变大，最后结果是怎样的呢？我们先构造这样一个式子来计算：<br>$$<br>\frac{1}{(1-\frac{1}{n})^n}<br>$$<br>接着利用 Swift Playground 来计算其结果，观察随着 n 变大，最后的结果是怎样变化的：</p><p><img src="https://cdn.jsdelivr.net/gh/zhenwanping/cdn-assets@master/photo/20201111105035.png" alt="SwiftPlayground计算截图"></p><p>我们可以发现，随着 n 越来越大，最后的值会越来越接近 $e$ 的值！我们可以用下面这个极限的式子表示：<br>$$<br>\lim\limits_{n \to \infty} (1-\frac{1}{n})^n = \frac{1}{e}<br>$$<br>扩展一下：</p><p>如果我们把前面说到的超级宝箱例子，具象成一个装满球的箱子，假设箱子里有 1000 个球，我们每次有放回地抽取一个球，抽取 1000 次，那么最后没有被抽到的球大概有多少个呢？答案是 368 个。</p><p>这里的计算其实与上面的几乎一样，求出没有被抽到球的概率，然后乘以球的总数：<br>$$<br>(1-\frac{1}{1000})^{1000} \approx 0.368<br>$$</p><p>$$<br>1000 \times 0.368 = 368<br>$$</p><p>这个在统计学上，这个其实叫做<code>自助抽样法(Bootstrapping Method)</code> : 是一种从给定训练集中有放回的均匀抽样，也就是说，每当选中一个样本，它等可能地被再次选中并被再次添加到训练集中。</p><blockquote><p>从数量为 N 的样本中「有放回地」随机抽取出一个「数量同样为N」的样本，那么理论上来说，原来的 N 个个体中大约会有 <code>36.8%</code> 的个体不会被抽中。（引用<a href="https://www.zhihu.com/question/20296247" target="_blank" rel="noopener">来源</a>）</p></blockquote><p> 这种抽样方法已经应用在很多领域，比如在机器学习领域，大家都略有耳闻的 <code>随机森林</code> 算法，就是在训练集中利用这种抽样方式，从原始训练样本集 N 中有放回地重复随机抽取 N 个样本生成新的训练样本集合训练决策树，然后没有被抽中的 36.8% 作为 Out of Bag 数据集训练，即袋外误差来验证决策树。具体就不展开讲了，因为我也不是很懂 :-)</p><p>我们回到 Fred 哥身上，前文提到 Fred 哥很有钱，但是有一天 Fred 哥居然找我借了 100 块钱，我很无耻地定了 100% 的年息利率。也就是一年后我可以得到 200 块：<br>$$<br>100 \times (1 + 100\%) = 200<br>$$<br>但是这时候我想起了复利的概念，如果仍然保持 100% 的年利率，但是我半年结一次息，把得到的利息和加入100块里，让它利滚利，也就是说每半年的利率为 $\frac{100\%}{2} = 50\%$ 那这样的话，一年后我可以得到 225 块：<br>$$<br>100 \times (1+\frac{100\%}{2}） \times (1+\frac{100\%}{2}) = 225<br>$$<br>看起来复利真不错啊！丧心病狂的我决定从半年结一次息改成每个季度结一次息，一年后我可以得到 244 块：<br>$$<br>100 \times (1+\frac{100\%}{4})^4 \approx 244<br>$$<br>太棒了，又多了点钱，贪得无厌的我决定每个月结一次息，不，我要每天结一次息，我要半天结一次息，我要每小时结一次息，我要每分钟结一次息，我要每秒结一次息…… 被连续复利冲昏头脑的我想着这次要彻底榨干 Fred 哥！兴奋的我，又打开了 Swift Playground，喜滋滋地让程序帮我算出最后能得多少钱：</p><p><img src="https://cdn.jsdelivr.net/gh/zhenwanping/cdn-assets@master/photo/20201111162711.png" alt="SwiftPlayground计算复利"></p><p>咦！发生什么情况，怎么随着结息次数的增加，钱怎么都不往上涨了？？而且越来越趋向 271.828 。</p><p>这个数字是不是似曾相识？没错，这个值就是 $e \approx 2.71828$ 乘以 100 所得到，也就是不管结息次数怎么增大，最后得到的钱也只能是 $e$ 倍！因此也有人说 $e$ 是在一个特定周期内的增长极限。</p><p>这里我们祭出一个关于极限的公式：<br>$$<br>\lim\limits_{n \to \infty} (1+\frac{1}{n})^n = e<br>$$</p><p>通过上面的例子，大家应该能体会 $e$ 是多么神奇的一个数学常数。$e$ 在我们生活中可以说无处不在，除了这些纯数学上的例子外，自然界中很多东西也和 $e$ 有关。比如等角螺线，或者称对数螺线、生长螺线。</p><p><img src="https://cdn.jsdelivr.net/gh/zhenwanping/cdn-assets@master/photo/20201117152859.png" alt="等角螺线图片"></p><p>它是自然界中常见的螺线，在极坐标系 $(r, \theta)$ 中，这个曲线的公式可以写成：<br>$$<br>r = ae^{b\theta}<br>$$<br>从公式可以看到，我们的 $e$ 又出现了。还真的是无处不在啊。</p><p>下面举一下自然界中的例子（来自维基百科：<a href="https://zh.wikipedia.org/wiki/%E7%AD%89%E8%A7%92%E8%9E%BA%E7%BA%BF" target="_blank" rel="noopener">等角螺线</a>）：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>鹦鹉螺的贝壳像等角螺线</td><td><img src="https://cdn.jsdelivr.net/gh/zhenwanping/cdn-assets@master/photo/20201111165255.png" alt="鹦鹉螺等角螺线"></td></tr><tr><td>菊的花蕊排列成等角螺线</td><td><img src="https://cdn.jsdelivr.net/gh/zhenwanping/cdn-assets@master/photo/20201111165449.png" alt="菊花种子"></td></tr><tr><td>鹰以等角螺线的方式接近它们的猎物</td><td></td></tr><tr><td>昆虫以等角螺线的方式接近光源</td><td></td></tr><tr><td>蜘蛛网的构造与等角螺线相似</td><td><img src="https://cdn.jsdelivr.net/gh/zhenwanping/cdn-assets@master/photo/20201111165605.png" alt="蜘蛛网的构造与等角螺线相似"></td></tr><tr><td>旋涡星系的旋臂差不多是等角螺线。银河系的四大旋臂的倾斜度约为 12°。</td><td><img src="https://cdn.jsdelivr.net/gh/zhenwanping/cdn-assets@master/photo/20201111170543.png" alt="旋涡星系的旋臂"></td></tr><tr><td>低气压(热带气旋、温带气旋等)的外观像等角螺线</td><td><img src="https://cdn.jsdelivr.net/gh/zhenwanping/cdn-assets@master/photo/20201111170713.png" alt="低气压(热带气旋、温带气旋等)"></td></tr></tbody></table><p>最后点一下题吧，这些自然的现象，都与等角螺线有关，也就是都跟我们的自然常数 $e$ 有关。小至游戏宝箱，大至宇宙星系，都有 $e$ 存在的身影。$e$ 称之为自然常数，当之无愧。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么OpenGL里旋转等变换矩阵是4x4的矩阵</title>
      <link href="/2020/10/23/%E4%B8%BA%E4%BB%80%E4%B9%88OpenGL%E9%87%8C%E6%97%8B%E8%BD%AC%E7%AD%89%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E6%98%AF4x4%E7%9A%84%E7%9F%A9%E9%98%B5/"/>
      <url>/2020/10/23/%E4%B8%BA%E4%BB%80%E4%B9%88OpenGL%E9%87%8C%E6%97%8B%E8%BD%AC%E7%AD%89%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E6%98%AF4x4%E7%9A%84%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<p>OpenGL ES 的很多教程里都会有这样一个例子来讲解纹理：将一张图片作为纹理显示在屏幕上。</p><p>因为纹理坐标和实际屏幕显示的坐标不一样，把图片渲染在屏幕上后，图片是上下颠倒的。</p><p>一个解决方法是对当前的顶点坐标，乘以绕 z 轴旋转180度的矩阵，这样图片就能正确显示了。</p><p>$$<br>\begin{bmatrix}<br>cos\theta &amp; -sin\theta &amp; 0 &amp; 0 \\ sin\theta &amp; cos\theta &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \<br>\end{bmatrix}<br>$$</p><p>那么如何理解这个旋转矩阵呢？</p><p>影响我们理解这个矩阵的第一个问题是：</p><p><strong>为什么这个矩阵是 4x4 的？</strong> 而且我们发现旋转，缩放、平移等变换矩阵都是 4x4 的。</p><p>在直观上的认知里，表达一个三维空间的坐标用 x,y,z 就足够了，那在三维空间里进行矩阵变换，用 3x3 的矩阵就够了，为什么需要 4x4 呢？</p><p>为了回答这个问题，下面我们先在几何意义上理解<strong><u>向量和矩阵</u></strong>之间的关系，然后通过<strong><u>推导旋转矩阵</u></strong>和<u><strong>平移矩阵</strong></u>，一步步来解开这个疑惑。</p><h2 id="向量和矩阵"><a href="#向量和矩阵" class="headerlink" title="向量和矩阵"></a>向量和矩阵</h2><p>在几何平面上，我们可以把平面上任意一<code>点</code>，当作<u>与原点组成</u>的一个 <code>向量</code> 来理解。</p><p>如图 ，A 点可以表示成向量  $\vec{OA}$  ；在 x 轴和 y 轴上各有 i 点（1， 0）和  j 点（0，1），同样的，让它们与原点组成向量，为了简化，我们用  $\vec{i}$  和 $\vec{j}$ 表示这两个向量。</p><p><img src="https://cdn.jsdelivr.net/gh/zhenwanping/cdn-assets@master/photo/20201022184245.png" alt="image-20201022184243547"></p><p>因为 A 点的坐标为 (3, 2)，如果我们要用  $\vec{i}$  和 $\vec{j}$  表示 $\vec{OA}$ ，那是这样的：<br>$$<br>3\vec{i} + 2\vec{j} = \vec{OA}<br>$$<br>这里的几何意义是 $\vec{i}$ 延展到 $3\vec{i}$  ，$\vec{j}$ 延展到 $2\vec{j}$ ，然后把这两个向量相加即可得到 $\vec{OA}$</p><p>i  坐标是 （1， 0），j 坐标是 （0，1），我们把上面这个等式转换成竖列的形式：<br>$$<br>3<br>\begin{bmatrix}1\\0\end{bmatrix}<br>+<br>2<br>\begin{bmatrix}<br>0\\1<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>3 \\ 2<br>\end{bmatrix}<br>$$<br>这里其实是向量的简单运算，运算过程如下：<br>$$<br>\begin{bmatrix}<br>3 \times  1 \\ 3 \times 0<br>\end{bmatrix}<br>+<br>\begin{bmatrix}<br>2 \times 0\\2 \times 1<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>3 \times 1 + 2 \times 0\\3 \times 0 + 2 \times 1<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>3\\2<br>\end{bmatrix}<br>$$<br>看到运算过程是否有种似曾相识的感觉？这不就是矩阵与向量的乘法计算吗？这个运算其实就是将<code>向量左乘一个矩阵</code> 的计算：<br>$$<br>\begin{bmatrix}<br>1 &amp; 0\\0 &amp; 1<br>\end{bmatrix}<br>\begin{bmatrix}<br>3\\2<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>3 \times 1 + 2 \times 0 \\3 \times 0 + 2 \times 1<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>3 \\ 2<br>\end{bmatrix}<br>$$<br>这里 $\begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 1 \end{bmatrix}$  其实就是<code>单元矩阵</code>，左乘一个单元矩阵并不会改变原来的值。而这个单元矩阵以两个竖列来看，<strong>正是 i 和 j 点的坐标</strong>，也是向量  $\vec{i}$  和  $\vec{j}$ ，在数学上将  $\vec{i}$  和  $\vec{j}$  称为此坐标系的 <code>基向量</code>。</p><h2 id="推导旋转矩阵"><a href="#推导旋转矩阵" class="headerlink" title="推导旋转矩阵"></a>推导旋转矩阵</h2><p>我们现在把整个坐标轴绕原点逆时针旋转  $45^o$ ：</p><p><img src="https://cdn.jsdelivr.net/gh/zhenwanping/cdn-assets@master/photo/20201022220658.png" alt="image-20201022220656758"></p><p>旋转后  i 点和 j 点对应  $i^\prime$  和  $j^\prime$ 位置。</p><p>通过简单的三角函数计算得到： $i^\prime$ 坐标为 $\begin{bmatrix}cos45^o \\ sin45^o\end{bmatrix}$ ，$j^\prime$ 坐标为 $\begin{bmatrix} -sin45^o \\ cons45^o \end{bmatrix}$</p><p>旋转后，A 点的坐标是多少呢？回顾上面的做法， $\vec{i^\prime}$ 延展到 $3\vec{i^\prime}$  ，$\vec{j^\prime}$ 延展到 $2\vec{j^\prime}$ ，然后把这两个向量相加即可得到 $\vec{OA^\prime}$ 。结合上面一节矩阵和向量的推演，可以变成下面的形式：<br>$$<br>\begin{bmatrix}<br>cos45^o &amp; -sin45^o \\sin45^o &amp; cos45^o<br>\end{bmatrix}<br>\begin{bmatrix}<br>3 \\ 2<br>\end{bmatrix}<br>$$<br>我们发现，左边的矩阵不正是开头所看到的 <code>旋转矩阵</code> 吗？只不过这是二维平面上的旋转矩阵:<br>$$<br>\begin{bmatrix}<br>cos\theta &amp; -sin\theta \\sin\theta &amp; cos\theta<br>\end{bmatrix}<br>$$<br>结合图形和计算，我们可以这样理解这个二维矩阵：二维矩阵代表一个坐标系里的两个基向量，而在这个坐标系里的点与原点组成的向量，都可以用这两个基向量的变换来表示。那么旋转一个点，可以转换成旋转这个点所在的坐标系，从而通过变化的基向量求出旋转后的点的位置。</p><p>其实这种变换在数学上称作 <code>线性变换</code> ，线性变换是通过 <code>矩阵乘法</code> 来实现</p><blockquote><p><strong>线性变换</strong>：是在两个<a href="https://zh.wikipedia.org/wiki/向量空间" target="_blank" rel="noopener">向量空间</a>（包括由函数构成的抽象的向量空间）之间的一种保持向量加法和标量乘法的特殊映射</p></blockquote><blockquote><p>线性变换在几何直观上有如下特点：</p><ul><li><p>变换前后，直线仍然保持是直线的状态</p></li><li><p>变换前后，原点保持固定，不会变化</p></li></ul></blockquote><p>我们从二维平面，推导到三维坐标也是同理，只不过是多了个 z 轴<br>$$<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$$<br>竖着来看这个矩阵，是 x，y，z轴上的三个基向量，同时它又是一个单元矩阵。</p><p>同理上面二维平面的推导，三维坐标绕 z 轴的旋转矩阵为：<br>$$<br>\begin{bmatrix}<br>cos\theta&amp;-sin\theta&amp;0\\sin\theta&amp;cos\theta&amp;0\\0&amp;0&amp;1<br>\end{bmatrix}<br>$$</p><h2 id="推导平移矩阵"><a href="#推导平移矩阵" class="headerlink" title="推导平移矩阵"></a>推导平移矩阵</h2><p>那么平移操作，能不能也用这种矩阵与向量相乘的形式呢？我们再次回到二维平面，看看将 A 点平移到 B 点的情况是怎样的。</p><img src="https://cdn.jsdelivr.net/gh/zhenwanping/cdn-assets@master/photo/20201022222202.png" alt="image-20201022222139291" style="zoom: 33%;" /><p>要将 A 点（3，2）平移到 B 点(4，5)，实际上就是先将 A 点往右移动 1 ，再往上移动 3，即 x 坐标值增加 1，y坐标值增加 3<br>$$<br>\begin{bmatrix}<br>x + 1 \\ y + 3<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>x \\ y<br>\end{bmatrix}<br>+<br>\begin{bmatrix}<br>1 \\ 3<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>3 + 1 \\ 2 + 3<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>4 \\ 5<br>\end{bmatrix}<br>$$<br>从上面的运算来看，平移这种操作实际上是 <code>向量的加法</code>，即:<br>$$<br>\vec{OA} + \vec{OC} = \vec{OB}<br>$$</p><p>$$<br>\begin{bmatrix} 3 \\ 2 \end{bmatrix} + \begin{bmatrix} 1 \\ 3 \end{bmatrix}=\begin{bmatrix} 4 \\ 5 \end{bmatrix}<br>$$</p><p>我们可以通过向量加法的 <code>平行四边形法则</code> 加深理解，如下图：</p><img src="https://cdn.jsdelivr.net/gh/zhenwanping/cdn-assets@master/photo/20201022223037.png" alt="image-20201022223035113" style="zoom:50%;" /><p>对于平移这种操作，<strong>我们无法仅仅通过矩阵乘法来实现</strong>。</p><p>而实际上，平移这种操作属于 <code>仿射变换</code> 。</p><blockquote><p><strong>仿射变换</strong>，又称<strong>仿射映射</strong>，是指在几何中，对一个向量空间进行一次<a href="https://zh.wikipedia.org/wiki/线性变换" target="_blank" rel="noopener">线性变换</a>并接上一个平移，变换为另一个向量空间。</p></blockquote><p>仿射变换在几何直观上，相比线性变换，它不需要保证变换前后坐标原点不变。</p><p>如下图，从 A 点平移到 B 点，我们换一个角度思考，这次不移动点，而是<code>移动整个坐标轴</code>，同样可以达到平移 A 点到 B 点的需求，但是坐标原点移动到了 O’ 点（1，3）。</p><img src="https://cdn.jsdelivr.net/gh/zhenwanping/cdn-assets@master/photo/20201022230510.png" alt="image-20201022230432040" style="zoom: 33%;" /><p>我们希望构造的是像下面这种矩阵乘法的等式，这样才能用一个通用的计算模式来处理坐标点的变换。<br>$$<br>\begin{bmatrix}<br>矩阵<br>\end{bmatrix}<br>\begin{bmatrix}<br>3\\2<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>4\\5<br>\end{bmatrix}<br>$$<br>到这里，我们终于要请出 <code>齐次坐标</code> 了。</p><blockquote><p>齐次坐标就是将一个原本是 n 维的向量用一个 n+1 维向量来表示，是指一个用于投影几何里的坐标系统，如同用于欧氏几何里的笛卡儿坐标一般。</p></blockquote><p>用一个通俗的讲法是，我们需要 <code>升维</code> 来处理这个问题。</p><blockquote><p>通过增加一个维度，我们可以在<code>高维度</code>上，通过线性变换来处理<code>低维度</code>的仿射变换。</p></blockquote><p>这句话咋一听感觉很有哲理，但是通过下面的数学等式就能知道其中的奥妙：<br>$$<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 1 \\0 &amp; 1 &amp; 3 \\0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>\begin{bmatrix}<br>3 \\ 2 \\ 1<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>1 \times 3 + 0 \times 2 + 1 \times 1 \\0 \times 3 + 1 \times 2 + 3 \times 1 \\0 \times 3 + 0 \times 2 + 1 \times 1<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>4 \\ 5 \\ 1<br>\end{bmatrix}<br>$$<br>观察上面的运算过程，结果 $\begin{bmatrix}4\\5\\1 \end{bmatrix}$ 不正是我们上面所得的 $\begin{bmatrix} 4\\5 \end{bmatrix}$ 吗？只不过多了一个 z 轴的坐标值。</p><p>我们通过升级一个维度，将在二维平面上的平移问题转换成了在三维坐标的矩阵和向量乘法。那么在二维平面上，这个平移矩阵就为：<br>$$<br>\begin{bmatrix}<br>1 &amp; 0 &amp; tx \\0 &amp; 1 &amp; ty \\0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$$<br>tx 和 ty 就对应在 x 轴 和 y 轴上的移动距离。</p><p>同理推广到三维坐标系，要实现三维坐标的平移操作，同样需要通过升维，引入齐次坐标来计算。那么三维坐标下的平移矩阵就为：<br>$$<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; tx \\0 &amp; 1 &amp; 0 &amp; ty \\0 &amp; 0 &amp; 1 &amp; tz \\0 &amp; 0 &amp; 0 &amp; 1 \<br>\end{bmatrix}<br>$$</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们可以回答最开始的问题了，为什么 OpenGL 里的矩阵变换是 4x4 的矩阵呢？</p><p>我们来想象这样一个场景：如果我要让顶点坐标旋转一定角度后，再平移一段距离，那么这里面的操作就涉及 3x3 矩阵的计算和 4x4 矩阵的计算，如果不统一起来，这种连续变换的计算操作将很复杂。</p><p>所以如果要用矩阵乘法来统一所有的平移、旋转等等变换计算，为了照顾到平移这类仿射变换，统一用 4x4 矩阵来计算既能满足场景又方便计算。</p>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenGLES和Swift实现全景图浏览(全景球,360度浏览,小行星)</title>
      <link href="/2020/09/12/OpenGLES%E5%92%8CSwift%E5%AE%9E%E7%8E%B0%E5%85%A8%E6%99%AF%E5%9B%BE%E6%B5%8F%E8%A7%88(%E5%85%A8%E6%99%AF%E7%90%83,360%E5%BA%A6%E6%B5%8F%E8%A7%88,%E5%B0%8F%E8%A1%8C%E6%98%9F)/"/>
      <url>/2020/09/12/OpenGLES%E5%92%8CSwift%E5%AE%9E%E7%8E%B0%E5%85%A8%E6%99%AF%E5%9B%BE%E6%B5%8F%E8%A7%88(%E5%85%A8%E6%99%AF%E7%90%83,360%E5%BA%A6%E6%B5%8F%E8%A7%88,%E5%B0%8F%E8%A1%8C%E6%98%9F)/</url>
      
        <content type="html"><![CDATA[<p>最近在学习 OpenGLES，其实也就学到纹理那里，所以想着做个小项目来巩固一下知识。而一个全景浏览器正好囊括顶点坐标，纹理坐标，索引绘图，MVP 矩阵变换等等知识，是一个很不错的练手项目。我选择用 Swift 来写，当然用 Swift 会相对麻烦一点，特别是在处理指针方面。我同时写了两种实现方式，一种是基于 iOS 封装的 GLKit，一种则是用 GLSL 来写，具体实现请查看 <a href="https://github.com/zyphs21/HSGLPanoViewer" target="_blank" rel="noopener">源码-HSGLPanoViewer</a>。</p><img src="https://cdn.jsdelivr.net/gh/zhenwanping/cdn-assets@master/photo/20200912200148.jpg" alt="ScreentShot" style="zoom:50%;" /><a id="more"></a><h2 id="全景浏览器实现思路"><a href="#全景浏览器实现思路" class="headerlink" title="全景浏览器实现思路"></a>全景浏览器实现思路</h2><p>实现思路其实挺简单的，首先我们需要计算出一个球的顶点坐标（这里还包括纹理坐标和索引数组的计算），然后把全景图以纹理的形式贴在这个球上，剩下的事情都是 MVP 矩阵的魔法了。</p><h3 id="球的顶点坐标，纹理坐标，索引数组"><a href="#球的顶点坐标，纹理坐标，索引数组" class="headerlink" title="球的顶点坐标，纹理坐标，索引数组"></a>球的顶点坐标，纹理坐标，索引数组</h3><p>对于一个球，通过圆柱投影方式我们可以把它剥开成一个长方形，然后对其进行切割成一块一块的小长方形，而这些长方形的顶点则相当于组成球的坐标。</p><img src="https://cdn.jsdelivr.net/gh/zhenwanping/cdn-assets@master/photo/20200912191614.png" alt="image-20200912191316204" style="zoom: 33%;" /><p>OpenGLES 里只能通过三角形来绘制，一个长方形可以以对角线分成两个三角形，而当为了便于绘制，需要有一个索引数组来表示哪几个点是组成一个三角形。</p><img src="https://cdn.jsdelivr.net/gh/zhenwanping/cdn-assets@master/photo/20200912191630.png" alt="image-20200912191415072" style="zoom:50%;" /><p>关于这块的计算我们可以参考 <a href="https://book.douban.com/subject/25845921/" target="_blank" rel="noopener">《OpenGL ES 3.0 Programming Guide》</a> 里有关于球坐标的<a href="https://github.com/danginsburg/opengles3-book/blob/master/Common/Source/esShapes.c" target="_blank" rel="noopener">示例代码-esShapes.c</a>，这里贴一下我用 Swift 的实现代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> vertices = [<span class="type">GLfloat</span>]() <span class="comment">// 顶点坐标，包含纹理坐标</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> <span class="built_in">indices</span> = [<span class="type">GLushort</span>]() <span class="comment">// 索引坐标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">generateSphereVertices</span><span class="params">(slice: Int, radius: Float)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> parallelsNum = slice / <span class="number">2</span></span><br><span class="line">        <span class="keyword">let</span> verticesNum = (parallelsNum + <span class="number">1</span>) * (slice + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">let</span> indicesNum = parallelsNum * slice * <span class="number">6</span></span><br><span class="line">        <span class="keyword">let</span> angleStep = (<span class="number">2</span> * <span class="type">Float</span>.pi) / <span class="type">Float</span>(slice)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顶点坐标和纹理坐标，乘以 5 代表顶点坐标 x,y,z 分量和纹理坐标的 u,v 分量</span></span><br><span class="line">        <span class="keyword">var</span> vertexArray: [<span class="type">GLfloat</span>] = <span class="type">Array</span>(repeating: <span class="number">0</span>, <span class="built_in">count</span>: verticesNum * <span class="number">5</span>)</span><br><span class="line">        <span class="comment">// 顶点坐标索引数组</span></span><br><span class="line">        <span class="keyword">var</span> vertexIndexArray: [<span class="type">Int</span>] = <span class="type">Array</span>(repeating: <span class="number">0</span>, <span class="built_in">count</span>: indicesNum)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 顶点坐标公式</span></span><br><span class="line"><span class="comment">         x = r * sin α * sin β</span></span><br><span class="line"><span class="comment">         y = r * cos α</span></span><br><span class="line"><span class="comment">         z = r * sin α * cos β</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;(parallelsNum + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..&lt;(slice + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> vertexIndex = (i * (slice + <span class="number">1</span>) + j) * <span class="number">5</span></span><br><span class="line">                vertexArray[vertexIndex + <span class="number">0</span>] = (radius * sinf(angleStep * <span class="type">Float</span>(i)) * sinf(angleStep * <span class="type">Float</span>(j)))</span><br><span class="line">                vertexArray[vertexIndex + <span class="number">1</span>] = (radius * cosf(angleStep * <span class="type">Float</span>(i)))</span><br><span class="line">                vertexArray[vertexIndex + <span class="number">2</span>] = (radius * sinf(angleStep * <span class="type">Float</span>(i)) * cosf(angleStep * <span class="type">Float</span>(j)))</span><br><span class="line">                </span><br><span class="line">                vertexArray[vertexIndex + <span class="number">3</span>] = <span class="type">Float</span>(j) / <span class="type">Float</span>(slice)</span><br><span class="line">                vertexArray[vertexIndex + <span class="number">4</span>] = <span class="type">Float</span>(<span class="number">1.0</span>) - (<span class="type">Float</span>(i) / <span class="type">Float</span>(parallelsNum))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> vertexIndexTemp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;parallelsNum &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..&lt;slice &#123;</span><br><span class="line">                vertexIndexArray[<span class="number">0</span> + vertexIndexTemp] = i * (slice + <span class="number">1</span>) + j</span><br><span class="line">                vertexIndexArray[<span class="number">1</span> + vertexIndexTemp] = (i + <span class="number">1</span>) * (slice + <span class="number">1</span>) + j</span><br><span class="line">                vertexIndexArray[<span class="number">2</span> + vertexIndexTemp] = (i + <span class="number">1</span>) * (slice + <span class="number">1</span>) + (j + <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">                vertexIndexArray[<span class="number">3</span> + vertexIndexTemp] = i * (slice + <span class="number">1</span>) + j</span><br><span class="line">                vertexIndexArray[<span class="number">4</span> + vertexIndexTemp] = (i + <span class="number">1</span>) * (slice + <span class="number">1</span>) + (j + <span class="number">1</span>)</span><br><span class="line">                vertexIndexArray[<span class="number">5</span> + vertexIndexTemp] = i * (slice + <span class="number">1</span>) + (j + <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">                vertexIndexTemp += <span class="number">6</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.vertices = vertexArray</span><br><span class="line">        <span class="keyword">self</span>.<span class="built_in">indices</span> = vertexIndexArray.<span class="built_in">map</span> &#123; <span class="type">GLushort</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="MVP-矩阵"><a href="#MVP-矩阵" class="headerlink" title="MVP 矩阵"></a>MVP 矩阵</h3><p>MVP 矩阵即：</p><ul><li>模型矩阵（Model Matrix）</li><li>视图矩阵（View Matrix）</li><li>投影矩阵（Projection Matrix）</li></ul><p>通过这三个矩阵，就能实现全景球、360度浏览和小行星三种视角。首先我们得知道 OpenGLES 是右手坐标系，我们面向手机屏幕，X轴正方向在右边，Y轴正方向在上边，原点在手机屏幕中心，而 Z 轴的正方向从屏幕中心指向我们自己。</p><img src="https://cdn.jsdelivr.net/gh/zhenwanping/cdn-assets@master/photo/20200912191907.png" alt="image-20200912180100001" style="zoom: 33%;" /><ol><li><p>全景球</p><p>全景球是最简单的，我们只需要把球体放置在坐标系原点，然后我们的视角(即相机位置)，放置在 z 轴上，同时需要大于球的半径，就能看到完整的球体。</p></li><li><p>360度浏览</p><p>要想实现 360度环绕浏览，全景球还是放置在原点，把我们的视角放置在球体里面，那么我们就能 360 度环绕查看全景图了。所以我们的相机位置放在 z 轴上比球的半径小即可。</p></li><li><p>小行星</p><p>小行星的效果需要与投影矩阵配合，当然上面的两种方式也需要投影矩阵配合，只是在小行星效果这里，投影的 FOV 比前两种的大，有种贴近球体看的感觉，所以我们的摄像机视角需要放置在刚刚好球的半径上。可以想象成我们在球体挖了个小孔，眼睛往里面看的样子。</p></li></ol><blockquote><p> 具体实现可以查看源码里的 <a href="https://github.com/zyphs21/HSGLPanoViewer/blob/master/HSGLPanoViewer/ViewTransform.swift" target="_blank" rel="noopener">ViewTransform.swift</a></p></blockquote><h2 id="经验和踩坑分享"><a href="#经验和踩坑分享" class="headerlink" title="经验和踩坑分享"></a>经验和踩坑分享</h2><h3 id="去除-GLKit-API-弃用警告"><a href="#去除-GLKit-API-弃用警告" class="headerlink" title="去除 GLKit API 弃用警告"></a>去除 GLKit API 弃用警告</h3><blockquote><p>‘GLKViewController’ was deprecated in iOS 12.0: OpenGLES API deprecated. (Define GLES_SILENCE_DEPRECATION to silence these warnings)</p></blockquote><p><code>GLKit</code> 相关的 API 从 iOS12 之后就已经标记为<code>弃用</code>了。</p><p>为了避免 Xcode 满屏的黄色警告⚠️，我们在 <code>Project--Build Settings</code> 里找到 <code>Preprocessor Macros</code> ，然后配置 <code>GLES_SILENCE_DEPRECATION=1</code> 即可把 OpenGLES 相关的弃用 API 警告去掉。这样 Xcode 的编辑界面就清爽很多了。</p><p><img src="https://cdn.jsdelivr.net/gh/zhenwanping/cdn-assets@master/photo/20200912191829.png" alt="image-20200912114634891"></p><h3 id="注意索引数组类型"><a href="#注意索引数组类型" class="headerlink" title="注意索引数组类型"></a>注意索引数组类型</h3><p>在最后让 OpenGLES 进行绘图时，都会调用 <code>glDrawElements</code> 方法:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDrawElements(<span class="type">GLenum</span>(<span class="type">GL_TRIANGLES</span>), <span class="type">GLsizei</span>(vertexIndices.<span class="built_in">count</span>), <span class="type">GLenum</span>(<span class="type">GL_UNSIGNED_SHORT</span>), <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>这个方法的第三个参数是告诉 OpenGLES 当前索引数组的类型，比如上面指定的是 <code>GL_UNSIGNED_SHORT</code> 类型，所以我们的索引数组必须定义成是 <code>[GLushort]</code> 即数组里面的元素是 <code>UInt16</code> ，我们可以点击 GLushort 的定义是 <code>public typealias GLushort = UInt16）</code></p><p>这里我当初很傻地犯了一个错误是：我点击 <code>GL_UNSIGNED_SHORT</code> 进去查看它的定义是 <code>public var GL_UNSIGNED_SHORT: Int32 { get }</code> ，然后下意识认为索引数组的元素类型是 <code>Int32</code> ，结果导致最后效果怎么都不对，最后才发现是这里被绕晕了。</p><h3 id="数组所占内存大小"><a href="#数组所占内存大小" class="headerlink" title="数组所占内存大小"></a>数组所占内存大小</h3><p>OpenGLES 里有些方法是需要传递数值所占的内存大小。比如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将顶点数组复制到 GPU 中的顶点缓存区</span></span><br><span class="line">glBufferData(<span class="type">GLenum</span>(<span class="type">GL_ARRAY_BUFFER</span>), vertices.size(), vertices, <span class="type">GLenum</span>(<span class="type">GL_STATIC_DRAW</span>))</span><br></pre></td></tr></table></figure><p>这里我给 Array 添加了一个扩展方法，能够比较方便地获取到数组实际所占内存的大小：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 根据数组类型和长度获取数组实际内存空间大小(Bytes)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">size</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">MemoryLayout</span>&lt;<span class="type">Element</span>&gt;.<span class="built_in">stride</span> * <span class="keyword">self</span>.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="矩阵的构建"><a href="#矩阵的构建" class="headerlink" title="矩阵的构建"></a>矩阵的构建</h3><p>矩阵的构建和计算是一个较为复杂的部分，所以最好是把它交给程序。</p><p>GLKit 中提供了不少便捷的类和方法，比如 </p><ul><li><p><code>GLKMatrix4MakeLookAt</code> ：构建摄像机视图矩阵</p></li><li><p><code>GLKMatrix4MakePerspective</code> : 构建投影视图矩阵</p></li><li><p><code>GLKMatrix4Multiply</code> : 用于矩阵的相乘</p></li><li><p><code>GLKMatrix4RotateX</code> : 绕 x 轴旋转的旋转矩阵</p><p>……</p></li></ul><p>利用这些方法在 GLKit 的实现中很方便，但是如何扩展利用在 GLSL 的实现呢？这里贴一下更新 MVP 矩阵的代码: </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">updateMVPMatrix</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> modelViewMatrix = <span class="type">GLKMatrix4Identity</span></span><br><span class="line">        modelViewMatrix = <span class="type">GLKMatrix4RotateX</span>(modelViewMatrix, xAxisRotate)</span><br><span class="line">        modelViewMatrix = <span class="type">GLKMatrix4RotateY</span>(modelViewMatrix, yAxisRotate)</span><br><span class="line">        modelViewMatrix = <span class="type">GLKMatrix4Multiply</span>(panoViewType.viewTransform.viewMatrix, modelViewMatrix)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> width = frame.size.width * <span class="type">UIScreen</span>.main.scale</span><br><span class="line">        <span class="keyword">let</span> height = frame.size.height * <span class="type">UIScreen</span>.main.scale</span><br><span class="line">        <span class="keyword">let</span> aspect = <span class="type">GLfloat</span>(width / height)</span><br><span class="line">        <span class="keyword">let</span> projectionMatrix = panoViewType.viewTransform.projectionMatrix(aspect: aspect)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最终的 MVP 矩阵</span></span><br><span class="line">        <span class="keyword">var</span> mvpMatrix = <span class="type">GLKMatrix4Multiply</span>(projectionMatrix, modelViewMatrix)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里取出 mvpMatrix.m 的指针操作</span></span><br><span class="line">        <span class="keyword">let</span> components = <span class="type">MemoryLayout</span>.size(ofValue: mvpMatrix.m) / <span class="type">MemoryLayout</span>.size(ofValue: mvpMatrix.m.<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">withUnsafePointer</span>(to: &amp;mvpMatrix.m) &#123;</span><br><span class="line">            $<span class="number">0</span>.withMemoryRebound(to: <span class="type">GLfloat</span>.<span class="keyword">self</span>, capacity: components) &#123;</span><br><span class="line">                glUniformMatrix4fv(glGetUniformLocation(shaderProgram, <span class="string">"mvpMatrix"</span>), <span class="number">1</span>, <span class="type">GLboolean</span>(<span class="type">GL_FALSE</span>), $<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看到，我们通过 <code>GLKMatrix4</code> 的 <code>m</code> 属性拿到矩阵的数组数据，然后用 <code>withUnsafePointer</code>  的方式拿到数组的指针，以完成 <code>glUniformMatrix4fv</code> 的调用。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.opengl-tutorial.org/cn/beginners-tutorials/tutorial-3-matrices/" target="_blank" rel="noopener">OpenGL-Tutorial-矩阵</a></li><li><a href="https://medium.com/@hanton.yang/how-to-create-a-360-video-player-with-opengl-es-3-0-and-glkit-360-3f29a9cfac88" target="_blank" rel="noopener">How to Create a 360 Video Player</a></li><li><a href="https://github.com/danginsburg/opengles3-book" target="_blank" rel="noopener">OpenGLES3-Book</a></li></ul><blockquote><p>欢迎关注我的公众号：HansonTalk<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/qrcode/HansonTalk.jpg" alt=""></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 开源/产品 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PathToGo “没什么卵用” 的更新</title>
      <link href="/2020/06/28/PathToGo%E6%B2%A1%E4%BB%80%E4%B9%88%E5%8D%B5%E7%94%A8%E7%9A%84%E6%9B%B4%E6%96%B0/"/>
      <url>/2020/06/28/PathToGo%E6%B2%A1%E4%BB%80%E4%B9%88%E5%8D%B5%E7%94%A8%E7%9A%84%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<p>PathToGo 是一个可以复制当前选中文件的路径到粘贴板的小 Mac App。具体可以看看之前写的文章 <a href="">《PathToGo诞生记》</a> 。</p><a id="more"></a><h3 id="用户反馈"><a href="#用户反馈" class="headerlink" title="用户反馈"></a>用户反馈</h3><p>PathToGo 解决的是一个很冷门的需求，即便是我，也不会经常用它。甚至很多人觉得它 <code>“没有什么卵用”</code>。但是它仍然收获了一部分用户，甚至还收到用户的反馈：</p><p><img src="https://imgkr.cn-bj.ufileos.com/ccdab9e6-bae4-4fa5-9f4c-a245b16894e7.png" alt=""></p><p>这个用户的需求是希望复制出来的文件路径可以带上 <code>反斜杠转义符</code>，这样他可以直接复制到他的终端里跳转路径使用。</p><p>很明显，这个用户并不知道 <code>Go2Shell</code> ，这款给了 <code>PathToGo</code> 诞生灵感的 App。如果他使用 <code>Go2Shell</code>  的话应该能够很好地解决他真正的需求。</p><h3 id="我的吐槽"><a href="#我的吐槽" class="headerlink" title="我的吐槽"></a>我的吐槽</h3><p>Anyway，既然有用户反馈，我有了一点点更新它的动力。不过最大的动力还是来自于我对 <code>PathToGo</code> 的不满：<strong>它实在太丑了！</strong></p><p>因为 <code>PathToGo</code> 的使用场景，注定它要常驻在 Finder 的 Toolbar 上。而当初在设计图标的时候，脑抽地给它设置了一个<strong>半透明背景</strong> 😂。在 macOS 的浅色模式下还好，但是在深色模式下的样子真的一言难尽：</p><p><img src="https://imgkr.cn-bj.ufileos.com/a416976a-2092-4f0c-801a-057cbfc20a4a.png" alt="浅色模式下显示"></p><p><img src="https://imgkr.cn-bj.ufileos.com/62b41f1b-cbf7-4cce-9b06-0863befd9df6.png" alt="深色模式下显示"></p><p>如上图，真的太丑了！而且图标的大小与 Toolbar 上的其它 icon 相比显得是如此的格格不入。</p><h3 id="重新设计图标"><a href="#重新设计图标" class="headerlink" title="重新设计图标"></a>重新设计图标</h3><p>所以，更新 PathToGo 的首要任务是重新设计图标！</p><p>设计不是我的长项，所以我给自己订的只有两个要求：</p><ol><li>改掉背景色 </li><li>图标尺寸在 Finder 上不要显得那么突兀</li></ol><p>打开 Sketch，一顿操作后，PathToGo 的图标现在长这样了：</p><p><img src="https://imgkr.cn-bj.ufileos.com/8459c5a7-cd62-4bf6-a9d9-a32766274a5c.png" alt="PathToGo图标"></p><p>然后它在 Finder 上是这样子的：</p><p><img src="https://imgkr.cn-bj.ufileos.com/9fd7a8c4-f2ad-4cf5-8587-f139480f978e.png" alt=""></p><p>嗯嗯，看着还可以。</p><p>不过还能更进一步吗？能在好看的同时又能够满足上面用户反馈的需求吗？</p><p>这时候，我发现了一个东西：<strong><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/Finder.html" target="_blank" rel="noopener">FinderSync</a></strong></p><h3 id="用-FinderSync-改造"><a href="#用-FinderSync-改造" class="headerlink" title="用 FinderSync 改造"></a>用 FinderSync 改造</h3><p>FinderSync 是苹果提供的一个扩展功能，它的目的是可以让开发者自定义 Finder 文件的界面，以提示用户文件的监听使用状态等。比如你的 App 可以进行文件同步的功能，你希望让用户知道当前文件是否已经同步完成了，可以通过 FinderSync 这个扩展来给文件添加 icon 以达到提示的作用：</p><p><img src="https://imgkr.cn-bj.ufileos.com/f2ad6a3f-ef5c-4c0d-9ec6-5f78b9774ea3.png" alt=""></p><p>我注意到 FinderSync 可以给 Finder 添加一个原生的 Toolbar！如果 PathToGo 可以做成一个原生样式的 Toolbar 按钮，那不就太完美了吗？</p><p>不过 FinderSync 只支持有下拉选项的 Toolbar 按钮样式，那其实可以将上面用户反馈的功能做到这里：</p><p>点击下拉出两个选项，一个是复制纯文本，一个是复制出带有反斜杠转义的文本。</p><p>这样就既能保留 PathToGo 原有的功能基础上，扩展出了新的功能，尽管与 PathToGo <code>一点击即达</code> 的初衷有点违背，但是我认为这是<strong>在权衡好看和功能性两者之间的最好妥协</strong>。</p><p>于是，PathToGo 在支持原来拖动放置在 Finder Toolbar 的形式的基础上，多了一种以 FinderSync 为踏板的新形式，<strong>终于让它很好地融入了 Toolbar 上</strong>：</p><p><img src="https://imgkr.cn-bj.ufileos.com/51709307-f8e5-4715-90a8-a1eea46296ba.png" alt="PathToGo 在 Finder Toolbar 上"></p><p>添加的方式是：右击 Finder Toolbar 空白处，进入自定义 Toolbar，找到 PathToGo 并拖动添加到 Toolbar 上就可以啦！</p><p><img src="https://imgkr.cn-bj.ufileos.com/464ba02e-a880-425c-8da3-9032d820fd1e.png" alt=""></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>尽管在很多人看来 PathToGo 还是一个没什么卵用的东西，但是这次从出现更新的念头，到最后利用 FinderSync “曲线救国”的实现过程，我是觉得很有意思的。</p><blockquote><p>PathToGo 下载地址：<code>https://github.com/HansonStudio/PathToGo/releases</code></p></blockquote><blockquote><p>欢迎关注我的公众号：HansonTalk<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/qrcode/HansonTalk.jpg" alt=""></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 开源/产品 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>通过 DeveloperID证书分发 Mac App 的经验</title>
      <link href="/2020/06/12/%E9%80%9A%E8%BF%87%20DeveloperID%E8%AF%81%E4%B9%A6%E5%88%86%E5%8F%91%20Mac%20App%20%E7%9A%84%E7%BB%8F%E9%AA%8C/"/>
      <url>/2020/06/12/%E9%80%9A%E8%BF%87%20DeveloperID%E8%AF%81%E4%B9%A6%E5%88%86%E5%8F%91%20Mac%20App%20%E7%9A%84%E7%BB%8F%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>对 Mac App 打包后，我们可以选择通过 <code>Developer ID</code> 方式直接向我们的客户分发 Mac App 而不用将 App 传到 Mac App Store。</p><p><img src="https://imgkr.cn-bj.ufileos.com/e0d7c2cf-f9a7-4f3c-8351-282e3ac12094.png" alt=""></p><p>在这个过程中遇到了一些坑，故总结分享一下。</p><a id="more"></a><h2 id="Developer-ID-证书"><a href="#Developer-ID-证书" class="headerlink" title="Developer ID 证书"></a>Developer ID 证书</h2><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>首先我们需要创建 Developer ID 证书，具体如何创建可以看苹果的这个 <a href="https://help.apple.com/developer-account/#/dev04fd06d56" target="_blank" rel="noopener">文档: 创建 Developer ID 证书</a>。</p><p>但是这里有个需要很注意的问题：使用开发者帐户或 Xcode 可以创建 <code>最多五个</code> Developer ID App 证书。</p><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><p>撤销删除 Developer ID App 证书 并不是随意操作的，不管你的苹果开发者账号的角色是什么，需通过 <code>product-security@apple.com</code> 向 Apple 发送请求，才可以删除。</p><p>而且注意，<strong>如果您撤销了 Developer ID 证书，用户便无法安装使用该证书签名的 app。</strong></p><blockquote><p>更详细的撤销证书权限可以看这个 <a href="https://help.apple.com/developer-account/#/dev138c9fac7" target="_blank" rel="noopener">文档: 撤销权限</a></p></blockquote><p>所以这里需要注意保管好 Developer ID 证书的私钥。我就试过换了电脑后，本地证书没有私钥的尴尬情况，就是常见的 <code>Missing Private key</code> 错误，如果你的 Developer ID 证书数量刚好达到了上限，无法创建新的证书，又丢失了旧的证书的私钥的话，这个情况就只能通过 <code>product-security@apple.com</code> 向 Apple 发送请求撤销旧的证书，再创建新的了。所以这里建议可以事先在 KeyChain Access.app 里导出 p12 文件做好保管。</p><h2 id="Notarization-苹果公证"><a href="#Notarization-苹果公证" class="headerlink" title="Notarization 苹果公证"></a>Notarization 苹果公证</h2><p>从 <code>macOS 10.14.5</code> 之后，通过 Developer ID 证书分发的 App，苹果建议都需要通过苹果的公证(Notarized)，以代表这个 App 不含有恶意内容，否则的话每次用户初次打开你的 App 的时候都会有 <code>无法检查是否包含恶意软件</code> 的安全提示，类似如下图：</p><p><img src="https://imgkr.cn-bj.ufileos.com/c7fb34a3-d41d-4003-beb8-3bc2ba3061da.png" alt=""></p><p>这时候需要去到系统设置的安全与隐私那里，选择仍要打开：</p><p><img src="https://imgkr.cn-bj.ufileos.com/3ac18848-7e5e-4ea5-b942-64c9b54efad7.png" alt=""></p><p>这时候还会有个安全提示，但是这次是有 <code>打开</code> 选项的：</p><p><img src="https://imgkr.cn-bj.ufileos.com/9cb935ba-b1d0-417b-9a28-318bfd5459f4.png" alt=""></p><p>这一顿操作下来其实对用户的体验很不友好，让人产生对 App 的不信任感。</p><p>所以这里还是建议大家把 App 上传给苹果进行公证。如下图在打包的时候可以选择 <code>Upload</code> 给苹果进行 Notarize</p><p><img src="https://imgkr.cn-bj.ufileos.com/15ed1b9d-485e-4c5a-90ed-66a329d5d246.png" alt=""></p><blockquote><p>关于 Notarization 这块更详细的内容，可以查看这个 <a href="https://developer.apple.com/documentation/xcode/notarizing_macos_software_before_distribution" target="_blank" rel="noopener">文档: Notarizing macOS Software Before Distribution</a></p></blockquote><blockquote><p>欢迎关注我的个人公众号：HansonTalk，分享点有意思的。<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/qrcode/HansonTalk.jpg" alt=""></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>利用 Vision给无人机图传加上人脸识别功能</title>
      <link href="/2020/06/08/%E5%88%A9%E7%94%A8%20Vision%20%E7%BB%99%E6%97%A0%E4%BA%BA%E6%9C%BA%E5%9B%BE%E4%BC%A0%E5%8A%A0%E4%B8%8A%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%8A%9F%E8%83%BD/"/>
      <url>/2020/06/08/%E5%88%A9%E7%94%A8%20Vision%20%E7%BB%99%E6%97%A0%E4%BA%BA%E6%9C%BA%E5%9B%BE%E4%BC%A0%E5%8A%A0%E4%B8%8A%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>Vision 是 iOS 上一个机器视觉的框架，它可以对图片和视频进行多种机器视觉相关的任务处理。Vision 里的人脸识别功能是最常用的功能之一，经过几次的迭代，它的识别效果已经很不错了，具体可以看看 <code>WWDC2017 Session 506</code>, <code>WWDC2018 Session 716、717</code> 和 <code>WWDC 2019 Session 222</code>，本文的 <a href="https://github.com/zyphs21/VisionDetect" target="_blank" rel="noopener">Demo-VisoinDetect</a> 有些代码就是从这些 Session 中的示例代码修改而来。</p><p>这里我们要做的东西是: 将 DJISDK 提供给我们的视频流数据，传入 Vision 框架进行人脸识别，然后拿到人脸信息在图传界面显示出来。效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/zyphs21/VisionDetect/detectFace.gif" alt=""></p><a id="more"></a><h2 id="一、获取无人机图传视频流"><a href="#一、获取无人机图传视频流" class="headerlink" title="一、获取无人机图传视频流"></a>一、获取无人机图传视频流</h2><blockquote><p>相信大家对无人机App激活连接这部分已经比较熟悉了，这里就不赘述，不熟悉的话请查阅 DJISDK 文档</p></blockquote><h3 id="1-注册-VideoFrameProcessor，获取到-VideoFrameYUV"><a href="#1-注册-VideoFrameProcessor，获取到-VideoFrameYUV" class="headerlink" title="1. 注册 VideoFrameProcessor，获取到 VideoFrameYUV"></a>1. 注册 VideoFrameProcessor，获取到 VideoFrameYUV</h3><p>视频流数据其实就是一帧帧的图片，而 Vision 可以接收 <code>CVPixelBuffer</code> 的图片数据，所以我们需要把图传数据转换成 <code>CVPixelBuffer</code> 。</p><p>这里我们利用 DJIWidget 的 <code>VideoFrameProcessor</code> 来获取视频流的帧数据。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> DJISDK</span><br><span class="line"><span class="keyword">import</span> DJIWidget</span><br><span class="line"></span><br><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> videoPreview: <span class="type">UIView!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="type">DJIVideoPreviewer</span>.instance().setView(videoPreview)</span><br><span class="line">    <span class="type">DJIVideoPreviewer</span>.instance().enableHardwareDecode = <span class="literal">true</span></span><br><span class="line">    <span class="type">DJIVideoPreviewer</span>.instance().enableFastUpload = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewWillAppear(animated)</span><br><span class="line">    </span><br><span class="line">    <span class="type">DJIVideoPreviewer</span>.instance().type = .autoAdapt</span><br><span class="line">    <span class="comment">// 调用 registFrameProcessor 方法</span></span><br><span class="line">    <span class="type">DJIVideoPreviewer</span>.instance()?.registFrameProcessor(<span class="keyword">self</span>)</span><br><span class="line">    <span class="type">DJIVideoPreviewer</span>.instance()?.start()</span><br><span class="line">    <span class="type">DJISDKManager</span>.videoFeeder()?.primaryVideoFeed.add(<span class="keyword">self</span>, with: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillDisappear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewWillDisappear(animated)</span><br><span class="line">    </span><br><span class="line">    <span class="type">DJISDKManager</span>.videoFeeder()?.primaryVideoFeed.remove(<span class="keyword">self</span>)</span><br><span class="line">    <span class="type">DJIVideoPreviewer</span>.instance().unSetView()</span><br><span class="line">    <span class="type">DJIVideoPreviewer</span>.instance().close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是我们常规获取视频流的方法，不过我们还调用了 <code>registFrameProcessor</code> 的方法，调用了该方法后，我们需要实现 <code>VideoFrameProcessor</code> 的代理方法，从代理方法中可以获取到视频流的 <code>VideoFrameYUV</code> 数据。</p><h3 id="2-将-VideoFrameYUV-转换成-CVPixelBuffer"><a href="#2-将-VideoFrameYUV-转换成-CVPixelBuffer" class="headerlink" title="2. 将 VideoFrameYUV 转换成 CVPixelBuffer"></a>2. 将 VideoFrameYUV 转换成 CVPixelBuffer</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: - VideoFrameProcessor</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DJIVideoViewController</span>: <span class="title">VideoFrameProcessor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">videoProcessorEnabled</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">videoProcessFrame</span><span class="params">(<span class="number">_</span> frame: UnsafeMutablePointer&lt;VideoFrameYUV&gt;!)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> resolution = <span class="type">CGSize</span>(width: <span class="type">CGFloat</span>(frame.pointee.width), height: <span class="type">CGFloat</span>(frame.pointee.height))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> frame.pointee.cv_pixelbuffer_fastupload != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 把 cv_pixelbuffer_fastupload 转换成 CVPixelBuffer 对象</span></span><br><span class="line">            <span class="keyword">let</span> cvBuf = <span class="built_in">unsafeBitCast</span>(frame.pointee.cv_pixelbuffer_fastupload, to: <span class="type">CVPixelBuffer</span>.<span class="keyword">self</span>)</span><br><span class="line">            setupCaptureDeviceResolution(resolution)</span><br><span class="line">            detectFace(pixelBuffer: cvBuf)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 自行构建 CVPixelBuffer 对象</span></span><br><span class="line">            <span class="keyword">let</span> pixelBuffer = frame.pointee.createPixelBuffer()</span><br><span class="line">            setupCaptureDeviceResolution(resolution)</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> cvBuf = pixelBuffer <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            detectFace(pixelBuffer: cvBuf)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>func videoProcessFrame(_ frame: UnsafeMutablePointer&lt;VideoFrameYUV&gt;!)</code> 的代理方法中，我们可以拿到 <code>VideoFrameYUV</code> 的数据。</p><p>理论上，在支持 HardwareDecode 的设备上，如果开启了 <code>HardwareDecode</code> 和 <code>Fastupload</code> , 返回的 <code>VideoFrameYUV</code> 里的 <code>luma</code>, <code>chromaB</code> and <code>chromaR</code> 可能会是空的(就无法构建 CVPixelBuffer)，这时候可以通过 <code>cv_pixelbuffer_fastupload</code> 获取到 <code>CVPixelBuffer</code> 的值。所以上面的代码里先判断 <code>frame.pointee.cv_pixelbuffer_fastupload</code> 是否不为 nil。</p><p>如果 cv_pixelbuffer_fastupload 为 nil 则我们需要自行构建 <code>CVPixelBuffer</code>，这里我们给 <code>VideoFrameYUV</code> 添加了一个扩展方法 <code>createPixelBuffer()</code> 以构建 <code>CVPixelBuffer</code>，这里就不贴代码了，具体可以查看 <a href="https://github.com/zyphs21/VisionDetect" target="_blank" rel="noopener">Github</a> 上的源码。</p><blockquote><p>针对开启 HardwareDecode 获取到 cv_pixelbuffer_fastupload 的情况，目前我手头上的设备是无法获取得到，总是需要进行构建 CVPixelBuffer。这个问题在 <a href="https://github.com/dji-sdk/DJIWidget/issues/9" target="_blank" rel="noopener">DJIWidget Github issue9</a> 有相关的讨论。</p></blockquote><h2 id="二、把-CVPixelBuffer-传给-Vision-处理"><a href="#二、把-CVPixelBuffer-传给-Vision-处理" class="headerlink" title="二、把 CVPixelBuffer 传给 Vision 处理"></a>二、把 CVPixelBuffer 传给 Vision 处理</h2><p>Vision 对数据的处理逻辑可以分为三步：</p><table><thead><tr><th>步骤</th><th></th></tr></thead><tbody><tr><td>做什么</td><td>VNRequest</td></tr><tr><td>怎么做</td><td>VNImageRequestHandler<br/>VNSequenceRequestHandler</td></tr><tr><td>处理结果</td><td>VNObservation</td></tr></tbody></table><h4 id="1-做什么-识别人脸及五官信息"><a href="#1-做什么-识别人脸及五官信息" class="headerlink" title="1. 做什么: 识别人脸及五官信息"></a>1. 做什么: 识别人脸及五官信息</h4><p>为了识别人脸及其五官信息，我们需要创建 <code>VNDetectFaceLandmarksRequest</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> detectFaceRequest = <span class="type">VNDetectFaceLandmarksRequest</span>(completionHandler: detectedFace)</span><br></pre></td></tr></table></figure><h4 id="2-怎么做-VNSequenceRequestHandler"><a href="#2-怎么做-VNSequenceRequestHandler" class="headerlink" title="2. 怎么做: VNSequenceRequestHandler"></a>2. 怎么做: VNSequenceRequestHandler</h4><p>因为我们需要处理视频流的一帧帧图片数据，所以我们用 <code>VNSequenceRequestHandler</code> 来执行 <code>FaceLandmarksRequest</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 注意无人机图传中照片都是 downMirrored 的，即(0, 0)在左下角</span></span><br><span class="line">    <span class="keyword">try</span> sequenceRequestHandler.perform([detectFaceRequest], on: pixelBuffer, orientation: .downMirrored)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"----执行 sequenceRequestHandler 失败: \(error.localizedDescription)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 perform 方法时，除了传入要执行的 request 和 pixelBuffer 外，还需要注意传入图片的 Orientation 信息，以让 Vision 知道这个图片是倒着的还是反转的等等。因为我们的视频流是从无人机传过来的，这里测试发现都是 <code>downMirrored</code> 的，即照片的 (0, 0) 点在左下角。</p><h4 id="3-处理结果：绘制人脸图层"><a href="#3-处理结果：绘制人脸图层" class="headerlink" title="3. 处理结果：绘制人脸图层"></a>3. 处理结果：绘制人脸图层</h4><p>最终得到的结果是封装在 <code>VNFaceObservation</code> 的对象里的，通过该对象可以拿到人脸相对于图片的坐标：<code>boundingBox</code> 以及五官的坐标信息 <code>landmarks</code>，从而可以绘制在图传界面上。具体绘制方法 <code>drawFaceObservations</code> 可以在 <a href="https://github.com/zyphs21/VisionDetect" target="_blank" rel="noopener">Github</a> 上查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func detectedFace(request: VNRequest, error: Error?) &#123;</span><br><span class="line">    if let error &#x3D; error &#123;</span><br><span class="line">        print(&quot;---detectedFaceRequest Error: \(error.localizedDescription)&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    guard let results &#x3D; request.results as? [VNFaceObservation] else &#123; return &#125;</span><br><span class="line"></span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">        self.drawFaceObservations(results)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里的关键点是在于：如何从无人机图传视频流里拿到 <code>CVPixelBuffer</code> ———— 这个 Vision 可以接受的数据。</p><p>另外一个的关键点是如何在图传界面上绘制出人脸信息，这里涉及到如何获取到视频图片的真实大小(Pixel单位)、ordination 等。</p><p>一旦处理好这些关键点，其余的问题就迎刃而解了。</p><blockquote><p>欢迎关注我的公众号：HansonTalk<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/qrcode/HansonTalk.jpg" alt=""></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CoreLocation 中的 Course 和 Heading 简析</title>
      <link href="/2020/04/15/CoreLocation%E4%B8%AD%E7%9A%84Course%E5%92%8CHeading%E7%AE%80%E6%9E%90/"/>
      <url>/2020/04/15/CoreLocation%E4%B8%AD%E7%9A%84Course%E5%92%8CHeading%E7%AE%80%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>很多地图 App 都会有一个当前定位的标记，该标记可以根据用户手持手机的朝向不同而改变方向。如图：</p><img src="https://imgkr.cn-bj.ufileos.com/6a305cfc-4d8e-4f17-ad25-d40534e29aec.png" width = "80" height = "80" alt="带方向的定位标记" align=center /><p>如果要实现这个带方向定位的标记点，需要什么数据呢？</p><a id="more"></a><ul><li>定位数据</li><li>手机朝向数据</li></ul><p>定位数据获取很简单，调用 <code>CLLocationManager</code> 的 <code>startUpdatingLocation()</code> 方法，然后在 <code>didUpdateLocations</code> 的回调方法中可以得到的 <code>CLLocation</code> 属性值。</p><p><code>CLLocation</code> 对象中，除了有我们需要的 coordinate 位置数据外，还有一个 <code>course</code> 属性。</p><p>这个 <code>course</code> 属性是不是我们需要的手机朝向数据呢？</p><blockquote><p>course:<br>The direction in which the device is traveling, measured in degrees and relative to due north.</p></blockquote><blockquote><p>Course values are measured in degrees starting at due north and continue clockwise around the compass. Thus, north is 0 degrees, east is 90 degrees, south is 180 degrees, and so on. Course values may not be available on all devices. A negative value indicates that the course information is invalid.</p></blockquote><p>从文档的解释来看，它是一个相对于地理北极以顺时针方向的角度数据，手机朝着正北方是 0 度，朝着东边是 90度，依次类推。</p><p>看起来是我们想要的值。但是从实际测试(真机室内测试)结果看，<strong>这个值一直是返回 -1 。（负数代表此值当前不可用）</strong></p><p>排除使用方式的不对，我们从文档 <a href="https://developer.apple.com/documentation/corelocation/getting_heading_and_course_information" target="_blank" rel="noopener">Getting Heading and Course Information</a> 发现，我们要获取的其实是 <code>heading</code>  的数据。</p><p>通过调用 CLLocationManager 中的 </p><pre><code>startUpdatingHeading()</code></pre><p>然后在 <code>locationManager(_:didUpdateHeading:)</code> 的回调方法中就可以获取到 heading 的数据了。</p><h2 id="Course-和-Heading"><a href="#Course-和-Heading" class="headerlink" title="Course 和 Heading"></a>Course 和 Heading</h2><p>从字面意思上我们可以将它们区分为 <code>航向</code> 和 <code>朝向</code></p><p><code>Course(航向)信息</code> 反映的是设备移动的速度和方向，并且仅在具有GPS硬件条件的设备上可用。</p><p>注意不要将 <code>Course(航向)</code> 与 <code>Heading(朝向)</code> 混淆。Course(航向) 反映的是设备移动时的方向，是<strong>从GPS信息中获取到，它与设备的物理方向无关</strong>。</p><p>而 <code>Heading(朝向)信息</code> 则是通过计算手机上传感器的值而获取到的相对于地理北极的角度信息。</p><h3 id="Course"><a href="#Course" class="headerlink" title="Course"></a>Course</h3><p>Course 常常是用在进行导航的情况下。比如平时我们开车进行导航的时候，有时候车子转弯过快，会发现导航上的朝向并没有及时更新到正确的方向，要过一会才会更新，这就是因为 GPS 信息没有及时更新过来，故 Course 信息也就无法有足够的数据支持它更新。</p><h3 id="Heading"><a href="#Heading" class="headerlink" title="Heading"></a>Heading</h3><p>Heading 是与物理设备有关的值，所以我们在获取 Heading 信息的时候，注意要配置 CLLocationManager 的 <code>headingOrientation</code> 属性。</p><p>headingOrientation 默认值是 <code>portrait</code> ，即我们平时正面拿着手机。而当我们正面横着拿手机的时候，需要将 <code>headingOrientation</code> 属性根据实际情况改成 <code>landscapeLeft</code> 或者 <code>landscapeRight</code>，这样系统才能通过手机的持有方位计算正确的 <code>Heading</code> 值，不然 Heading 就一直是默认以 portrait 的形式计算得到。</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算地图缩放等级 zoomLevel</title>
      <link href="/2019/05/08/%E8%AE%A1%E7%AE%97%E5%9C%B0%E5%9B%BE%E7%BC%A9%E6%94%BE%E7%AD%89%E7%BA%A7zoomLevel/"/>
      <url>/2019/05/08/%E8%AE%A1%E7%AE%97%E5%9C%B0%E5%9B%BE%E7%BC%A9%E6%94%BE%E7%AD%89%E7%BA%A7zoomLevel/</url>
      
        <content type="html"><![CDATA[<h2 id="背景及问题分析"><a href="#背景及问题分析" class="headerlink" title="背景及问题分析"></a>背景及问题分析</h2><p>在一些第三方的地图 SDK 中，往往会有 <code>zoomLevel</code> 这样一个属性，常用于设置地图的缩放等级。</p><p>但是在 iOS 自带的地图控件 <code>MKMapView</code> 是没有这样一个属性的。取而代之的是利用 <code>MKCoordinateRegion</code> 和 <code>MKCoordinateSpan</code> 来配置地图显示的中心和区域缩放的大小。</p><h3 id="MKCoordinateRegion-和-MKCoordinateSpan"><a href="#MKCoordinateRegion-和-MKCoordinateSpan" class="headerlink" title="MKCoordinateRegion 和 MKCoordinateSpan"></a>MKCoordinateRegion 和 MKCoordinateSpan</h3><p>我们先来看看 <code>MKCoordinateRegion</code> 和 <code>MKCoordinateSpan</code> 的这两个初始化方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MKCoordinateRegion(center: CLLocationCoordinate2D, span: MKCoordinateSpan)</span><br><span class="line">MKCoordinateSpan(latitudeDelta: CLLocationDegrees, longitudeDelta: CLLocationDegrees)</span><br></pre></td></tr></table></figure><p>结合 <a href="https://developer.apple.com/documentation/mapkit/mkcoordinatespan" target="_blank" rel="noopener">文档</a> ，我们可以将 <code>MKCoordinateRegion</code> 理解为地图上一块方形区域， <code>center</code> 是这块方形区域的中心地理坐标，而 <code>MKCoordinateSpan</code> 是这块区域的 <strong>经纬度范围</strong>，那么它的两个参数的取值范围是：</p><ul><li>latitudeDelta：[0, 180]</li><li>longitudeDelta: [0, 360]</li></ul><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/zoomlevel/lnglatDelta.jpg" width = "450" height = "320" alt="" align=center /><h2 id="Tiled-web-map"><a href="#Tiled-web-map" class="headerlink" title="Tiled web map"></a>Tiled web map</h2><p>了解了 <code>MKCoordinateRegion</code> 和 <code>MKCoordinateSpan</code> 后，我们该如何利用它们来计算出 <code>zoomLevel</code> 呢？这里我们需要先了解一下 <a href="https://en.wikipedia.org/wiki/Tiled_web_map" target="_blank" rel="noopener">Tiled web map</a> 这个概念。<code>Tiled web map</code> 的设计初衷是为了能在网络上更好的传输和展示地图，其中最早应用起来的是 <code>Google Maps</code>， 然后慢慢地成为了地图工具中一个不成文的标准。它把地图以图片的形式切割成很多个小块: <code>Tile</code>，当用户在地图上滑动或者缩放时，就会加载更多的 <code>Tile</code>，对比以前直接加载一大块图片的方式效率更高，用户体验更好。</p><p>大部分的 <code>Tiled web map</code> 会依据 Google Maps 的一些实现标准：</p><ul><li>一个 <code>Tile</code> 是 256x256 像素。</li><li>zoom Level 为 0 时，整个世界地图可以显示在单个 <code>Tile</code> 上。</li><li>每增加一个地图缩放等级，一个 <code>Tile</code> 的像素会加倍。也就是说一个 <code>Tile</code> 会被四个 <code>Tile</code> 替换掉。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/zoomlevel/tileMap.jpg" alt=""></p><blockquote><p>上面原图片来自 <a href="http://troybrant.net/blog/2010/01/mkmapview-and-zoom-levels-a-visual-guide/" target="_blank" rel="noopener">troybrant.net</a>，由原图拼接而成。</p></blockquote><p>根据上面的标准，我们可以得出这样一个公式：</p><p>$W=256 \times 2^{zoomlevel}$</p><p>W 表示地图一边长的像素。</p><h2 id="zoomLevel-算法解析"><a href="#zoomLevel-算法解析" class="headerlink" title="zoomLevel 算法解析"></a>zoomLevel 算法解析</h2><p>我们知道地球经度一周360度，那么一个经度范围占 <code>Tiled web map</code> 的多少像素呢？简单的除法可以得知：</p><p>$\frac{360}{256 \times 2^{zoomlevel}}$</p><p>上面说到 <code>MKCoordinateSpan</code> 它表示地图显示区域的 <strong>经纬度范围</strong>，假设我们把 <code>MKMapView</code> 的宽度设置为 <code>width</code>, 而 <code>MKCoordinateSpan.longitudeDelta</code> 是当前 <code>MKMapView</code> 显示区域的<strong>经度</strong>范围。那么我们可以得到这样一个等式：</p><p>$\frac{360}{256 \times 2^{zoomlevel}} = \frac{longitudeDelta}{width}$</p><p>一个简单的转换，即可得出 <code>zoomLevel</code> 的计算公式：</p><p>$zoomLevel = log_2{\frac{360 \times width}{longitudeDelta \times 256}}$</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>用代码形式展示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mapWidth = mapView.frame.size.width</span><br><span class="line"><span class="keyword">let</span> zoomLevel = log2(<span class="number">360</span> * <span class="type">Double</span>(mapWidth) / <span class="number">256.0</span> / mapView.region.span.longitudeDelta)</span><br></pre></td></tr></table></figure><p>我们还可以给 <code>MKMapView</code> 扩展一下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MKMapView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> zoomLevel: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> log2(<span class="number">360</span> * <span class="type">Double</span>(frame.size.width) / <span class="number">256.0</span> / region.span.longitudeDelta)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://en.wikipedia.org/wiki/Tiled_web_map" target="_blank" rel="noopener">维基百科: Tiled web map</a></li><li><a href="https://blog.mapbox.com/512-map-tiles-cb5bfd6e72ba" target="_blank" rel="noopener">Mapbox Medium blog: 512 map tiles</a></li><li><a href="https://stackoverflow.com/questions/4189621/setting-the-zoom-level-for-a-mkmapview/15020534#15020534" target="_blank" rel="noopener">Stackoverflow: Setting the zoom level for a MKMapView</a></li><li><a href="http://troybrant.net/blog/2010/01/mkmapview-and-zoom-levels-a-visual-guide/" target="_blank" rel="noopener">troybrant blog: mkmapview and zoom levels a visual guide</a></li><li><a href="https://www.microimages.com/documentation/TechGuides/80TilesetZoom.pdf" target="_blank" rel="noopener">Microimages: Setting Zoom Levels</a></li></ul><details open><summary><strong>欢迎关注我的公众号</strong></summary><table><thead><tr><th align="center">HansonTalk</th><th align="center">iOSTypist</th></tr></thead><tbody><tr><td align="center"><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/qrcode/HansonTalk.jpg" alt="HansonTalk" align=center /></td><td align="center"><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/qrcode/iOSTypist.jpg" alt="iOSTypist" align=center /></td></tr></tbody></table></details>]]></content>
      
      
      <categories>
          
          <category> 算法实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算一个多边形的重心点坐标</title>
      <link href="/2019/05/05/%E8%AE%A1%E7%AE%97%E4%B8%80%E4%B8%AA%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E9%87%8D%E5%BF%83%E7%82%B9%E5%9D%90%E6%A0%87/"/>
      <url>/2019/05/05/%E8%AE%A1%E7%AE%97%E4%B8%80%E4%B8%AA%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E9%87%8D%E5%BF%83%E7%82%B9%E5%9D%90%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h2 id="背景介绍与问题分析"><a href="#背景介绍与问题分析" class="headerlink" title="背景介绍与问题分析"></a>背景介绍与问题分析</h2><p>在之前的《如何判断一个多边形是否合法》 一文中有提到，用无人机规划飞行路线前，往往需要框选一个多边形的区域。</p><p>而在地图控件上显示这个多边形区域时，往往会遇到这样一个需求：需要把所要测绘的多边形区域移动到地图中心。</p><p>实现这个需求的基本思路就是：获取到多边形区域的重心点坐标，然后利用地图控件的 <code>setCenter</code>方法，就可以把地图的显示中心移动到多边形区域重心了。那么问题来了，如何求出一个多边形的重心点坐标呢？</p><blockquote><p>这里所说的重心，也常常叫几何中心</p></blockquote><p>这里首先给出一个公式:</p><p>平面多边形 $X$ 可以被剖分为 n个有限的简单图形 $X_1,X_2,….X_n$，这些简单图形的重心点为 $C_1$，面积为 $A_1$，那么这个平面多边形的重心点坐标为 $(C_x,C_y)$<br>$$C_x = \frac{\sum C_{i_x} A_i}{\sum A_i}, C_y = \frac{\sum C_{i_y} A_i}{\sum A_i}$$</p><blockquote><p>公式参考: <a href="https://en.wikipedia.org/wiki/Centroid#Centroid_of_polygon" target="_blank" rel="noopener">维基百科</a></p></blockquote><p>一般来说我们可以给多边形进行三角剖分，而 $\sum{A_i}$ 即为多边形的总面积，那么这个公式可以理解为：</p><p>多边形重心横坐标 = 多边形剖分的每一个三角形重心的横坐标 * 该三角形的面积之和 / 多边形总面积</p><p>多边形重心纵坐标 = 多边形剖分的每一个三角形重心的纵坐标 * 该三角形的面积之和 / 多边形总面积</p><p>所以这里就把问题拆分成了三个小问题：</p><ul><li>求每个剖分出来的三角形的重心。</li><li>求每个剖分出来的三角形的面积。</li><li>求多边形的面积。</li></ul><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><h3 id="1-求三角形的重心"><a href="#1-求三角形的重心" class="headerlink" title="1. 求三角形的重心"></a>1. 求三角形的重心</h3><p><img src="https://user-gold-cdn.xitu.io/2019/4/30/16a6cfc2430378e5?w=495&h=359&f=png&s=6343" alt="三角形重心"><br>三角形的重心：三条中线的交点。其中重心到其中一个顶点的距离是重心到该顶点对边中点的距离的2倍。<br />即：GC = 2 * GP，也就是说重心坐标在 CP 线段上距离 AB 的中点 P 的 1/3 处。<br>假设 A,B,C 三点的坐标为：<br>$$A:(x_1,y_1),B:(x_2,y_2),C:(x_3,y_3)$$</p><p>那么通过简单坐标计算，可以得出其重心坐标为 $(x,y)$<br>$$x = \frac{(x_1+x_2+x_3)}{3} , y = \frac{(y_1+y_2+y_3)}{3}$$</p><h3 id="2-求三角形面积"><a href="#2-求三角形面积" class="headerlink" title="2. 求三角形面积"></a>2. 求三角形面积</h3><p>计算三角形的面积，我们这里利用 <code>向量积</code>来计算，我们知道平面中的两个向量的叉乘的模等于以这两个向量为边的平行四边形的面积，那么以这个两个向量为边的三角形，则是这个平行四边形的面积的一半。</p><blockquote><p>参考：<a href="https://zh.wikipedia.org/wiki/%E5%8F%89%E7%A7%AF" target="_blank" rel="noopener">向量叉积</a></p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/4/30/16a6cfc2411ec119?w=426&h=271&f=png&s=3768" alt=""></p><p>如上图，已知平面上两点 $A:(x_1,y_1),B(x_2,y_2)$ ，以 A，B和坐标原点 $P(0,0)$ 构成的三角形的面积 S 为：<br>$$S=\frac{\vec{PB}\times\vec{PA}}{2} = \frac{x_2y_1 - x_1y_2 }{2}$$</p><p>这里给出运算草稿：<br><img src="https://user-gold-cdn.xitu.io/2019/4/30/16a6cfc2446ff8cb?w=845&h=215&f=png&s=225564" alt=""></p><p>为什么这里我们会以原点作为第三个点构成三角形呢？其实是跟接下来求多边形面积是有关联的。</p><h3 id="3-求多边形的面积"><a href="#3-求多边形的面积" class="headerlink" title="3. 求多边形的面积"></a>3. 求多边形的面积</h3><p>我们在上面给出的求平面多边形重心的公式中有说到，一般我们会把多边形剖分为多个三角形。<br>那么这个剖分点 P 我们可以设在哪里呢？这里先给出结论：这个剖分点可以设置在多边形的内部，也可以设置到外部。</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/30/16a6cfc2424f444d?w=493&h=243&f=png&s=7753" alt=""></p><p>为什么这个剖分点可以设置到外部呢？我们可以通过简单的三角形情况来推广到多边形的情况。<br>对于三角形ABC，我们把剖分点设置在其外部 P 的一点上<br><img src="https://user-gold-cdn.xitu.io/2019/4/30/16a6cfc24423917c?w=381&h=260&f=png&s=5277" alt=""></p><p>如果大家还记得 <a href="https://juejin.im/post/5cc7eea351882512fa03a481" target="_blank" rel="noopener">《如何判断一个多边形是否合法》</a> 一文中有讲过向量叉积是有正负之分的，并且根据上面所说的计算三角形面积，那么以 P 为剖分点，通过向量积可以得出这个三角形的面积 A 为：<br>$$A = \frac{1}{2}(\vec{PB} \times \vec{PC} + \vec{PC} \times \vec{PA} + \vec{PA} \times \vec{PB})$$</p><p>因为 向量PB 在 向量PA 的顺时针方向，所以 $\vec{PA} \times \vec{PB}$ 的结果是负数的。那么上面的面积计算公式其实就可以理解为：</p><p>三角形ABC的面积 = 三角形PBC面积 + 三角形PCA面积 - 三角形PAB面积</p><p>假设这四个点的坐标为：$P(x_0,y_0), A(x_1,y_1), B(x_2,y_2), C(x_3,y_3)$，通过上面的公式进行计算，具体的演算过程我就不给出了，这里直接给出计算结果：<br>$$A = x_1y_2-x_2y_1+x_2y_3-x_3y_2+x_3y_1-x_1y_3$$</p><p>我们可以发现，计算结果中没有 $x_0,y_0$ 的项，因为它们在计算过程中给消去了，数学就是这么奇妙！所以我们可以得出一个结论，多边形的面积结果与这个剖分点的位置是无关的。那么为了计算方便，我们当然选择把这个 P 点设置到原点上啦。</p><p>那么只要我们知道多边形的每一个顶点，通过原点进行剖分成多个三角形，然后通过向量的叉乘求出每个三角的面积，最后相加，就可以求出多边形的面积了。</p><h2 id="示例代码及解析"><a href="#示例代码及解析" class="headerlink" title="示例代码及解析"></a>示例代码及解析</h2><p>好了，说到这里，我们已经找到所有满足最开始的计算多边形重心点坐标的所有计算元素了。是时候上代码了，这里构建一个函数<code>calculatePolygonGravityCenter(coordinates: [CLLocationCoordinate2D])</code>，这个函数传入的参数是多边形在地图上的坐标点数组。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculatePolygonGravityCenter</span><span class="params">(coordinates: [CLLocationCoordinate2D])</span></span> -&gt; <span class="type">CLLocationCoordinate2D</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> area = <span class="number">0.0</span> <span class="comment">// 多边形面积</span></span><br><span class="line">    <span class="keyword">var</span> gravityLat = <span class="number">0.0</span> <span class="comment">// 重心点 latitude</span></span><br><span class="line">    <span class="keyword">var</span> gravityLng = <span class="number">0.0</span> <span class="comment">// 重心点 longitude</span></span><br><span class="line">    <span class="keyword">for</span> (index, coordinate) <span class="keyword">in</span> coordinates.enumerated() &#123;</span><br><span class="line">          <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">let</span> lat = coordinate.latitude</span><br><span class="line">        <span class="keyword">let</span> lng = coordinate.longitude</span><br><span class="line">        <span class="keyword">let</span> nextLat = coordinates[(index + <span class="number">1</span>) % coordinates.<span class="built_in">count</span>].latitude</span><br><span class="line">        <span class="keyword">let</span> nextLng = coordinates[(index + <span class="number">1</span>) % coordinates.<span class="built_in">count</span>].longitude</span><br><span class="line">          <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">let</span> tempArea = (nextLat * lng - nextLng * lat) / <span class="number">2.0</span></span><br><span class="line">          <span class="comment">// 3</span></span><br><span class="line">        area += tempArea</span><br><span class="line">          <span class="comment">// 4</span></span><br><span class="line">        gravityLat += tempArea * (lat + nextLat) / <span class="number">3</span></span><br><span class="line">        gravityLng += tempArea * (lng + nextLng) / <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 5</span></span><br><span class="line">    gravityLat = gravityLat / area</span><br><span class="line">    gravityLng = gravityLng / area</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">CLLocationCoordinate2D</span>(latitude: gravityLat, longitude: gravityLng)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应上面代码的注释：</p><ol><li>拿到多边形上连续两个点的坐标，我们可以把 latitude 看做横坐标，longitude 是纵坐标。</li><li>利用向量叉乘计算这两个点与原点组成的三角形的面积。</li><li>所有面积之和得出多边形的面积，就是求公式 $C_x = \frac{\sum C_{i_x} A_i}{\sum A_i}$ 中的 $\sum A_i$。</li><li><code>(lat + nextLat) / 3</code> 是以这两个点和原点组成的三角形的重心横坐标，这样的累加<code>gravityLat += tempArea * (lat + nextLat) / 3</code> 其实是求公式 $C_x = \frac{\sum C_{i_x} A_i}{\sum A_i}$ 中的 $\sum C_{i_x} A_i$ 的值。</li><li>到这一步就简单了，直接套用公式 $C_x = \frac{\sum C_{i_x} A_i}{\sum A_i}$。</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://en.wikipedia.org/wiki/Centroid#Centroid_of_polygon" target="_blank" rel="noopener">维基百科-Centroid</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%8F%89%E7%A7%AF" target="_blank" rel="noopener">维基百科-叉积</a></li><li><a href="http://www.cnblogs.com/xiexinxinlove/p/3708147.html" target="_blank" rel="noopener">cnblogs-用向量积（叉积）计算三角形的面积和多边形面积</a></li><li><a href="https://www.zhihu.com/question/22902370" target="_blank" rel="noopener">知乎-两个向量的叉乘为什么是面积</a></li><li><a href="https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CFJD&dbname=CJFDLAST2018&filename=SXTB200210014&v=MDk4NThSOGVYMUx1eFlTN0RoMVQzcVRyV00xRnJDVVJMT2ZZK1Z2RmlIblZydk9OalhmYkxHNEh0UE5yNDlFWUk=" target="_blank" rel="noopener">中国知网-任意多边形匀面重心的计算方法</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何判断一个多边形是否合法</title>
      <link href="/2019/02/17/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95/"/>
      <url>/2019/02/17/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>利用无人机对一片区域进行测绘前，我们会先在地图上框选一个区域，然后再规划飞行的路线，而需要测绘的这片区域往往是一个多边形。这就涉及判断多边形是否合法的问题。</p><p>首先我们要确定一个标准：<strong>怎么样才算一个不合法的多边形</strong> ？我们可以简单地通过下面这幅图来解释一下：<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/judgePolygonValid/polygonDesc.png" alt=""></p><a id="more"></a><p>我们可以看出前面两个分别是凹多边形和凸多边形，而最后一张则是我们所说的不合法多边形，可以看出这个不合法的多边形的特征就是：<strong>它存在某条边与另外一条边相交的情况</strong> 。</p><p>那么要判断一个多边形是否合法，我们只要判断组成多边形的所有线段是否存在相交的情况即可，当然，我们这里所说的相交是 <strong>规范相交</strong> ，即 <strong>交点不在线段的端点上</strong> 。</p><p>好了，那么现在的问题可以简化成：<strong>如何判断两条线段是否规范相交</strong> 。</p><p>这里我们需要借助 <strong>向量的叉积</strong> 来进行判断。</p><blockquote><p>叉积，又称向量积，是对三维空间中的两个向量的二元运算。</p></blockquote><p>这里推荐 3Blue1Brown 的 <a href="https://www.bilibili.com/video/av6731067/?p=11" target="_blank" rel="noopener">视频</a> 来快速回顾一下叉积的概念(下面的两幅截图来自此视频)。我们只需知道叉积的结果是有正负的，比如我们以向量 $\vec{v}$ 为标准，如下图，向量  $\vec{w}$  在  $\vec{v}$ 的 <strong>顺时针方向</strong>，那么   $\vec{v} \times \vec{w} &lt; 0$ ：</p><p><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/judgePolygonValid/vetorvw.png" alt=""><br>$$\vec{v} \times \vec{w} &lt; 0$$</p><p>如果向量 $\vec{w}$  在  $\vec{v}$ 的 <strong>逆时针方向</strong>，那么 $\vec{v} \times \vec{w} &gt; 0$ ：</p><p><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/judgePolygonValid/vetorwv.png" alt=""><br>$$\vec{v} \times \vec{w} &gt; 0$$</p><p>那么我们如何利用叉积的特性运用到判断线段是否相交上呢？</p><p>我们先看下面最直接的一个线段相交的情况：<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/judgePolygonValid/line1.png" alt=""></p><p>线段 $P_1P_2$ 和 线段 $Q_1Q_2$ 明显存在一个交点，从上面这张图我们可以做一个简单的结论：<strong>如果一条的线段的两个端点在另外一条线段两侧，那么这两条线段可能相交</strong>，注意这里说的是可能相交，稍后会讲到另外一种情况。</p><p>我们可以将上面的图转换为向量的情况来看：<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/judgePolygonValid/line2.png" alt=""></p><p>是不是觉得似曾相识，这跟上面提到的叉积的情况是不是很类似？<br>向量  $\vec{P_1Q_1}$  在  $\vec{P_1P_2}$ 的逆时针方向，那么：$\vec{P_1P_2} \times \vec{P_1Q_1} &gt; 0$<br>向量  $\vec{P_1Q_2}$  在  $\vec{P_1P_2}$ 的顺时针方向，那么：$\vec{P_1P_2} \times \vec{P_1Q_2} &lt; 0$</p><p>用 A 表示 $\vec{P_1P_2} \times \vec{P_1Q_1} $ 的叉积结果，用 B 表示 $\vec{P_1P_2} \times \vec{P_1Q_2}$ 的叉积结果，那么 <strong>一条的线段的两个端点在另外一条线段两侧</strong> 这个几何现象可以用这个公式表示 ：A*B &lt; 0</p><p>我们前面提到 <strong>如果一条的线段的两个端点在另外一条线段两侧，那么这两条线段可能相交</strong> ，为什么是可能相交呢？如果我们将 线段 $Q_1Q_2$ 往右边移动一下，会存在下面这种情况：<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/judgePolygonValid/line3.png" alt=""><br>从上图可以看出，线段 $Q_1Q_2$ 的两个端点在线段 $P_1P_2$  两侧，但是它们并没有相交。</p><p>那么如何排除这种情况呢？其实很简单，我们之前都是以线段 $P_1P_2$ 作为主视角，如果将主视角换成线段 $Q_1Q_2$，那么我们很容易看出 线段 $P_1P_2$ 的两个端点并没有在 线段 $Q_1Q_2$ 的两侧。所以我们再次看回上面相交的那幅图，为了能够充分的判断两条线段相交，这次以 $Q_1Q_2$ 为主视角看待这个问题，求叉积：<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/judgePolygonValid/line4.png" alt=""><br>向量  $\vec{Q_1P_2}$  在  $\vec{Q_1Q_2}$ 的逆时针方向，那么：$\vec{Q_1Q_2} \times \vec{Q_1P_2} &gt; 0$<br>向量  $\vec{Q_1P_1}$  在  $\vec{Q_1Q_2}$ 的顺时针方向，那么：$\vec{Q_1Q_2} \times \vec{Q_1P_1} &lt; 0$</p><p>综上，我们可以得出：<br>A =  $\vec{P_1P_2} \times \vec{P_1Q_1} $<br>B = $\vec{P_1P_2} \times \vec{P_1Q_2} $<br>C = $\vec{Q_1Q_2} \times \vec{Q_1P_1} $<br>D = $\vec{Q_1Q_2} \times \vec{Q_1P_2} $<br>当 A * B &lt; 0 &amp;&amp; C * D &lt; 0 的时候，两条线段规范相交。<br>至于向量的叉积如何运算，这里就不细写了，给出一张计算草稿给大家过目一下：<br><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/judgePolygonValid/calcraft.png" alt=""><br>根据计算草稿的内容，我们就很容易通过代码来实现了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private func isIntersect(line1: (CGPoint, CGPoint), line2: (CGPoint, CGPoint)) -&gt; Bool &#123;</span><br><span class="line">        let p1 &#x3D; line1.0</span><br><span class="line">        let p2 &#x3D; line1.1</span><br><span class="line">        let q1 &#x3D; line2.0</span><br><span class="line">        let q2 &#x3D; line2.1</span><br><span class="line"></span><br><span class="line">        let a1 &#x3D; (p2.x - p1.x) * (q1.y - p1.y) - (q1.x - p1.x) * (p2.y - p1.y)</span><br><span class="line">        let a2 &#x3D; (p2.x - p1.x) * (q2.y - p1.y) - (q2.x - p1.x) * (p2.y - p1.y)</span><br><span class="line">        </span><br><span class="line">        let b1 &#x3D; (q2.x - q1.x) * (p1.y - q1.y) - (p1.x - q1.x) * (q2.y - q1.y)</span><br><span class="line">        let b2 &#x3D; (q2.x - q1.x) * (p2.y - q1.y) - (p2.x - q1.x) * (q2.y - q1.y)</span><br><span class="line">        </span><br><span class="line">        if a1 * a2 &lt; 0 &amp;&amp; b1 * b2 &lt; 0 &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于笔者能力有限，文中如有错误还请各位读者不吝赐教。</p><br><br><details open><summary><strong>欢迎关注我的公众号</strong></summary><table><thead><tr><th align="center">HansonTalk</th><th align="center">iOSTypist</th></tr></thead><tbody><tr><td align="center"><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/qrcode/HansonTalk.jpg" alt="HansonTalk" align=center /></td><td align="center"><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/qrcode/iOSTypist.jpg" alt="iOSTypist" align=center /></td></tr></tbody></table></details>]]></content>
      
      
      <categories>
          
          <category> 算法实践 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift的泛型小总结</title>
      <link href="/2018/08/05/Swift%E7%9A%84%E6%B3%9B%E5%9E%8B%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/05/Swift%E7%9A%84%E6%B3%9B%E5%9E%8B%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><strong>本文针对网上一些关于泛型的知识点进行汇总和总结，已在文中标记出参考文章的链接</strong></p><blockquote><p>泛型是程序设计语言的一种特性。允许程序员在强类型程序设计语言中编写代码时定义一些可变部分，那些部分在使用前必须作出指明。</p></blockquote><a id="more"></a><p><code>Objective-C</code> 缺乏一个重要特性:不支持泛型。幸运地是，<code>Swift</code>拥有这一特性。==泛型允许你声明的函数、类以及结构体支持不同的数据类型==。</p><p>泛型代码可以让你写出根据自我需求定义、适用于任何类型的，灵活且可重用的函数和类型。它的可以让你避免重复的代码，用一种清晰和抽象的方式来表达代码的意图。</p><p>泛型是 Swift 强大特征中的其中一个，许多 Swift 标准库是通过泛型代码构建出来的。事实上，泛型的使用贯穿了整本语言手册，只是你没有发现而已。 <span style="border-bottom:2px solid brown;">例如，Swift 的数组和字典类型都是泛型集。你可以创建一个Int数组，也可创建一个String数组，或者甚至于可以是任何其他 Swift 的类型数据数组。同样的，你也可以创建存储任何指定类型的字典（dictionary），而且这些类型可以是没有限制的。</span></p><blockquote><p><a href="https://swift.gg/2015/09/16/swift-generics/" target="_blank" rel="noopener">参考</a></p></blockquote><h2 id="实现栈的例子，说明泛型的作用"><a href="#实现栈的例子，说明泛型的作用" class="headerlink" title="实现栈的例子，说明泛型的作用"></a>实现栈的例子，说明泛型的作用</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntStack</span></span>&#123;</span><br><span class="line">  <span class="comment">// 采用数组作为容器保存数据 类型为Int</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> stackItems:[<span class="type">Int</span>] = []</span><br><span class="line">  <span class="comment">// 入栈操作 即Push 添加最新数据到容器最顶部</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">pushItem</span><span class="params">(item:Int)</span></span>&#123;</span><br><span class="line">    stackItems.append(item)    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 出栈操作 即Pop 将容器最顶部数据移除</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">popItem</span><span class="params">()</span></span>-&gt;<span class="type">Int?</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastItem = stackItems.last</span><br><span class="line">    stackItems.removeLast()</span><br><span class="line">    <span class="keyword">return</span> lastItem</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这栈能够处理<code>Int</code>类型数据。但是如果要一个能够处理<code>String</code>类型的栈呢？我们需要替换所有<code>Int</code>为<code>String</code>，不过这显然是一个糟糕的解决方法。此外另外一种方法是用<code>AnyObject</code>，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class AnyObjectStack&#123;</span><br><span class="line">  &#x2F;&#x2F; 采用数组作为容器保存数据 类型为AnyObject</span><br><span class="line">  private var stackItems:[AnyObject] &#x3D; []</span><br><span class="line">  </span><br><span class="line">  func pushItem(item:AnyObject)&#123;</span><br><span class="line">    stackItems.append(item)    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  func popItem()-&gt;AnyObject?&#123;</span><br><span class="line">    let lastItem &#x3D; stackItems.last</span><br><span class="line">    stackItems.removeLast()</span><br><span class="line">    return lastItem</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这种情况下我们就失去了数据类型的安全，并且每当我们对栈进行操作时,都需要进行一系列繁琐的类型转换(casting操作,使用as来进行类型转换)</p><ul><li>通过泛型来解决：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Stack&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">  private var stackItems: [T] &#x3D; []  </span><br><span class="line"></span><br><span class="line">  func pushItem(item:T) &#123;</span><br><span class="line">    stackItems.append(item)</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  func popItem() -&gt; T? &#123;</span><br><span class="line">    let lastItem &#x3D; stackItems.last</span><br><span class="line">    stackItems.removeLast()</span><br><span class="line">    return lastItem</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型定义方式:由一对尖括号(&lt;&gt;)包裹，命名方式通常为大写字母开头(这里我们命名为T)。在初始化阶段，我们通过明确的类型(这里为Int)来定义参数,之后编译器将所有的泛型T替换成Int类型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 指定了泛型T 就是 Int </span><br><span class="line">&#x2F;&#x2F; 编译器会替换所有T为Int</span><br><span class="line">let aStack &#x3D; Stack&lt;Int&gt;()</span><br><span class="line"></span><br><span class="line">aStack.pushItem(10)</span><br><span class="line">if let lastItem &#x3D; aStack.popItem() &#123;</span><br><span class="line">  print(&quot;last item: \(lastItem)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型扩展"><a href="#泛型扩展" class="headerlink" title="泛型扩展"></a>泛型扩展</h2><blockquote><p><a href="http://swifter.tips/extension-generic/" target="_blank" rel="noopener">参考</a></p></blockquote><p>Swift 对于泛型的支持使得我们可以避免为类似的功能多次书写重复的代码，这是一种很好的简化。而对于泛型类型，我们也可以使用 extension 为泛型类型添加新的方法。</p><p>与为普通的类型添加扩展不同的是，<span style="border-bottom: 2px solid brown">泛型类型在类型定义时就引入了类型标志，我们可以直接使用</span>。例如 Swift 的 Array 类型的定义是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public struct Array&lt;Element&gt; : CollectionType, Indexable, ... &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个定义中，已经声明了 <code>Element</code> 为泛型类型。在为类似这样的泛型类型写扩展的时候，我们不需要在 extension 关键字后的声明中重复地去写 <code>&lt;Element&gt;</code> 这样的泛型类型名字 (其实编译器也不允许我们这么做)，在扩展中可以使用和原来所定义一样的符号即可指代类型本体声明的泛型。比如我们想在扩展中实现一个 random 方法来随机地取出 Array 中的一个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extension Array &#123;</span><br><span class="line">    var random: Element? &#123;</span><br><span class="line">        return self.count !&#x3D; 0 ?</span><br><span class="line">          self[Int.random(in: 0..&lt;self.count)] : nil</span><br><span class="line">        &#x2F;&#x2F; self[Int(arc4random_uniform(UInt32(self.count)))]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let languages &#x3D; [&quot;Swift&quot;,&quot;ObjC&quot;,&quot;C++&quot;,&quot;Java&quot;]</span><br><span class="line">languages.random!</span><br><span class="line">&#x2F;&#x2F; 随机输出是这四个字符串中的某个</span><br><span class="line"></span><br><span class="line">let ranks &#x3D; [1,2,3,4]</span><br><span class="line">ranks.random!</span><br><span class="line">&#x2F;&#x2F; 随机输出是这四个数字中的某个</span><br></pre></td></tr></table></figure><p><span style="border-bottom: 2px solid brown">在扩展中是不能添加整个类型可用的新泛型符号的，但是对于某个特定的方法来说，我们可以添加 T 以外的其他泛型符号</span>。比如在刚才的扩展中加上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func appendRandomDescription</span><br><span class="line">    &lt;U: CustomStringConvertible&gt;(input: U) -&gt; String &#123;</span><br><span class="line"></span><br><span class="line">        if let element &#x3D; self.random &#123;</span><br><span class="line">            return &quot;\(element) &quot; + input.description</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &quot;empty array&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们限定了只接受实现了 <code>CustomStringConvertible</code> 的参数作为参数，然后将这个内容附加到自身的某个随机元素的描述上。因为参数 input 实现了 <code>CustomStringConvertible</code>，所以在方法中我们可以使用 description 来获取描述字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let languages &#x3D; [&quot;Swift&quot;,&quot;ObjC&quot;,&quot;C++&quot;,&quot;Java&quot;]</span><br><span class="line">languages.random!</span><br><span class="line"></span><br><span class="line">let ranks &#x3D; [1,2,3,4]</span><br><span class="line">ranks.random!</span><br><span class="line"></span><br><span class="line">languages.appendRandomDescription(ranks.random!)</span><br><span class="line">&#x2F;&#x2F; 随机组合 languages 和 ranks 中的各一个元素，然后输出</span><br></pre></td></tr></table></figure><p>虽然这是个生造的需求，但是能说明泛型在扩展里的使用方式。简单说就是我们++不能通过扩展来重新定义当前已有的泛型符号，但是可以对其进行使用；在扩展中也不能为这个类型添加泛型符号；但只要名字不冲突，我们是可以在新声明的方法中定义和使用新的泛型符号的++。</p><h2 id="typealias-和-泛型"><a href="#typealias-和-泛型" class="headerlink" title="typealias 和 泛型"></a>typealias 和 泛型</h2><h3 id="typealias-作用"><a href="#typealias-作用" class="headerlink" title="typealias 作用"></a>typealias 作用</h3><blockquote><p><a href="http://swifter.tips/typealias/" target="_blank" rel="noopener">参考</a></p></blockquote><p>typealias 是用来为已经存在的类型重新定义名字的，通过命名，可以使代码变得更加清晰。使用的语法也很简单，使用 typealias 关键字像使用普通的赋值语句一样，可以将某个已经存在的类型赋值为新的名字。比如在计算二维平面上的距离和位置的时候，我们一般使用 Double 来表示距离，用 CGPoint 来表示位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func distanceBetweenPoint(point: CGPoint, toPoint: CGPoint) -&gt; Double &#123;</span><br><span class="line">    let dx &#x3D; Double(toPoint.x - point.x)</span><br><span class="line">    let dy &#x3D; Double(toPoint.y - point.y)</span><br><span class="line">    return sqrt(dx * dx + dy * dy)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let origin: CGPoint &#x3D; CGPoint(x: 0, y: 0)</span><br><span class="line">let point: CGPoint &#x3D; CGPoint(x: 1, y: 1)</span><br><span class="line"></span><br><span class="line">let distance: Double &#x3D;  distanceBetweenPoint(origin, point)</span><br></pre></td></tr></table></figure><p>虽然在数学上和最后的程序运行上都没什么问题，但是阅读和维护的时候总是觉得有哪里不对。因为我们没有将数学抽象和实际问题结合起来，使得在阅读代码时我们还需要在大脑中进行一次额外的转换：CGPoint 代表一个点，而这个点就是我们在定义的坐标系里的位置；Double 是一个数字，它代表两个点之间的距离。</p><p>如果我们使用 typealias，就可以将这种转换直接写在代码里，从而减轻阅读和维护的负担：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">typealias Location &#x3D; CGPoint</span><br><span class="line">typealias Distance &#x3D; Double</span><br><span class="line"></span><br><span class="line">func distanceBetweenPoint(location: Location,</span><br><span class="line">    toLocation: Location) -&gt; Distance &#123;</span><br><span class="line">        let dx &#x3D; Distance(location.x - toLocation.x)</span><br><span class="line">        let dy &#x3D; Distance(location.y - toLocation.y)</span><br><span class="line">        return sqrt(dx * dx + dy * dy)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let origin: Location &#x3D; Location(x: 0, y: 0)</span><br><span class="line">let point: Location &#x3D; Location(x: 1, y: 1)</span><br><span class="line"></span><br><span class="line">let distance: Distance &#x3D;  distanceBetweenPoint(origin, toLocation: point)</span><br></pre></td></tr></table></figure><p>同样的代码，在 typealias 的帮助下，读起来就轻松多了。</p><h3 id="用-typealias-给泛型重命名"><a href="#用-typealias-给泛型重命名" class="headerlink" title="用 typealias 给泛型重命名"></a>用 typealias 给泛型重命名</h3><p>泛型类型的确定性得到保证后，才可以重命名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Person&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">typealias WorkId &#x3D; String</span><br><span class="line">typealias Worker &#x3D; Person&lt;WorkId&gt;</span><br></pre></td></tr></table></figure><h2 id="在协议中使用-associatedtype"><a href="#在协议中使用-associatedtype" class="headerlink" title="在协议中使用 associatedtype"></a>在协议中使用 associatedtype</h2><blockquote><p><a href="https://numbbbbb.gitbooks.io/-the-swift-programming-language-/content/chapter2/22_Generics.html" target="_blank" rel="noopener">参考</a></p></blockquote><p>定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分将会非常有用。关联类型为协议中的某个类型提供了一个占位名（或者说别名），其代表的实际类型在协议被采纳时才会被指定。你可以通过 associatedtype 关键字来指定关联类型。</p><p>新建一个Container协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protocol Container &#123;</span><br><span class="line">    associatedtype Item</span><br><span class="line">    mutating func append(_ item: Item)</span><br><span class="line">    var count: Int &#123; get &#125;</span><br><span class="line">    subscript(i: Int) -&gt; Item &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以给协议里的关联类型添加类型注释，让遵守协议的类型必须遵循这个约束条件。例如，下面的代码定义了一个 Item 必须遵循 Equatable 的 Container 类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protocol Container &#123;</span><br><span class="line">    associatedtype Item: Equatable</span><br><span class="line">    mutating func append(_ item: Item)</span><br><span class="line">    var count: Int &#123; get &#125;</span><br><span class="line">    subscript(i: Int) -&gt; Item &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成遵循Container协议的泛型Stack:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct Stack&lt;T&gt;: Container &#123;</span><br><span class="line">    &#x2F;&#x2F; original Stack&lt;T&gt; implementation</span><br><span class="line">    var items &#x3D; [T]()</span><br><span class="line">    mutating func push(_ item: T) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    mutating func pop() -&gt; T &#123;</span><br><span class="line">        return items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 遵循Container协议的实现</span><br><span class="line">    mutating func append(_ item: T) &#123;</span><br><span class="line">        self.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    var count: Int &#123;</span><br><span class="line">        return items.count</span><br><span class="line">    &#125;</span><br><span class="line">    subscript(i: Int) -&gt; T &#123;</span><br><span class="line">        return items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h2><blockquote><p><a href="https://numbbbbb.gitbooks.io/-the-swift-programming-language-/content/chapter2/22_Generics.html" target="_blank" rel="noopener">参考</a></p></blockquote><h3 id="实现Equtable协议-使得泛型可以比较"><a href="#实现Equtable协议-使得泛型可以比较" class="headerlink" title="实现Equtable协议,使得泛型可以比较"></a>实现Equtable协议,使得泛型可以比较</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Stack&lt;T:Equatable&gt; &#123;</span><br><span class="line"></span><br><span class="line">  private var stackItems: [T] &#x3D; []</span><br><span class="line"></span><br><span class="line">  func pushItem(item:T) &#123;</span><br><span class="line">    .append(item)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  func popItem() -&gt; T? &#123;</span><br><span class="line">    let lastItem &#x3D; stackItems.last</span><br><span class="line">    stackItems.removeLast()</span><br><span class="line">    return lastItem</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  func isItemInStack(item:T) -&gt; Bool &#123;</span><br><span class="line">    var found &#x3D; false</span><br><span class="line">    for stackItem in stackItems &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果没有 &lt;T:Equatable&gt; 这里会报错</span><br><span class="line">      if stackItem &#x3D;&#x3D; item &#123;</span><br><span class="line">        ound &#x3D; true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return found</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Where-语句"><a href="#Where-语句" class="headerlink" title="Where 语句"></a>Where 语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func allItemsMatch&lt;</span><br><span class="line">    C1: Container, C2: Container</span><br><span class="line">    where C1.ItemType &#x3D;&#x3D; C2.ItemType, C1.ItemType: Equatable&gt;</span><br><span class="line">    (someContainer: C1, anotherContainer: C2) -&gt; Bool &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 检查两个Container的元素个数是否相同</span><br><span class="line">        if someContainer.count !&#x3D; anotherContainer.count &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 检查两个Container相应位置的元素彼此是否相等</span><br><span class="line">        for i in 0..&lt;someContainer.count &#123;</span><br><span class="line">            if someContainer[i] !&#x3D; anotherContainer[i] &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果所有元素检查都相同则返回true</span><br><span class="line">        return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在Swift扩展里添加&quot;存储属性&quot;</title>
      <link href="/2018/07/17/%E5%9C%A8Swift%E6%89%A9%E5%B1%95%E9%87%8C%E6%B7%BB%E5%8A%A0%22%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7%22/"/>
      <url>/2018/07/17/%E5%9C%A8Swift%E6%89%A9%E5%B1%95%E9%87%8C%E6%B7%BB%E5%8A%A0%22%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7%22/</url>
      
        <content type="html"><![CDATA[<p>能在 Swift 扩展里添加”存储属性”吗？</p><a id="more"></a><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>最近 <a href="https://itunes.apple.com/cn/app/imagegotcha/id1384107130?mt=8" target="_blank" rel="noopener">ImageGotcha</a> 收到了第一封用户反馈的邮件。<br><img src="" alt=""><br>这个用户希望可以有 <code>Dark Mode</code>。<code>ImageGotcha</code> 只是一个工具类 <code>App</code> ，好像也没有什么必要加上这个黑夜模式，不过我还是去想了想如何给应用加上黑夜模式，或者说加上一个换肤的功能。</p><p>基本的思路就是 <code>post</code> 一个自定义的 <code>NSNotification</code>，然后在需要修改颜色的地方监听这个通知然后进行修改。<br>按照惯例，我还是去 <code>Github</code> 上搜搜，看看别人是怎么做的。然后发现一部分人的做法是给现有的 <code>UIKit</code> 控件添加扩展属性，然后可以在定义这些控件的时候指定不同模式下的颜色，这的确是一种好方法。那么是如何在 <code>Swift</code> 的 <code>Extension 扩展</code> 里添加所谓的<code>&quot;存储属性&quot;</code>呢？</p><p>我们都知道，在 <code>Swift</code> 的 <code>Extension</code> 里是不能添加<code>存储属性</code>的，这里可以类比 <code>Objective-C</code>的 <code>Category 分类</code>，分类是不能添加实例变量和属性的。</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>这里就有个问题了，为什么不能添加呢？</p><blockquote><p>因为不管是 <code>Swift</code> 的 <code>Extension</code> 还是 <code>Objective-C</code> 的 <code>Category</code> 都不能改变原有的类或者结构体的内存结构，在实例化这些类的时候，内存结构是确定的，而添加属性或者实例变量需要内存空间，会改变原有的内存结构。</p></blockquote><h2 id="利用关联对象"><a href="#利用关联对象" class="headerlink" title="利用关联对象"></a>利用关联对象</h2><p>在 <code>Objective-C</code> 中我们常常用运行时 <code>Associated Object 关联对象</code> 来给 <code>Category</code> 添加属性，而在 <code>Swift</code> 里，我们同样可以利用关联对象在 <code>Extension</code> 中添加计算属性，以达到所谓的<code>存储属性</code>的效果。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AssociatedKeys</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> testNameKey: <span class="type">String</span> = <span class="string">"testNameKey"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> testName: <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">AssociatedKeys</span>.testNameKey) <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">AssociatedKeys</span>.testNameKey, newValue, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&amp;AssociatedKeys.testNameKey</code>: <code>&amp;</code> 操作符是取出地址作为 <code>UnsafeRawPointer</code> 参数传入。<br><code>.OBJC_ASSOCIATION_RETAIN_NONATOMIC</code>: 是一个 <code>objc_AssociationPolicy</code> 枚举，它有以下几种选择(从字面意思可以猜测是与Objective-C中的属性修饰符相关)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public enum objc_AssociationPolicy : UInt &#123;</span><br><span class="line">    case OBJC_ASSOCIATION_ASSIGN</span><br><span class="line">    case OBJC_ASSOCIATION_RETAIN_NONATOMIC</span><br><span class="line">    case OBJC_ASSOCIATION_COPY_NONATOMIC</span><br><span class="line">    case OBJC_ASSOCIATION_RETAIN</span><br><span class="line">    case OBJC_ASSOCIATION_COPY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var testString &#x3D; &quot;test&quot;</span><br><span class="line"></span><br><span class="line">let view &#x3D; UIView()</span><br><span class="line"></span><br><span class="line">view.testName &#x3D; testString</span><br><span class="line">print(view.testName) &#x2F;&#x2F; 输出 Optional(&quot;test&quot;)</span><br><span class="line"></span><br><span class="line">testString.append(&quot;change&quot;)</span><br><span class="line">print(view.testName) &#x2F;&#x2F; 输出 Optional(&quot;test&quot;)</span><br><span class="line"></span><br><span class="line">view.testName &#x3D; &quot;testChange&quot;</span><br><span class="line">print(view.testName) &#x2F;&#x2F; 输出 Optional(&quot;testChange&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>上架个小工具-ImageGotcha</title>
      <link href="/2018/05/18/%E4%B8%8A%E6%9E%B6%E4%B8%AA%E5%B0%8F%E5%B7%A5%E5%85%B7-ImageGotcha/"/>
      <url>/2018/05/18/%E4%B8%8A%E6%9E%B6%E4%B8%AA%E5%B0%8F%E5%B7%A5%E5%85%B7-ImageGotcha/</url>
      
        <content type="html"><![CDATA[<p>上架了个小工具。<a href="https://itunes.apple.com/cn/app/imagegotcha/id1384107130?mt=8&at=1000lMM4" target="_blank" rel="noopener">ImageGotcha</a> 是一个 <code>Safari</code> 的 <code>Action Extension</code>，它可以提取当前网页的图片方便查看和批量保存，比如可以去某些 <code>Instagram</code> 用户的主页批量下载图片，或者下载 <code>Bing</code> 的每日背景图等等。点击 <a href="https://itunes.apple.com/cn/app/imagegotcha/id1384107130?mt=8&at=1000lMM4" target="_blank" rel="noopener">这里</a> 到 <code>AppStore</code> 查看。</p><a id="more"></a><p><img src="https://camo.githubusercontent.com/f473966292ac4b1b3f3f07960e8e9383a4a3bf65/68747470733a2f2f6d6d62697a2e717069632e636e2f6d6d62697a5f6a70672f72346266653378374e3471557141566c666a4e593156685669615546614145363161334a687868543536696357544545685866376175324369633243743762746636706269627a326e53455458737858724e696344696351674f6f512f3634303f77785f666d743d6a7065672674703d7765627026777866726f6d3d352677785f6c617a793d31" alt=""></p><p><code>ImageGotcha</code> 也做了国际化，支持英文、简体中文、繁体中文、日语以及韩语。要想使用<code>ImageGotcha</code>，需先在 <code>Safari</code> 开启这个<code>Extension</code>，<code>App</code> 内有操作指导，如下图是各种语言的指导说明：</p><p><img src="https://camo.githubusercontent.com/f9878ecb46ab65ce8d6c74671ef02f18623408d4/68747470733a2f2f6d6d62697a2e717069632e636e2f6d6d62697a5f706e672f72346266653378374e3471557141566c666a4e5931566856696155466141453631346849493249524c316858316f69614764696250614e46475972326348304162737a5565386f6e43436963675144507469624d754d43677457672f3634303f77785f666d743d706e672674703d7765627026777866726f6d3d352677785f6c617a793d31" alt=""></p><p>这是演示如何启动 <code>ImageGotcha</code> 的 <code>Action Extension</code>：</p><p><embed src="https://imgcache.qq.com/tencentvideo_v1/playerv3/TPout.swf?max_age=86400&v=20161117&vid=o1339za69qd&auto=0" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"></embed></p><p>这是操作的演示：</p><p><embed src="https://imgcache.qq.com/tencentvideo_v1/playerv3/TPout.swf?max_age=86400&v=20161117&vid=w1339c8t6nc&auto=0" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"></embed></p><p>链接：<br><a href="https://itunes.apple.com/cn/app/imagegotcha/id1384107130?mt=8&at=1000lMM4" target="_blank" rel="noopener" style="display:inline-block;overflow:hidden;background:url(https://linkmaker.itunes.apple.com/assets/shared/badges/zh-cn/appstore-lrg.svg) no-repeat;width:135px;height:40px;background-size:contain;">ImageGotcha</a></p>]]></content>
      
      
      <categories>
          
          <category> 开源/产品 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用SVN建立和发布私有CocoaPods库</title>
      <link href="/2018/03/28/%E4%BD%BF%E7%94%A8SVN%E5%BB%BA%E7%AB%8B%E5%92%8C%E5%8F%91%E5%B8%83%E7%A7%81%E6%9C%89CocoaPods%E5%BA%93/"/>
      <url>/2018/03/28/%E4%BD%BF%E7%94%A8SVN%E5%BB%BA%E7%AB%8B%E5%92%8C%E5%8F%91%E5%B8%83%E7%A7%81%E6%9C%89CocoaPods%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="SVN-项目结构"><a href="#SVN-项目结构" class="headerlink" title="SVN 项目结构"></a>SVN 项目结构</h2><p>首先，一般 SVN 项目有如下的结构：</p><ul><li>trunk：项目主干</li><li>branches：开发或者 Bug 分支</li><li>tags：发布的版本</li></ul><p>比如说我们已经写好了一个 CocoaPods 的库，它的名字是 xxxKit，那么它应该在看起来是这样的：<br><img src="" alt=""></p><h2 id="建立-CocoaPods-库"><a href="#建立-CocoaPods-库" class="headerlink" title="建立 CocoaPods 库"></a>建立 CocoaPods 库</h2><p>我们在 trunk 的目录下执行 </p><p><code>pod lib create xxxKit</code></p><p>按照提示输入后，在该目录下就会利用 CocoaPods 的模板生成了一个项目。我们主要关注<code>xxxKit.podspec</code> 这个文件。</p><p>修改 <code>xxxKit.podspec</code>，比如：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">  s.name         &#x3D; &quot;xxxKit&quot;</span><br><span class="line">  s.version      &#x3D; &quot;0.1.1&quot;</span><br><span class="line">  s.summary      &#x3D; &quot;xxxKit.&quot;</span><br><span class="line">  s.homepage     &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;zyphs21&#x2F;&quot;</span><br><span class="line">  s.author       &#x3D; &#123; &quot;zyphs21&quot; &#x3D;&gt; &quot;hansenhs21@live.com&quot; &#125;</span><br><span class="line">  s.source       &#x3D; &#123; :svn &#x3D;&gt; &quot;http:&#x2F;&#x2F;xxxx&#x2F;xxxKit&#x2F;&quot;, :tag &#x3D;&gt; s.version.to_s &#125;</span><br><span class="line">  s.source_files  &#x3D; &quot;xxxKit&#x2F;**&#x2F;*.&#123;swift&#125;&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>主要注意是指定 source 那里，路径填的是 SVN 仓库的地址，并加上 tag。</p><p><code>s.source = { :svn =&gt; &quot;http://xxxx/xxxKit/&quot;, :tag =&gt; s.version.to_s }</code></p><h2 id="打-tags-发布一个版本"><a href="#打-tags-发布一个版本" class="headerlink" title="打 tags 发布一个版本"></a>打 tags 发布一个版本</h2><p>这里以 <code>Cornerstone</code> 这个 Mac 端的 SVN 工具来说明。</p><ol><li><p>去到远程库里进行打 tags，注意只有在远程库操作才能打 tag。</p><p> <img src="" alt=""></p></li><li><p>选择在 trunk 主干上 <code>右键</code> -&gt; <code>Tag…</code>，然后输入 tag 标签，比如 v0.1.1</p><p> <img src="" alt=""></p></li></ol><p>之后只要有开发到了新的版本了，按照这样先打 tag。</p><h2 id="使用私有库"><a href="#使用私有库" class="headerlink" title="使用私有库"></a>使用私有库</h2><p>去到需要使用该库的项目里，在 Podfile 里指定该版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &#39;xxxKit&#39;, :svn &#x3D;&gt; &#39;http:&#x2F;&#x2F;xxxx&#x2F;xxxKit&#x2F;&#39;, :tag &#x3D;&gt; &#39;0.1.1&#39;</span><br></pre></td></tr></table></figure><p>然后执行 <code>pod install</code></p>]]></content>
      
      
      <categories>
          
          <category> 工具教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>通过RunScript给iOS项目自增版本号(Versioin和Build)</title>
      <link href="/2018/03/14/%E9%80%9A%E8%BF%87RunScript%E7%BB%99iOS%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%A2%9E%E7%89%88%E6%9C%AC%E5%8F%B7(Versioin%E5%92%8CBuild)/"/>
      <url>/2018/03/14/%E9%80%9A%E8%BF%87RunScript%E7%BB%99iOS%E9%A1%B9%E7%9B%AE%E8%87%AA%E5%A2%9E%E7%89%88%E6%9C%AC%E5%8F%B7(Versioin%E5%92%8CBuild)/</url>
      
        <content type="html"><![CDATA[<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ul><li>在打包应用之后，需要自增 <strong>Version 的最后一位</strong> 和 <strong>Build</strong> 的值。<br><img src="https://user-gold-cdn.xitu.io/2018/3/14/162201d291ebc6c1?w=690&h=136&f=png&s=11268" alt=""></li><li>只在 Archive(Release) 的时候触发该自增。</li></ul><h2 id="添加-RunScript"><a href="#添加-RunScript" class="headerlink" title="添加 RunScript"></a>添加 RunScript</h2><p>在 <code>项目Target</code> -&gt; <code>Build Phases</code> -&gt; <code>点击+号</code> -&gt; <code>New Run Script Phase</code></p><p>然后添加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$CONFIGURATION</span> == Release ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前为 Release Configuration,开始自增 Build"</span></span><br><span class="line">plist=<span class="variable">$&#123;INFOPLIST_FILE&#125;</span></span><br><span class="line">buildnum=$(/usr/libexec/PlistBuddy -c <span class="string">"Print CFBundleVersion"</span> <span class="string">"<span class="variable">$&#123;plist&#125;</span>"</span>)</span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$&#123;buildnum&#125;</span>"</span> == <span class="string">""</span> ]]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Error：在Plist文件里没有 Build 值"</span></span><br><span class="line"><span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">buildnum=$(expr <span class="variable">$buildnum</span> + 1)</span><br><span class="line">/usr/libexec/PlistBuddy -c <span class="string">"Set CFBundleVersion <span class="variable">$buildnum</span>"</span> <span class="string">"<span class="variable">$&#123;plist&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"开始自增 Version 最后一位"</span></span><br><span class="line">versionNum=$(/usr/libexec/PlistBuddy -c <span class="string">"Print CFBundleShortVersionString"</span> <span class="string">"<span class="variable">$&#123;plist&#125;</span>"</span>)</span><br><span class="line">thirdPartVersonNum=`<span class="built_in">echo</span> <span class="variable">$versionNum</span> | awk -F <span class="string">"."</span> <span class="string">'&#123;print $3&#125;'</span>`</span><br><span class="line">thirdPartVersonNum=$((<span class="variable">$thirdPartVersonNum</span> + 1))</span><br><span class="line">newVersionStr=`<span class="built_in">echo</span> <span class="variable">$versionNum</span> | awk -F <span class="string">"."</span> <span class="string">'&#123;print $1 "." $2 ".'</span><span class="variable">$thirdPartVersonNum</span><span class="string">'" &#125;'</span>`</span><br><span class="line">/usr/libexec/PlistBuddy -c <span class="string">"Set CFBundleShortVersionString <span class="variable">$newVersionStr</span>"</span> <span class="string">"<span class="variable">$&#123;plist&#125;</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$CONFIGURATION</span> <span class="string">"当前不为 Release Configuration"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>因为我的版本号是<code>xx.xx.xx</code>这样的形式，所以我以 <code>.</code> 拆分版本号后，取出第三个值来增加，最后再拼接回来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">versionNum&#x3D;$(&#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -c &quot;Print CFBundleShortVersionString&quot; &quot;$&#123;plist&#125;&quot;)</span><br><span class="line"># 这里取出第三个值</span><br><span class="line">thirdPartVersonNum&#x3D;&#96;echo $versionNum | awk -F &quot;.&quot; &#39;&#123;print $3&#125;&#39;&#96;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PathToGo诞生记</title>
      <link href="/2018/03/02/PathToGo%E8%AF%9E%E7%94%9F%E8%AE%B0/"/>
      <url>/2018/03/02/PathToGo%E8%AF%9E%E7%94%9F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>不知道大家在使用 Mac 的时候有没有这样的需求:</p><blockquote><p>经常需要获取当前文件或者文件夹的路径，并且复制到粘贴板。</p></blockquote><p>对于我来说经常有这种需要，然后我就从网上再结合自己的经验，找了好几种方法：</p><a id="more"></a><ol><li>右键-选择「显示简介」，然后在弹出的窗口里直接用鼠标拖动复制「位    置」里的路径。</li></ol><p>​    缺点：麻烦。</p><ol start="2"><li>把文件拖到浏览器，在浏览器地址栏复制路径。</li></ol><p>​    缺点：麻烦。</p><ol start="3"><li>打开终端，把文件拖入终端，终端会把文件路径打印出来，然后复制。</li></ol><p>​    缺点：麻烦。</p><ol start="4"><li>打开终端，cd到目标目录，然后输入 「pwd|pbcopy」就可以把路径复制到粘贴板。</li></ol><p>​    缺点：麻烦。</p><ol start="5"><li>选择文件，然后使用快捷键「Option + Command + C」。</li></ol><p>​    缺点：这个快捷键在更低版本的系统中好像不行，而且会与 Alfred 的一个快捷键冲突。还是麻烦。</p><ol start="6"><li>利用 Automator 来建立 Service 服务添加到右键服务菜单。</li></ol><p>​    缺点：麻烦。</p><p>以上几种方法都不能满足我的需求：</p><blockquote><ol><li>直观快捷</li><li>最好可以同时获取多个文件/文件夹的路径。</li></ol></blockquote><p>这时候我想起了很受大家欢迎的一款效率软件：Go2Shell</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/2/161e49096986d7c9?w=262&h=238&f=png&s=66436" alt=""></p><p>这款软件把它拖动到 Finder 的工具栏后，只要点击它就可以立刻启动终端，并且进入到当前的路径。</p><p>那可以不可以也做一款这样的 App 操作和 Go2Shell 类似，选中一个或多个文件或文件夹然后直接一点，就可以把当前选中的文件或文件夹路径复制到粘贴板呢？</p><p>然后经过一番折腾，『PathToGo』这款 App 就诞生了。</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/2/161e490bc920f193?w=554&h=438&f=png&s=151480" alt=""></p><p>虽然一开始是想直接利用 AppleScript 然后导出为应用程序的，可是看着 AppleScript 导出为应用程序的图标实在不够酷，就直接着手做了 PathToGo 这个简单的 Mac App。</p><p>下面看看实际体验效果吧：</p><p>首先是把『PathToGo』拖动到 Finder 的工具栏，记得是按住『command键』来进行拖动。</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/2/161e491134c3825f?w=492&h=214&f=gif&s=199517" alt=""></p><p>拖放好了之后，只需要选中你想要的一个或多个文件/文件夹，然后点击在工具栏上的『PathToGo』的图标，路径就已经复制到粘贴板上了，然后你就能愉快的 用 command+v 就能粘贴出你选择的文件的路径了。</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/2/161e491402bb99d2?w=668&h=366&f=gif&s=297785" alt=""></p><p>怎么样？是不是很方便快捷呢！<br><a href="https://github.com/HansonStudio/PathToGo" target="_blank" rel="noopener">PathToGo</a> 已经开源在 HansonStudio 的 Github 组织下了，大家可以在 Release 页面下载使用。</p>]]></content>
      
      
      <categories>
          
          <category> 开源/产品 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用SwiftGen管理UIImage等的String-based接口</title>
      <link href="/2017/12/08/%E7%94%A8SwiftGen%E7%AE%A1%E7%90%86UIImage%E7%AD%89%E7%9A%84String-based%E6%8E%A5%E5%8F%A3/"/>
      <url>/2017/12/08/%E7%94%A8SwiftGen%E7%AE%A1%E7%90%86UIImage%E7%AD%89%E7%9A%84String-based%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="问题现状"><a href="#问题现状" class="headerlink" title="问题现状"></a>问题现状</h1><p>平时我们使用UIImage，UIFont，UIColor会遇到很多String-based的接口方法，比如常用的UIImage：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> testImage = <span class="type">UIImage</span>(named: <span class="string">"test"</span>)</span><br></pre></td></tr></table></figure><p>对于上面的代码，如果我们把 <code>test</code> 拼写错了，Xcode 并不会给出提示，只有当我们运行的时候才会收到报错，这样维护起来是有一定成本的。</p><h1 id="代码解决"><a href="#代码解决" class="headerlink" title="代码解决"></a>代码解决</h1><p>我们可以用类似如下的代码来解决这个问题：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit.UIImage</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImageAssets</span> </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> image: <span class="type">UIImage</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> image = <span class="type">UIImage</span>(named: name)</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> result = image <span class="keyword">else</span> &#123; <span class="built_in">fatalError</span>(<span class="string">"Unable to load image named \(name)."</span>) &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Assets</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">AppLogo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> appLogo = <span class="type">ImageAssets</span>(name: <span class="string">"appLogo"</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> grayLogo = <span class="type">ImageAssets</span>(name: <span class="string">"gray_logo"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Arrow</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> arrowBlue = <span class="type">ImageAssets</span>(name: <span class="string">"arrow_blue"</span>)</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> arrowBrown = <span class="type">ImageAssets</span>(name: <span class="string">"arrow_brown"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIImage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>!(asset: <span class="type">ImageAssets</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(named: asset.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用上面的代码，我们在新建 UIImage 的时候就不需要去想图片的名字了，而且 Xcode 还会有代码提示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> logo = <span class="type">Asset</span>.<span class="type">AppLogo</span>.appLogo.image</span><br><span class="line"><span class="keyword">let</span> grayLogo = <span class="type">UIImage</span>(asset: <span class="type">Asset</span>.<span class="type">AppLogo</span>.grayLogo)</span><br></pre></td></tr></table></figure><h1 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h1><p>虽然这种方法在调用的时候简单又安全了，但是项目中的图片往往比较多，如果手动编写维护那段代码也是需要不少精力，而且不能保证后续不会添加新的图片，这样每次都要去维护那段代码不免有些反人类。<br>那么现在就要介绍这个开源项目—  <a href="https://github.com/SwiftGen/SwiftGen" target="_blank" rel="noopener"><code>SwiftGen</code></a>了！</p><blockquote><p>SwiftGen is a tool to auto-generate Swift code for resources of your projects, to make them type-safe to use.</p></blockquote><p>利用 SwiftGen 可以帮我们生成这类的代码，但是 SwiftGen 默认生成的代码样式有时候并不是我们想要的，而且默认生成还会有针对 macOS 上的代码，比较好的是 SwiftGen 提供了模板的功能，我们可以按自己的需要来修改模板。</p><h1 id="集成-SwiftGen-在项目中"><a href="#集成-SwiftGen-在项目中" class="headerlink" title="集成 SwiftGen 在项目中"></a>集成 SwiftGen 在项目中</h1><p>SwiftGen 提供了好几种的集成方式，我这里只介绍我自己比较喜欢的方式：就是通过下载它的 Zip 文件解压到项目的目录中，然后通过添加 Run Script 来进行管理。这样可以基本做到不用操心代码。</p><h2 id="1-修改模板"><a href="#1-修改模板" class="headerlink" title="1.修改模板"></a>1.修改模板</h2><ul><li><p>到 SwiftGen仓库的Release页面下载最新的 <a href="https://github.com/SwiftGen/SwiftGen/releases" target="_blank" rel="noopener">swiftgen-5.2.1.zip</a></p></li><li><p>将解压后的 <code>swiftgen-5.2.1</code> 文件夹放到项目所在的目录下(存放<code>xxx.xcodeproj</code> 的位置)，可以将文件夹的名字改为<code>SwiftGen5</code>简洁一点。</p></li><li><p>进入到 <code>SwiftGen5</code> 里的 <code>templates/xcassets</code> 目录下，这里面可以看到有不少模板，我们选择 <code>swift4.stencil</code> 复制一份，命名为 <code>my-swift4.stencil</code> 然后我们就可以在里面修改我们自己想要的模板，我主要是想把 macOS 等其它平台的一些判断代码给删掉:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generated using SwiftGen, using my-templete created by Hanson</span></span><br><span class="line"></span><br><span class="line">&#123;% <span class="keyword">if</span> catalogs %&#125;</span><br><span class="line">&#123;% <span class="keyword">set</span> imageAlias %&#125;&#123;&#123;param.imageAliasName|<span class="keyword">default</span>:<span class="string">"Image"</span>&#125;&#125;&#123;% endset %&#125;</span><br><span class="line"><span class="keyword">import</span> UIKit.UIImage</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> &#123;&#123;imageAlias&#125;&#125; = <span class="type">UIImage</span></span><br><span class="line"></span><br><span class="line">&#123;% <span class="keyword">set</span> enumName %&#125;&#123;&#123;param.enumName|<span class="keyword">default</span>:<span class="string">"Asset"</span>&#125;&#125;&#123;% endset %&#125;</span><br><span class="line">&#123;% <span class="keyword">set</span> imageType %&#125;&#123;&#123;param.imageTypeName|<span class="keyword">default</span>:<span class="string">"ImageAsset"</span>&#125;&#125;&#123;% endset %&#125;</span><br><span class="line"><span class="meta">@available</span>(*, deprecated, renamed: <span class="string">"&#123;&#123;imageType&#125;&#125;"</span>)</span><br><span class="line"><span class="keyword">typealias</span> &#123;&#123;enumName&#125;&#125;<span class="type">Type</span> = &#123;&#123;imageType&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span>&#123;&#123;imageType&#125;&#125; &#123;</span><br><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> image: &#123;&#123;imageAlias&#125;&#125; &#123;</span><br><span class="line"><span class="keyword">let</span> bundle = <span class="type">Bundle</span>(<span class="keyword">for</span>: <span class="type">BundleToken</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="keyword">let</span> image = &#123;&#123;imageAlias&#125;&#125;(named: name, <span class="keyword">in</span>: bundle, compatibleWith: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> result = image <span class="keyword">else</span> &#123; <span class="built_in">fatalError</span>(<span class="string">"Unable to load image named \(name)."</span>) &#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% macro enumBlock assets sp %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% call casesBlock assets sp %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% <span class="keyword">if</span> not param.noAllValues %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% endif %&#125;</span><br><span class="line">&#123;% endmacro %&#125;</span><br><span class="line">&#123;% macro casesBlock assets sp %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% <span class="keyword">for</span> asset <span class="keyword">in</span> assets %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% <span class="keyword">if</span> asset.type == <span class="string">"color"</span> %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  <span class="keyword">static</span> <span class="keyword">let</span> &#123;&#123;asset.name|swiftIdentifier:<span class="string">"pretty"</span>|lowerFirstWord|escapeReservedKeywords&#125;&#125; = &#123;&#123;colorType&#125;&#125;(name: <span class="string">"&#123;&#123;asset.value&#125;&#125;"</span>)</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% elif asset.type == <span class="string">"image"</span> %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  <span class="keyword">static</span> <span class="keyword">let</span> &#123;&#123;asset.name|swiftIdentifier:<span class="string">"pretty"</span>|lowerFirstWord|escapeReservedKeywords&#125;&#125; = &#123;&#123;imageType&#125;&#125;(name: <span class="string">"&#123;&#123;asset.value&#125;&#125;"</span>)</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% elif asset.items %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  <span class="class"><span class="keyword">enum</span> </span>&#123;&#123;asset.name|swiftIdentifier:<span class="string">"pretty"</span>|escapeReservedKeywords&#125;&#125; &#123;</span><br><span class="line">&#123;&#123;sp&#125;&#125;    &#123;% <span class="keyword">set</span> sp2 %&#125;&#123;&#123;sp&#125;&#125;  &#123;% endset %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;    &#123;% call casesBlock asset.items sp2 %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% endif %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% endfor %&#125;</span><br><span class="line">&#123;% endmacro %&#125;</span><br><span class="line">&#123;% macro allValuesBlock assets <span class="built_in">filter</span> <span class="keyword">prefix</span> sp %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% <span class="keyword">for</span> asset <span class="keyword">in</span> assets %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% <span class="keyword">if</span> asset.type == <span class="built_in">filter</span> %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;&#123;<span class="keyword">prefix</span>&#125;&#125;&#123;&#123;asset.name|swiftIdentifier:<span class="string">"pretty"</span>|lowerFirstWord|escapeReservedKeywords&#125;&#125;,</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% elif asset.items %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% <span class="keyword">set</span> prefix2 %&#125;&#123;&#123;<span class="keyword">prefix</span>&#125;&#125;&#123;&#123;asset.name|swiftIdentifier:<span class="string">"pretty"</span>|escapeReservedKeywords&#125;&#125;.&#123;% endset %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% call allValuesBlock asset.items <span class="built_in">filter</span> prefix2 sp %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% endif %&#125;</span><br><span class="line">&#123;&#123;sp&#125;&#125;  &#123;% endfor %&#125;</span><br><span class="line">&#123;% endmacro %&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> </span>&#123;&#123;enumName&#125;&#125; &#123;</span><br><span class="line">&#123;% <span class="keyword">if</span> catalogs.<span class="built_in">count</span> &gt; <span class="number">1</span> %&#125;</span><br><span class="line">&#123;% <span class="keyword">for</span> catalog <span class="keyword">in</span> catalogs %&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> </span>&#123;&#123;catalog.name|swiftIdentifier:<span class="string">"pretty"</span>|escapeReservedKeywords&#125;&#125; &#123;</span><br><span class="line">&#123;% call enumBlock catalog.assets <span class="string">"  "</span> %&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">&#123;% call enumBlock catalogs.first.assets <span class="string">""</span> %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> </span>&#123;&#123;imageAlias&#125;&#125; &#123;</span><br><span class="line"><span class="keyword">convenience</span> <span class="keyword">init</span>!(asset: &#123;&#123;imageType&#125;&#125;) &#123;</span><br><span class="line"><span class="keyword">let</span> bundle = <span class="type">Bundle</span>(<span class="keyword">for</span>: <span class="type">BundleToken</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="keyword">self</span>.<span class="keyword">init</span>(named: asset.name, <span class="keyword">in</span>: bundle, compatibleWith: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BundleToken</span> </span>&#123;&#125;</span><br><span class="line">&#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line"><span class="comment">// No assets found</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h2 id="2-建立RunScript"><a href="#2-建立RunScript" class="headerlink" title="2.建立RunScript"></a>2.建立RunScript</h2></li><li><p>在<code>Xcode</code>中，进入到项目的<code>Target</code>，选择<code>Build Phases</code>,然后点击左上角的 <code>+</code> 号后点击 <code>New Run Script Phase</code>在新建的RunScript里添加如下内容：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">which</span> <span class="string">"<span class="variable">$PROJECT_DIR</span>"</span>/SwiftGen5/bin/swiftgen &gt;/dev/null;</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="string">"<span class="variable">$PROJECT_DIR</span>"</span>/SwiftGen5/bin/swiftgen xcassets -t my-swift4 <span class="string">"<span class="variable">$PROJECT_DIR</span>/swiftGenExample/Assets.xcassets"</span> --output <span class="string">"<span class="variable">$PROJECT_DIR</span>/swiftGenExample/ImageCode/ImageAsset.swift"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"##run echo warning: SwiftGen not installed, download it from https://github.com/SwiftGen/SwiftGen"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>  这段 <code>Run Script</code> 作用就是利用 SwiftGen 生成代码后写入到 <code>ImageAsset.swift</code> 文件中。</p></li><li><p>Build 一下project，我们就可以在 <code>/swiftGenExample/ImageCode/</code> 目录下看到 <code>ImageAsset.swift</code>，此时该文件还没有被项目索引，所以把它拖进项目Xcode对应的目录下就行了，之后即使我们添加了新的图片或者删掉旧的图片，只要每次Build一下项目，代码就会自动更新了。</p></li></ul><p>下面是生成的 <code>ImageAsset.swift</code> 的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ImageAsset.swift</span></span><br><span class="line"><span class="comment">// Generated using SwiftGen, using my-templete created by Hanson</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit.UIImage</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Image</span> = <span class="type">UIImage</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(*, deprecated, renamed: <span class="string">"ImageAsset"</span>)</span><br><span class="line"><span class="keyword">typealias</span> <span class="type">AssetType</span> = <span class="type">ImageAsset</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImageAsset</span> </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> image: <span class="type">Image</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> bundle = <span class="type">Bundle</span>(<span class="keyword">for</span>: <span class="type">BundleToken</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">let</span> image = <span class="type">Image</span>(named: name, <span class="keyword">in</span>: bundle, compatibleWith: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> result = image <span class="keyword">else</span> &#123; <span class="built_in">fatalError</span>(<span class="string">"Unable to load image named \(name)."</span>) &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Asset</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> arrowBlue = <span class="type">ImageAsset</span>(name: <span class="string">"arrow_blue"</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> arrowBrown = <span class="type">ImageAsset</span>(name: <span class="string">"arrow_brown"</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> iconLeftBack = <span class="type">ImageAsset</span>(name: <span class="string">"icon_left_back"</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> startLogo = <span class="type">ImageAsset</span>(name: <span class="string">"start_logo"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>!(asset: <span class="type">ImageAsset</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> bundle = <span class="type">Bundle</span>(<span class="keyword">for</span>: <span class="type">BundleToken</span>.<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(named: asset.name, <span class="keyword">in</span>: bundle, compatibleWith: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BundleToken</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这里只是利用了 <code>SwiftGen</code> 对于 <code>Image</code> 的部分。它还有其它的关于 <code>String</code> ，<code>StroyBoard</code>，<code>Font</code>等等的代码生成。原理基本相同，靠大家按需研究啦。</p><blockquote><p>到我的博客阅读：<a href="http://www.myhanson.com/2017/12/08/%E7%94%A8SwiftGen%E7%AE%A1%E7%90%86UIImage%E7%AD%89%E7%9A%84String-based%E6%8E%A5%E5%8F%A3/#more" target="_blank" rel="noopener">myhanson.com</a><br>本文Demo：<a href="https://github.com/zyphs21/SwiftGenExample" target="_blank" rel="noopener">SwiftGenExample</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift 实现启动屏动画</title>
      <link href="/2017/12/08/Swift%20%E5%AE%9E%E7%8E%B0%E5%90%AF%E5%8A%A8%E5%B1%8F%E5%8A%A8%E7%94%BB/"/>
      <url>/2017/12/08/Swift%20%E5%AE%9E%E7%8E%B0%E5%90%AF%E5%8A%A8%E5%B1%8F%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Github: <a href="https://github.com/zyphs21/SplashAnimate" target="_blank" rel="noopener">SplashAnimate</a></p></blockquote><a id="more"></a><h2 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h2><p>首先我们需要确定作为宣传的图片的宽高比，这个一般是与 UI 确定的。一般启动屏展示会有上下两部分，上面是宣传图片，下面是 App 的 Logo。</p><h2 id="实现基本思路："><a href="#实现基本思路：" class="headerlink" title="实现基本思路："></a>实现基本思路：</h2><p>在 LaunchScreen 结束后，在 AppDelegate 中将 rootViewController 指向展示广告用的 AdViewController，在AdViewController 中设置一段时间后自己销毁，并提供回调方法在 AppDelegate 中将 rootViewController 指向 App 真正的首页。</p><h2 id="实现细节："><a href="#实现细节：" class="headerlink" title="实现细节："></a>实现细节：</h2><p>新建一个 AdViewController 用于放置广告宣传等展示.注意有一个回调方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于 AdViewController 销毁后的回调</span></span><br><span class="line">    <span class="keyword">var</span> completion: (() -&gt; <span class="type">Void</span>)?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> adImage: <span class="type">UIImage?</span></span><br><span class="line">    <span class="keyword">var</span> adView: <span class="type">UIImageView?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ViewDidLoad 方法中配置广告图,同时判断 iPhoneX的特殊情况</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> adViewHeight = (<span class="number">1040</span> / <span class="number">720</span>) * screenWidth</span><br><span class="line">    <span class="keyword">var</span> imageName = <span class="string">"start_page"</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">UIDevice</span>.isiPhoneX() &#123;</span><br><span class="line">        adViewHeight = (<span class="number">1920</span> / <span class="number">1124</span>) * screenWidth</span><br><span class="line">        imageName = <span class="string">"start_page_x"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    adView = <span class="type">UIImageView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: screenWidth, height: adViewHeight))</span><br><span class="line">    adView?.image = <span class="type">UIImage</span>(named: imageName)</span><br><span class="line">    adView?.contentMode = .scaleAspectFill</span><br><span class="line">    <span class="keyword">self</span>.view.addSubview(adView!)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> bottomHolderView = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: screenHeight-<span class="number">120</span>, width: screenWidth, height: <span class="number">120</span>))</span><br><span class="line">    <span class="keyword">self</span>.view.addSubview(bottomHolderView)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> logo = <span class="type">UIImageView</span>(frame: <span class="type">CGRect</span>(x: (screenWidth-<span class="number">120</span>)/<span class="number">2</span>, y: (<span class="number">120</span>-<span class="number">50</span>)/<span class="number">2</span>, width: <span class="number">120</span>, height: <span class="number">50</span>))</span><br><span class="line">    logo.image = <span class="type">UIImage</span>(named: <span class="string">"start_logo"</span>)</span><br><span class="line">    bottomHolderView.addSubview(logo)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> time: <span class="type">TimeInterval</span> = <span class="number">1.0</span></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: <span class="type">DispatchTime</span>.now() + time) &#123;</span><br><span class="line">        <span class="keyword">self</span>.dismissAdView()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中有几个注意的:</p><p>因为图片要撑满屏幕的宽度，所以宽度是固定的，根据图片的高宽比，算出图片实际应有的高度，这样图片可以在各个尺寸的 iPhone 中才不会因为拉伸而变形。但是因为 iPhoneX 特殊的宽高比，所以还是要为它特定一张图片，不然即使图片在 iPhoneX 上不变形，图片所占的高度会太小，或者顶部被刘海遮挡内容而不美观。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> adViewHeight = (<span class="number">1040</span> / <span class="number">720</span>) * screenWidth</span><br><span class="line"><span class="keyword">var</span> imageName = <span class="string">"start_page"</span></span><br><span class="line"><span class="keyword">if</span> <span class="type">UIDevice</span>.isiPhoneX() &#123;</span><br><span class="line">    adViewHeight = (<span class="number">1920</span> / <span class="number">1124</span>) * screenWidth</span><br><span class="line">    imageName = <span class="string">"start_page_x"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面判断是否为 iPhoneX 我是在 UIDevice 里扩展了一个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extension UIDevice &#123;</span><br><span class="line">    public static func isiPhoneX() -&gt; Bool &#123;</span><br><span class="line">        if UIScreen.main.bounds.height &#x3D;&#x3D; 812 &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有注意在执行销毁时调用回调方法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> time: <span class="type">TimeInterval</span> = <span class="number">1.0</span></span><br><span class="line"><span class="type">DispatchQueue</span>.main.asyncAfter(deadline: <span class="type">DispatchTime</span>.now() + time) &#123;</span><br><span class="line">    <span class="keyword">self</span>.dismissAdView()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 AppDelegate 中 didFinishLaunchingWithOptions 方法中调用下面的 setUpWindowAndRootView() 来管理页面展示</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AppDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setUpWindowAndRootView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        window = <span class="type">UIWindow</span>(frame: <span class="type">UIScreen</span>.main.bounds)</span><br><span class="line">        window!.backgroundColor = <span class="type">UIColor</span>.white</span><br><span class="line">        window!.makeKeyAndVisible()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> adVC = <span class="type">AdViewController</span>()</span><br><span class="line">        adVC.completion = &#123;</span><br><span class="line">            <span class="keyword">let</span> vc = <span class="type">ViewController</span>()</span><br><span class="line">            vc.adView = adVC.view</span><br><span class="line">            <span class="keyword">self</span>.window!.rootViewController = vc</span><br><span class="line">        &#125;</span><br><span class="line">        window!.rootViewController = adVC</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在 AdViewController 销毁的回调方法中，将 AdViewController 的 view 传给真正的首页，让首页来执行动画</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adVC.completion = &#123;</span><br><span class="line">    <span class="keyword">let</span> vc = <span class="type">ViewController</span>()</span><br><span class="line">    <span class="comment">// 将 AdViewController 的 view 传给真正的首页，让首页来执行动画</span></span><br><span class="line">    vc.adView = adVC.view</span><br><span class="line">    <span class="keyword">self</span>.window!.rootViewController = vc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在首页 ViewController 里我们有如下方法来执行 AdViewController 的销毁动画，这里配置的动画是常见的扩大渐变消失</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> advertiseView: <span class="type">UIView?</span></span><br><span class="line"><span class="keyword">var</span> adView: <span class="type">UIView?</span> &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        advertiseView = adView!</span><br><span class="line">        advertiseView?.frame = <span class="keyword">self</span>.view.bounds</span><br><span class="line">        <span class="keyword">self</span>.view.addSubview(advertiseView!)</span><br><span class="line">        <span class="type">UIView</span>.animate(withDuration: <span class="number">1.5</span>, animations: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>?.advertiseView?.transform = <span class="type">CGAffineTransform</span>(scaleX: <span class="number">1.2</span>, y: <span class="number">1.2</span>)</span><br><span class="line">            <span class="keyword">self</span>?.advertiseView?.alpha = <span class="number">0</span></span><br><span class="line">        &#125;) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (isFinish) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>?.advertiseView?.removeFromSuperview()</span><br><span class="line">            <span class="keyword">self</span>?.advertiseView = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，一个简单的启动屏动画就完成了。</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>记一次失败的 Swift 元组数组实践</title>
      <link href="/2017/11/28/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%20Swift%20%E5%85%83%E7%BB%84%E6%95%B0%E7%BB%84%E5%AE%9E%E8%B7%B5/"/>
      <url>/2017/11/28/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%20Swift%20%E5%85%83%E7%BB%84%E6%95%B0%E7%BB%84%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>想建立一个元组的数组，来简单存放构建 TabViewController 的信息首先我的做法是</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> homeTab = (vc: <span class="type">VYHomeViewController</span>(), title: <span class="string">"Home"</span>, image: <span class="string">"home_gray"</span>, selectedImage: <span class="string">"home_blue"</span>)</span><br><span class="line"><span class="keyword">let</span> infoTab = (vc: <span class="type">VYInformationViewController</span>(), title: <span class="string">"Info"</span>, image: <span class="string">"home_gray"</span>, selectedImage: <span class="string">"home_blue"</span>)</span><br><span class="line"><span class="keyword">let</span> marketTab = (vc: <span class="type">VYMarketViewController</span>(), title: <span class="string">"Market"</span>, image: <span class="string">"home_gray"</span>, selectedImage: <span class="string">"home_blue"</span>)</span><br><span class="line"><span class="keyword">let</span> userTab = (vc: <span class="type">VYUserCenterViewController</span>(), title: <span class="string">"Me"</span>, image: <span class="string">"home_gray"</span>, selectedImage: <span class="string">"home_blue"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面报错：Heterogeneous collection literal could only be inferred to '[Any]'; add explicit type annotation if this is intentional</span></span><br><span class="line"><span class="keyword">let</span> data = [homeTab, infoTab, marketTab, userTab]</span><br></pre></td></tr></table></figure><p>但是会报错，Xcode 的修改提示是后面添加  <code>as [Any]</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [selfSelectedTab, infoTab, marketTab, userTab] <span class="keyword">as</span> [<span class="type">Any</span>]</span><br></pre></td></tr></table></figure><p>但是这样做已经不是原来的做一个元组数组的初衷了。无法在遍历数组的时候使用命名元组来获取信息</p><a id="more"></a><p>接着我用 <code>typealias</code> 的方法改成如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">TabInfo</span> = (vc: <span class="type">UIViewController</span>, title: <span class="type">String</span>, image: <span class="type">String</span>, selectedImage: <span class="type">String</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tabInfo: [<span class="type">TabInfo</span>] = [<span class="type">TabInfo</span>]()</span><br><span class="line"><span class="keyword">let</span> homeTab = (vc: <span class="type">VYHomeViewController</span>(), title: <span class="string">"Home"</span>, image: <span class="string">"home_gray"</span>, selectedImage: <span class="string">"home_blue"</span>)</span><br><span class="line"><span class="keyword">let</span> infoTab = (vc: <span class="type">VYHomeViewController</span>(), title: <span class="string">"Info"</span>, image: <span class="string">"home_gray"</span>, selectedImage: <span class="string">"home_blue"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面报错：Cannot express tuple conversion '(vc: VYInformationViewController, title: String, image: String, selectedImage: String)' to '(vc: UIViewController, title: String, image: String, selectedImage: String)'</span></span><br><span class="line">tabInfo.append(homeTab)</span><br></pre></td></tr></table></figure><p>给数组添加元素的时候报错，因为元组不支持类型转换，<code>VYHomeViewController</code> 虽然继承 <code>UIViewController</code>，但是元组看来它们不是同一类型。</p><p>最后还是放弃了用元组数组的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> homeTab = (vc: <span class="type">VYHomePageViewController</span>(), title: <span class="type">Home</span>, image: <span class="string">"new_home_gray"</span>, selectedImage: <span class="string">"new_home_blue"</span>)</span><br><span class="line"><span class="keyword">let</span> infoTab = (vc: <span class="type">VYInformationViewController</span>(), title: <span class="type">Info</span>, image: <span class="string">"msg_gray"</span>, selectedImage: <span class="string">"msg_blue"</span>)</span><br><span class="line"><span class="keyword">let</span> marketTab = (vc: <span class="type">VYMarketViewController</span>(), title: <span class="type">Market</span>, image: <span class="string">"hangqing_gray"</span>, selectedImage: <span class="string">"hangqing_blue"</span>)</span><br><span class="line"><span class="keyword">let</span> userTab = (vc: <span class="type">VYUserCenterViewController</span>(), title: <span class="type">Me</span>, image: <span class="string">"mine_gray"</span>, selectedImage: <span class="string">"mine_blue"</span>)</span><br><span class="line"></span><br><span class="line">addViewController(homeTab.vc, title: homeTab.title, image: homeTab.image, selectedIamge: homeTab.selectedImage)</span><br><span class="line">addViewController(infoTab.vc, title: infoTab.title, image: infoTab.image, selectedIamge: infoTab.selectedImage)</span><br><span class="line">addViewController(marketTab.vc, title: marketTab.title, image: marketTab.image, selectedIamge: marketTab.selectedImage)</span><br><span class="line">addViewController(userTab.vc, title: userTab.title, image: userTab.image, selectedIamge: userTab.selectedImage)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Swift </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自定义 UISegmentedControl 样式</title>
      <link href="/2017/05/09/%E8%87%AA%E5%AE%9A%E4%B9%89%20UISegmentedControl%20%E6%A0%B7%E5%BC%8F/"/>
      <url>/2017/05/09/%E8%87%AA%E5%AE%9A%E4%B9%89%20UISegmentedControl%20%E6%A0%B7%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>系统的 UISegmentedControl 是个挺方便的控件，这里来讲讲在 Swift3 下自定义 UISegmentedControl 的样式，包括修改底色，边框颜色等等。</p><p>要了解 UISegmentedControl 各个部分的组成，可以在官方的文档中找到 <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/UIKitUICatalog/UISegmentedControl.html" target="_blank" rel="noopener">UISegmentedControl 文档</a> 。着重注意这个图：</p><p>   <img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/uisegment/uisegment.png" alt="image.png"></p><p>上面这幅图明确的列出了 UISegmentedControl 各个部分所控制的方法。下面就开始自定义吧。  </p><a id="more"></a><p>首先我们先做一个通过颜色生成图片的的一个扩展方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIImage</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">renderImageWithColor</span>(<span class="title">_</span> <span class="title">color</span>: <span class="title">UIColor</span>, <span class="title">size</span>: <span class="title">CGSize</span>) -&gt; <span class="title">UIImage</span> </span>&#123;</span><br><span class="line">        <span class="type">UIGraphicsBeginImageContext</span>(size)</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>() <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">            <span class="keyword">return</span> <span class="type">UIImage</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        context.setFillColor(color.cgColor);</span><br><span class="line">        context.fill(<span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: size.width, height: size.height));</span><br><span class="line">        <span class="keyword">let</span> img = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">        <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">        <span class="keyword">return</span> img ?? <span class="type">UIImage</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们可以为 UISegmentedControl 建立一个可以自定义颜色的扩展方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UISegmentedControl</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 自定义样式</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameters:</span></span><br><span class="line">    <span class="comment">///   - normalColor: 普通状态下背景色</span></span><br><span class="line">    <span class="comment">///   - selectedColor: 选中状态下背景色</span></span><br><span class="line">    <span class="comment">///   - dividerColor: 选项之间的分割线颜色</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setSegmentStyle</span><span class="params">(normalColor: UIColor, selectedColor: UIColor, dividerColor: UIColor)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> normalColorImage = <span class="type">UIImage</span>.renderImageWithColor(normalColor, size: <span class="type">CGSize</span>(width: <span class="number">1.0</span>, height: <span class="number">1.0</span>))</span><br><span class="line">        <span class="keyword">let</span> selectedColorImage = <span class="type">UIImage</span>.renderImageWithColor(selectedColor, size: <span class="type">CGSize</span>(width: <span class="number">1.0</span>, height: <span class="number">1.0</span>))</span><br><span class="line">        <span class="keyword">let</span> dividerColorImage = <span class="type">UIImage</span>.renderImageWithColor(dividerColor, size: <span class="type">CGSize</span>(width: <span class="number">1.0</span>, height: <span class="number">1.0</span>))</span><br><span class="line">        </span><br><span class="line">        setBackgroundImage(normalColorImage, <span class="keyword">for</span>: .normal, barMetrics: .<span class="keyword">default</span>)</span><br><span class="line">        setBackgroundImage(selectedColorImage, <span class="keyword">for</span>: .selected, barMetrics: .<span class="keyword">default</span>)</span><br><span class="line">        setDividerImage(dividerColorImage, forLeftSegmentState: .normal, rightSegmentState: .normal, barMetrics: .<span class="keyword">default</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> segAttributesNormal: <span class="type">NSDictionary</span> = [<span class="type">NSForegroundColorAttributeName</span>: <span class="type">UIColor</span>.gray, <span class="type">NSFontAttributeName</span>: <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">14</span>)]</span><br><span class="line">        <span class="keyword">let</span> segAttributesSeleted: <span class="type">NSDictionary</span> = [<span class="type">NSForegroundColorAttributeName</span>: <span class="type">UIColor</span>.white,<span class="type">NSFontAttributeName</span>: <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">14</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 文字在两种状态下的颜色</span></span><br><span class="line">        setTitleTextAttributes(segAttributesNormal <span class="keyword">as</span> [<span class="type">NSObject</span> : <span class="type">AnyObject</span>], <span class="keyword">for</span>: <span class="type">UIControlState</span>.normal)</span><br><span class="line">        setTitleTextAttributes(segAttributesSeleted <span class="keyword">as</span> [<span class="type">NSObject</span> : <span class="type">AnyObject</span>], <span class="keyword">for</span>: <span class="type">UIControlState</span>.selected)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 边界颜色、圆角</span></span><br><span class="line">        <span class="keyword">self</span>.layer.borderWidth = <span class="number">0.7</span></span><br><span class="line">        <span class="keyword">self</span>.layer.cornerRadius = <span class="number">5.0</span></span><br><span class="line">        <span class="keyword">self</span>.layer.borderColor = dividerColor.cgColor</span><br><span class="line">        <span class="keyword">self</span>.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个扩展方法我只暴露了三种颜色的修改，大家可以根据自己需求修改。<br>最后就是使用了，注意这里如果进行了自定义，不能用 autoLayout 了, 需指定 Segement 的位置大小，不然显示出来的效果被压缩成了一条线，我估计是 setBackgroundImage 的方法需要把 1x1 的颜色图片进行填充，如果不指定大小会出差错。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> segment = <span class="type">UISegmentedControl</span>(items: [<span class="string">"测试"</span>, <span class="string">"测试"</span>, <span class="string">"测试"</span>])</span><br><span class="line">segment.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">150</span>, height: <span class="number">40</span>)</span><br><span class="line">segment.setSegmentStyle(normalColor: <span class="type">UIColor</span>.clear, selectedColor: <span class="type">UIColor</span>.cyan, dividerColor: <span class="type">UIColor</span>.gray)</span><br><span class="line">segment.selectedSegmentIndex = <span class="number">0</span></span><br><span class="line">view.addSubview(segment)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zyphs21/cdn-assets/photo/uisegment/testSegment.png" alt="image.png"></p><p>个人比较喜欢用 extension 扩展方法，这里大家直接拷贝就能够使用了，祝大家自定义愉快吧~</p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HSStockChart介绍</title>
      <link href="/2017/05/03/HSStockChart%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/05/03/HSStockChart%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>HSStockChart 是一个绘制股票分时图、K 线图的库。支持流畅的回弹拖动，长按十字线，捏合放大缩小等功能，主要使用了 CAShapeLayer 来绘图，相比使用 Core Graphics 和重写 drawRect 的方法更高效，占用内存更小。<br><a href="https://github.com/zyphs21/HSStockChart" target="_blank" rel="noopener">GitHub 地址：HSStockChart</a>  </p><p><img src="https://cdn.jsdelivr.net/gh/zyphs21/HSStockChart/DemoScreenshot/HSStockChart.gif" alt=""></p><a id="more"></a><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li><input checked="" disabled="" type="checkbox"> 支持绘制分时图，五日分时图，K 线图，MA 线指标，交易量柱等。</li><li><input checked="" disabled="" type="checkbox"> 支持横屏查看。</li><li><input checked="" disabled="" type="checkbox"> K 线图利用 <code>UIScrollView</code> 达到流畅的滑动查看效果。</li><li><input checked="" disabled="" type="checkbox"> 使用 <code>CAShapeLayer</code> 绘图，内存占用更小，效率更高。</li></ul><h2 id="版本需求"><a href="#版本需求" class="headerlink" title="版本需求"></a>版本需求</h2><ul><li>iOS 8.0+</li><li>Swift 3</li></ul><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ol><li><p>之前绘图的方法是重写 <code>drawRect</code> 方法，在方法里获取 <code>CGContext</code> 然后利用Core Graphics 来进行绘图，调用 <code>setNeedsDisplay</code> 来刷新。但是这种方法有个问题是：</p><blockquote><p>一旦你实现了 CALayerDelegate 协议中的 -drawLayer:inContext: 方法或者 UIView 中的 -drawRect: 方法（其实就是前者的包装方法），图层就创建了一个绘制上下文，这个上下文需要的内存可从这个公式得出：图层宽x图层高x4字节，宽高的单位均为像素。对于一个在 Retina iPad 上的全屏图层来说，这个内存量就是 2048x1526x4字节，相当于12MB内存，图层每次重绘的时候都需要重新抹掉内存然后重新分配。【摘自 iOS Core Animation- Advanced Techniques 中文译本 高效绘图一章】</p></blockquote><p>因为我要达到流畅滑动查看的效果，所以在 <code>UIScrollView</code> 上添加了一个 <code>UIView</code> 这个 View 的宽度会依据当前展示数据的多少而变化，结合 <code>UIScrollView</code> 的 <code>ContentSize</code> 就能达到很好的滑动效果。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/zyphs21/HSStockChart/DemoScreenshot/scrollTheory.png" alt=""></p><p>  如果我用之前重写 <code>drawRect</code> 的方法，那么这个 View 会根据数据量的变大而变大，从而导致绘图内存急剧上升，数据量大的时候会崩溃。基于此，我采用了 <code>CAShapeLayer</code> 的方式绘图，此方式的特点如下：</p><blockquote><p>CAShapeLayer 是一个通过矢量图形而不是 bitmap 来绘制的图层子类。你指定诸如颜色和线宽等属性，用 CGPath 来定义想要绘制的图形，最后就自动渲染出来了。当然，你也可以用 Core Graphics 直接向原始的内容中绘制一个路径，相比之下，使用 CAShapeLayer 有以下一些优点:</p><ul><li>渲染快速。CAShapeLayer 使用了硬件加速，绘制同一图形会比用 Core Graphics 快很多。</li><li>高效使用内存。一个 CAShapeLayer 不需要像普通 CALayer 一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。 </li><li>不会被图层边界剪裁掉，一个 CAShapeLayer 可以在边界之外绘制。你的图层路径不会像在使用 Core Graphics 的普通 CALayer 一样被剪裁掉。</li><li>不会出现像素化。当你给 CAShapeLayer 做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化</li></ul></blockquote><p>  最终在真机上测试(注意是在真机上测试)两种方式的结果如图，内存大大降低并且稳定在13M左右</p><p><img src="https://cdn.jsdelivr.net/gh/zyphs21/HSStockChart/DemoScreenshot/memoryUseExample.png" alt=""></p><ol start="2"><li>自定义 CAShapeLayer，重写 action(forKey event: String) 方法。目的是 关闭 CAShapeLayer 的隐式动画，避免滑动时候或者十字线出现时有残影的现象(实际上是因为 Layer 的 position 属性变化而产生的隐式动画)</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HSCAShapeLayer</span>: <span class="title">CAShapeLayer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">action</span><span class="params">(forKey event: String)</span></span> -&gt; <span class="type">CAAction?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>Released under MIT License.</p>]]></content>
      
      
      <categories>
          
          <category> 开源/产品 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
